<!DOCTYPE html>
<html lang="ja">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, user-scalable=yes">
    <title>WorldWeaver - 次世代創作Wiki</title>

    <!-- React & ReactDOM -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>

    <!-- Babel -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>

    <!-- Leaflet -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

    <!-- Lucide Icons -->
    <script src="https://unpkg.com/lucide@latest"></script>

    <!-- Quill.js -->
    <link href="https://cdn.quilljs.com/1.3.6/quill.snow.css" rel="stylesheet">
    <script src="https://cdn.quilljs.com/1.3.6/quill.min.js"></script>

    <!-- Google Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link
        href="https://fonts.googleapis.com/css2?family=Noto+Sans+JP:wght@300;400;500;700&family=Shippori+Mincho:wght@400;600&display=swap"
        rel="stylesheet">

    <!-- Firebase SDK -->
    <script type="module">
        import { initializeApp, deleteApp, getApps } from "https://www.gstatic.com/firebasejs/10.14.1/firebase-app.js";
        import { getAuth, signInWithEmailAndPassword, createUserWithEmailAndPassword, signInAnonymously, onAuthStateChanged, signOut, updateProfile, setPersistence, browserLocalPersistence } from "https://www.gstatic.com/firebasejs/10.14.1/firebase-auth.js";
        import { getFirestore, collection, doc, setDoc, addDoc, updateDoc, deleteDoc, onSnapshot, serverTimestamp, query, where, getDoc } from "https://www.gstatic.com/firebasejs/10.14.1/firebase-firestore.js";
        import { getStorage, ref, uploadBytes, getDownloadURL } from "https://www.gstatic.com/firebasejs/10.14.1/firebase-storage.js";

        window.firebaseModules = {
            initializeApp, deleteApp, getApps,
            getAuth, signInWithEmailAndPassword, createUserWithEmailAndPassword, signInAnonymously, onAuthStateChanged, signOut, updateProfile, setPersistence, browserLocalPersistence,
            getFirestore, collection, doc, setDoc, addDoc, updateDoc, deleteDoc, onSnapshot, serverTimestamp, query, where, getDoc,
            getStorage, ref, uploadBytes, getDownloadURL
        };
    </script>

    <style>
        /* フォント指定 */
        body {
            font-family: 'Noto Sans JP', sans-serif;
            background-color: #f3f4f6;
        }

        .serif {
            font-family: 'Shippori Mincho', serif;
        }

        /* その他のスタイル */
        #map-container {
            height: 100%;
            width: 100%;
            z-index: 0;
        }

        .wiki-link {
            color: #2563eb;
            text-decoration: underline;
            cursor: pointer;
        }

        .wiki-link:hover {
            color: #1d4ed8;
            background-color: rgba(37, 99, 235, 0.1);
        }

        .folder-tree-item {
            cursor: pointer;
            user-select: none;
        }

        .folder-tree-item:hover {
            background-color: #f3f4f6;
        }

        .rich-editor h1 {
            font-size: 1.5em;
            font-weight: bold;
            margin: 0.5em 0;
        }

        .rich-editor h2 {
            font-size: 1.3em;
            font-weight: bold;
            margin: 0.5em 0;
            border-bottom: 1px solid #ddd;
        }

        .rich-editor ul {
            list-style-type: disc;
            margin-left: 1.5em;
        }

        .rich-editor ol {
            list-style-type: decimal;
            margin-left: 1.5em;
        }

        .rich-editor blockquote {
            border-left: 4px solid #ccc;
            padding-left: 1em;
            color: #666;
        }

        /* Quill Editor Customization */
        .ql-container {
            font-family: 'Noto Sans JP', sans-serif;
            font-size: 16px;
        }

        .ql-editor {
            min-height: 200px;
        }

        /* カスタムスクロールバー */
        .custom-scrollbar::-webkit-scrollbar {
            width: 6px;
            height: 6px;
        }

        .custom-scrollbar::-webkit-scrollbar-track {
            background: #f1f1f1;
        }

        .custom-scrollbar::-webkit-scrollbar-thumb {
            background: #ccc;
            border-radius: 3px;
        }

        .custom-scrollbar::-webkit-scrollbar-thumb:hover {
            background: #aaa;
        }

        /* CSV block table styling: 罫線付きで表示 */
        .csv-block table {
            border-collapse: collapse;
            width: 100%;
            border: 1px solid #444;
        }

        .csv-block th,
        .csv-block td {
            border: 1px solid #444;
            padding: 6px;
        }

        .csv-block table,
        .csv-block th,
        .csv-block td {
            border-color: #444;
        }

        /* Placeholder style when table HTML is omitted from editor content */
        .csv-block .csv-placeholder {
            border: 1px dashed #666;
            padding: 8px;
            background: #fff;
            color: #222;
            font-size: 13px;
            border-radius: 6px;
            text-align: center;
        }

        /* スナップスクロール用 */
        .snap-y-mandatory {
            scroll-snap-type: y mandatory;
        }

        .snap-center {
            scroll-snap-align: center;
        }

        .snap-x-mandatory {
            scroll-snap-type: x mandatory;
        }

        .snap-start {
            scroll-snap-align: start;
        }

        /* マインドマップ風ライン */
        .mindmap-branch {
            position: absolute;
            left: -2rem;
            top: 50%;
            width: 2rem;
            height: 1px;
            background-color: rgba(255, 255, 255, 0.3);
        }

        /* タイムラインメーター */
        .timeline-ruler {
            background-image: linear-gradient(to bottom, rgba(255, 255, 255, 0.2) 1px, transparent 1px);
            background-size: 100% 40px;
        }

        /* スムーズスクロール */
        .scroll-smooth {
            scroll-behavior: smooth;
        }

        /* マップラベル */
        .leaflet-tooltip.map-label {
            background-color: rgba(255, 255, 255, 0.85);
            border: 1px solid rgba(0, 0, 0, 0.1);
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.2);
            font-size: 11px;
            font-weight: bold;
            color: #333;
            padding: 0px 4px;
            border-radius: 4px;
            margin-top: -3px;
        }
    </style>
</head>

<body>
    <div id="root"></div>

    <script type="text/babel">
        // --- デフォルト設定 ---
        const DEFAULT_CONFIG = {
            apiKey: "AIzaSyDp-ct-XP-4O-6Z_sZVFjyrgmDGbTplCps",
            authDomain: "rtts-studio.firebaseapp.com",
            projectId: "rtts-studio",
            storageBucket: "rtts-studio.firebasestorage.app",
            messagingSenderId: "980630089634",
            appId: "1:980630089634:web:7a3ee9ed7e118b99598cfb",
            measurementId: "G-D5YX71KKVP"
        };

        // 初期のデータID
        const DEFAULT_APP_CONTEXT_ID = 'world-weaver-wiki-v4';

        const ARTICLE_TYPES = {
            person: { label: '人物', color: 'bg-blue-100 text-blue-800', icon: 'user' },
            event: { label: '事象', color: 'bg-red-100 text-red-800', icon: 'flame' },
            region: { label: '地域', color: 'bg-green-100 text-green-800', icon: 'map' },
            organization: { label: '組織', color: 'bg-purple-100 text-purple-800', icon: 'building' },
            ideology: { label: '思想・宗教', color: 'bg-emerald-100 text-emerald-800', icon: 'star' },
            item: { label: '物品', color: 'bg-amber-100 text-amber-800', icon: 'package' },
            other: { label: 'その他', color: 'bg-gray-100 text-gray-800', icon: 'box' }
        };

        // ビュー設定：構造年表（Large Timeline）をメインの年表として統合
        const VIEW_TABS = [
            { key: 'list', label: '一覧', icon: 'list' },
            { key: 'map', label: '地図', icon: 'map' },
            { key: 'timeline_large', label: '構造年表', icon: 'git-branch' },
            { key: 'stats', label: '統計', icon: 'bar-chart-2' }
        ];

        // Region tag rules: define rectangles or circles to auto-assign tags when a location falls inside.
        // Rectangle example: { tag: 'north', type: 'rect', bounds: { latMin: -500, latMax: 500, lngMin: -500, lngMax: 0 } }
        // Circle example: { tag: 'capital', type: 'circle', center: { lat: 0, lng: 0 }, radiusKm: 100 }
        // Leave empty to disable auto region tags.
        const REGION_TAG_RULES = [
            // { tag: 'north', type: 'rect', bounds: { latMin: -500, latMax: 500, lngMin: -500, lngMax: 0 } },
            // { tag: 'capital', type: 'circle', center: { lat: 0, lng: 0 }, radiusKm: 100 }
        ];

        // Region auto-tag rules default (editable via GUI)
        const REGION_TAG_RULES_DEFAULT = [
            // { tag: 'north', type: 'rect', bounds: { latMin: -500, latMax: 500, lngMin: -500, lngMax: 0 } },
            // { tag: 'capital', type: 'circle', center: { lat: 0, lng: 0 }, radiusKm: 100 }
        ];

        const createEmptyArticle = () => ({
            title: '',
            type: 'person',
            folder: '未分類',
            contentHtml: '',
            year: 0,
            period: { start: '', end: '' }, // 期間設定用
            dateStr: '',
            representedTag: '',
            locations: [], // 複数地点用 { lat, lng, label }
            locationArticleId: '',
            mainImageUrl: ''
            , noYear: false
            , importance: 3 // 重要度 (1-5)
            , attachments: [] // { name, url }
            , _editorMode: 'wysiwyg' // default editor view
        });

        const stripHtml = (html = '') => html.replace(/<[^>]*>/g, ' ');

        // 年代抽出ユーティリティ
        const parseYear = (val) => {
            if (!val) return 0;
            if (typeof val === 'number') return val;
            // 文字列の場合、先頭の数字（負号含む）を年とみなす
            const match = val.toString().match(/^(\-?\d+)/);
            return match ? parseInt(match[1], 10) : 0;
        };

        // ソート用キー計算（期間がある場合は平均年を使用）
        const getArticleYear = (article) => {
            if (article.period && (article.period.start || article.period.end)) {
                const start = parseYear(article.period.start) || parseYear(article.year);
                const end = parseYear(article.period.end) || start;
                return (start + end) / 2;
            }
            // dateStrがある場合はそちらを優先
            if (article.dateStr) {
                return parseYear(article.dateStr);
            }
            return article.year || 0;
        };

        const chronologyKey = (article) => {
            const y = getArticleYear(article);
            // ゼロ埋めして文字列化（マイナス年も考慮してオフセットを加える簡易実装）
            return String(Math.floor(y + 100000)).padStart(10, '0');
        };

        const sortByChronology = (list = []) => [...list].sort((a, b) => {
            const ya = getArticleYear(a);
            const yb = getArticleYear(b);
            // treat missing/zero year as large value so they sort after dated items
            const va = (!ya || Number.isNaN(ya) || Number(ya) === 0) ? Number.MAX_SAFE_INTEGER : ya;
            const vb = (!yb || Number.isNaN(yb) || Number(yb) === 0) ? Number.MAX_SAFE_INTEGER : yb;
            return va - vb;
        });

        const filterTimelineArticles = (articles = [], filters = { type: 'all', keyword: '', tag: '', excludeNoYear: false }) => {
            const keyword = (filters.keyword || '').trim().toLowerCase();
            const tag = (filters.tag || '').replace(/^#/, '').trim().toLowerCase();
            const type = (filters.type || 'all');
            const minImportance = Number(filters.minImportance) || 0;
            return sortByChronology(articles).filter(article => {
                if (filters.excludeNoYear) {
                    const y = getArticleYear(article);
                    if (!y || Number.isNaN(y) || Number(y) === 0) return false;
                }
                if (filters.onlyApproved && !article.isApproved) return false;
                if (type !== 'all' && article.type !== type) return false;
                if (minImportance > 0 && (article.importance || 3) < minImportance) return false;
                if (keyword) {
                    const haystack = [
                        article.title,
                        article.folder,
                        stripHtml(article.contentHtml || ''),
                        (article.tags || []).join(' '),
                        article.representedTag || ''
                    ].join(' ').toLowerCase();
                    if (!haystack.includes(keyword)) return false;
                }
                if (tag) {
                    const tags = (article.tags || []).map(t => t.toLowerCase());
                    const rep = (article.representedTag || '').toLowerCase();
                    if (!tags.includes(tag) && rep !== tag) return false;
                }
                return true;
            });
        };

        // 記事が持つ全ての地点を取得
        const getArticleLocations = (article) => {
            if (!article) return [];
            const locs = [];
            // 新仕様: locations配列
            if (article.locations && Array.isArray(article.locations)) {
                article.locations.forEach(l => {
                    if (l.lat != null && l.lng != null) locs.push({ lat: parseFloat(l.lat), lng: parseFloat(l.lng), label: l.label || article.title, sourceId: article.id });
                });
            }
            // 旧仕様: lat, lng (互換性のため)
            if (article.lat != null && article.lng != null && article.lat !== '' && article.lng !== '') {
                const lat = parseFloat(article.lat);
                const lng = parseFloat(article.lng);
                // 重複チェック（簡易）
                if (!locs.some(l => Math.abs(l.lat - lat) < 0.0001 && Math.abs(l.lng - lng) < 0.0001)) {
                    locs.push({ lat, lng, label: article.title, sourceId: article.id });
                }
            }
            return locs;
        };

        // 再帰的に場所解決
        const resolveArticleLocation = (article, lookup = new Map(), visited = new Set()) => {
            if (!article) return null;
            const locs = getArticleLocations(article);
            if (locs.length > 0) return locs[0]; // 代表地点を返す

            if (article.locationArticleId) {
                if (visited.has(article.locationArticleId)) return null;
                visited.add(article.locationArticleId);
                return resolveArticleLocation(lookup.get(article.locationArticleId), lookup, visited);
            }
            return null;
        };

        // haversine distance (km) for circle-based region checks
        const haversineDistanceKm = (a, b) => {
            const R = 6371;
            const toRad = (x) => (x * Math.PI) / 180;
            const dLat = toRad(b.lat - a.lat);
            const dLng = toRad(b.lng - a.lng);
            const lat1 = toRad(a.lat);
            const lat2 = toRad(b.lat);
            const sinDLat = Math.sin(dLat / 2);
            const sinDLng = Math.sin(dLng / 2);
            const h = sinDLat * sinDLat + Math.cos(lat1) * Math.cos(lat2) * sinDLng * sinDLng;
            return 2 * R * Math.asin(Math.min(1, Math.sqrt(h)));
        };

        // Decide region tags based on location points and REGION_TAG_RULES
        const computeRegionTags = (locations = [], rules = REGION_TAG_RULES_DEFAULT) => {
            const tags = new Set();
            if (!Array.isArray(locations) || locations.length === 0) return [];
            (rules || []).forEach(rule => {
                if (!rule || !rule.tag) return;
                if (rule.type === 'rect' && rule.bounds) {
                    const { latMin, latMax, lngMin, lngMax } = rule.bounds;
                    locations.forEach(loc => {
                        if (loc.lat == null || loc.lng == null) return;
                        if (loc.lat >= latMin && loc.lat <= latMax && loc.lng >= lngMin && loc.lng <= lngMax) {
                            tags.add(rule.tag);
                        }
                    });
                } else if (rule.type === 'circle' && rule.center && rule.radiusKm != null) {
                    locations.forEach(loc => {
                        if (loc.lat == null || loc.lng == null) return;
                        const d = haversineDistanceKm(rule.center, { lat: Number(loc.lat), lng: Number(loc.lng) });
                        if (d <= rule.radiusKm) tags.add(rule.tag);
                    });
                }
            });
            return Array.from(tags);
        };

        const getAdjacentArticles = (articles = [], currentId = null) => {
            if (!currentId) return { previous: null, next: null };
            const idx = articles.findIndex(a => a.id === currentId);
            return {
                previous: idx > 0 ? articles[idx - 1] : null,
                next: idx >= 0 && idx < articles.length - 1 ? articles[idx + 1] : null
            };
        };

        // Wiki Plugin Processor & Parser (PukiWiki Style)
        let parsePukiWikiSyntax; // Forward declaration

        const processPukiWikiPlugin = (name, args, content, isBlock) => {
            const argList = (args || '').split(',').map(s => s.trim());

            if (name.toLowerCase() === 'br') return '<br />';

            if (name === 'size') {
                return `<span style="font-size:${argList[0]}px">${content}</span>`;
            }
            if (name === 'color') {
                return `<span style="color:${argList[0]}; ${argList[1] ? 'background-color:' + argList[1] : ''}">${content}</span>`;
            }
            if (name === 'attachref' || name === 'ref') {
                const src = argList[0] || content;
                let w, h;
                if (argList[1]) {
                    const dim = argList[1].match(/(\d+)x(\d+)/);
                    if (dim) { w = dim[1]; h = dim[2]; }
                    else if (argList[1].endsWith('%')) { w = argList[1]; }
                }
                return `<img src="${src}" style="${w ? 'width:' + w + (w.includes('%') ? '' : 'px') + ';' : ''} ${h ? 'height:' + h + 'px;' : ''}" class="inline-block" />`;
            }
            if (name === 'cssbox') {
                return `<div style="${args}">${parsePukiWikiSyntax ? parsePukiWikiSyntax(content) : content}</div>`;
            }
            if (name === 'flex_container') {
                const [jus, ali, wrp] = argList;
                let style = 'display:flex; gap:10px;';
                if (jus) style += `justify-content:${jus};`;
                if (ali) style += `align-items:${ali};`;
                if (wrp) style += `flex-wrap:${wrp};`;
                return `<div style="${style}">${parsePukiWikiSyntax ? parsePukiWikiSyntax(content) : content}</div>`;
            }
            if (name === 'flex_box') {
                const w = argList[0];
                return `<div style="${w ? 'flex-basis:' + w + '; width:' + w + ';' : 'flex:1;'}">${parsePukiWikiSyntax ? parsePukiWikiSyntax(content) : content}</div>`;
            }
            if (name === 'skin') return content;
            if (name === 'marquee') return `<marquee>${args}</marquee>`;
            if (name === 'contents') return '';
            if (name === 'fold') return `<details><summary class="cursor-pointer font-bold text-indigo-600">${args || '詳細'}</summary><div class="pl-4 border-l-2 ml-1 mt-1">${parsePukiWikiSyntax ? parsePukiWikiSyntax(content) : content}</div></details>`;
            if (name === 'comment') return '<div class="text-xs text-gray-400 p-2 border bg-gray-50 my-2">[コメント欄]</div>';
            return null;
        };

        parsePukiWikiSyntax = (text) => {
            if (!text) return '';

            // 0. Pre-process HTML
            const decodeHtml = (html) => {
                const txt = document.createElement("textarea");
                txt.innerHTML = html;
                return txt.value;
            };

            let cleanText = text
                .replace(/\r/g, '') // Normalize newlines
                .replace(/<br\s*\/?>/gi, '&br;')
                .replace(/<\/p>/gi, '\n')
                .replace(/<\/div>/gi, '\n')
                .replace(/<\/tr>/gi, '\n')
                .replace(/<\/li>/gi, '\n');

            cleanText = decodeHtml(cleanText);

            let res = cleanText;

            // 1. Recursive Layout/Block Plugin Parser
            for (let i = 0; i < 20; i++) {
                const regex = /(?:#|&)([a-zA-Z0-9_]+)(?:\(([^)]*)\))?(\{+)([\s\S]*?)(\}+)(;?)/g;
                let matched = false;
                res = res.replace(regex, (m, name, args, open, content, close, semi) => {
                    if (open.length !== close.length) return m;
                    matched = true;
                    // The recursive call happens inside processPukiWikiPlugin now
                    const p = processPukiWikiPlugin(name, args, content, open.startsWith('#'));
                    return p !== null ? p : m;
                });
                if (!matched) break;
            }

            const splitTableRow = (rowStr) => {
                const cells = [];
                let current = '';
                let depthBracket = 0;
                let depthBrace = 0;
                for (let i = 0; i < rowStr.length; i++) {
                    const char = rowStr[i];
                    if (char === '[' && rowStr[i + 1] === '[') { depthBracket++; i++; current += '[['; continue; }
                    if (char === ']' && rowStr[i + 1] === ']') { depthBracket--; i++; current += ']]'; continue; }
                    if (char === '{') depthBrace++;
                    if (char === '}') depthBrace--;
                    if (char === '|' && depthBracket === 0 && depthBrace === 0) {
                        cells.push(current);
                        current = '';
                    } else {
                        current += char;
                    }
                }
                cells.push(current);
                return cells;
            };

            const processInline = (str) => {
                let s = str;
                for (let i = 0; i < 10; i++) {
                    let replaced = false;
                    s = s.replace(/(&|#)([a-zA-Z0-9_]+)(?:\(([^)]*)\))?(?:\{([^}]*)\})?(;?)/g, (m, type, name, args, blockContent, semi) => {
                        replaced = true;
                        const p = processPukiWikiPlugin(name, args, blockContent || '', type === '#');
                        return p !== null ? p : m;
                    });
                    if (!replaced) break;
                }
                s = s.replace(/'''([^']+)'''/g, '<i>$1</i>');
                s = s.replace(/''([^']+)''/g, '<b>$1</b>');
                s = s.replace(/\[\[([^\]|]+)\|([^\]]+)\]\]/g, '<span class="wiki-link" data-article-id="$2">🔗 $1</span>');
                s = s.replace(/\[\[([^\]]+)\]\]/g, '<span class="wiki-link" data-wiki-title="$1">🔗 $1</span>');
                return s;
            };

            const lines = res.split('\n');
            const outLines = [];
            let inTable = false;
            let tableRows = [];

            const flushTable = () => {
                if (!inTable) return;
                let html = '<div class="overflow-x-auto my-2"><table class="wiki-table min-w-full border-collapse border border-gray-400 bg-white text-sm">';
                tableRows.forEach(row => {
                    html += '<tr>';
                    const cells = splitTableRow(row.trim());
                    if (cells.length > 0 && cells[0].trim() === '') cells.shift();
                    if (cells.length > 0 && cells[cells.length - 1].trim() === '') cells.pop();
                    if (cells.length === 0) return;
                    cells.forEach(cell => {
                        let c = cell;
                        let tag = 'td';
                        let style = 'border: 1px solid #cbd5e1; padding: 6px;';
                        while (true) {
                            c = c.trim();
                            if (c.startsWith('~')) { tag = 'th'; c = c.substring(1); style += 'background-color:#f1f5f9; font-weight:bold;'; continue; }
                            if (c.startsWith('BGCOLOR')) {
                                const m = c.match(/^BGCOLOR\(([^)]+)\):/);
                                if (m) { style += `background-color:${m[1]};`; c = c.substring(m[0].length); continue; }
                            }
                            if (c.startsWith('CENTER:')) { style += 'text-align:center;'; c = c.substring(7); continue; }
                            if (c.startsWith('LEFT:')) { style += 'text-align:left;'; c = c.substring(5); continue; }
                            if (c.startsWith('RIGHT:')) { style += 'text-align:right;'; c = c.substring(6); continue; }
                            if (c === '>') { c = '&nbsp;'; }
                            break;
                        }
                        html += `<${tag} style="${style}">${processInline(c)}</${tag}>`;
                    });
                    html += '</tr>';
                });
                html += '</table></div>';
                outLines.push(html);
                tableRows = [];
                inTable = false;
            };

            lines.forEach(line => {
                let l = line.trim();

                // Table
                if (l.startsWith('|')) {
                    inTable = true;
                    tableRows.push(l);
                    return;
                }
                flushTable();

                // Headers
                const parseHeader = (line, level) => {
                    let text = line.substring(level).trim();
                    let id = Math.random().toString(36).substr(2, 9);
                    const anchorMatch = text.match(/\[#([a-zA-Z0-9_-]+)\]$/);
                    if (anchorMatch) {
                        id = anchorMatch[1];
                        text = text.substring(0, text.length - anchorMatch[0].length).trim();
                    }
                    return { text, id };
                };

                if (l.startsWith('***')) { const h = parseHeader(l, 3); outLines.push(`<h4 id="${h.id}" class="text-lg font-bold mt-2 border-b border-gray-200 pb-1 flex items-center gap-2"><span class="w-1 h-4 bg-indigo-300 inline-block"></span>${processInline(h.text)}</h4>`); return; }
                if (l.startsWith('**')) { const h = parseHeader(l, 2); outLines.push(`<h3 id="${h.id}" class="text-xl font-bold mt-3 mb-2 border-b-2 border-indigo-100 flex items-center gap-2"><span class="w-2 h-2 rounded-full bg-indigo-500 inline-block"></span>${processInline(h.text)}</h3>`); return; }
                if (l.startsWith('*')) { const h = parseHeader(l, 1); outLines.push(`<h2 id="${h.id}" class="text-2xl font-bold mt-6 mb-3 border-b-2 border-indigo-600 pb-1 serif text-indigo-900">${processInline(h.text)}</h2>`); return; }

                // HR
                if (l.startsWith('----')) { outLines.push('<hr class="my-4 border-gray-300 border-dashed">'); return; }

                // Alignments
                if (l.startsWith('CENTER:')) { outLines.push(`<div class="text-center">${processInline(l.substring(7))}</div>`); return; }
                if (l.startsWith('LEFT:')) { outLines.push(`<div class="text-left">${processInline(l.substring(5))}</div>`); return; }
                if (l.startsWith('RIGHT:')) { outLines.push(`<div class="text-right">${processInline(l.substring(6))}</div>`); return; }

                if (l === '') { outLines.push('<br class="my-2" />'); return; }
                outLines.push(processInline(l) + '<br>');
            });
            flushTable();
            return outLines.join('\n');
        };

        // Wiki記法をHTMLリンクに変換する関数 (Wrapper)
        const transformContent = (html) => {
            if (!html) return '';

            // Explicit HTML Mode check
            if (html.trim().startsWith('<!-- html-mode -->') || html.trim().startsWith('<!DOCTYPE html>')) {
                // Just do simple link replacement
                let out = html.replace(/\[\[([^\]|]+)\|([^\]]+)\]\]/g, (match, title, id) => {
                    return `<span class="wiki-link" data-article-id="${id}">🔗 ${title}</span>`;
                });
                out = out.replace(/\[\[([^\]|]+)\]\]/g, (match, title) => {
                    const t = title.trim();
                    return `<span class="wiki-link" data-wiki-title="${t}">🔗 ${t}</span>`;
                });
                return out;
            }

            // Detect Wiki Syntax (Heuristic)
            // If it contains plugin syntax #plugin or &plugin or table | |
            // Updated to catch simple plugins ending with ; like &br;
            if (html.match(/(?:#|&)[a-zA-Z0-9_]+(?:[\(\{;])/) || html.match(/^\|.+\|$/m)) {
                // Ensure the function is defined before calling
                if (parsePukiWikiSyntax) return parsePukiWikiSyntax(html);
            }

            // Fallback for Standard HTML with simple Wiki Links
            let out = html.replace(/\[\[([^\]|]+)\|([^\]]+)\]\]/g, (match, title, id) => {
                return `<span class="wiki-link" data-article-id="${id}">🔗 ${title}</span>`;
            });
            out = out.replace(/\[\[([^\]|]+)\]\]/g, (match, title) => {
                const t = title.trim();
                return `<span class="wiki-link" data-wiki-title="${t}">🔗 ${t}</span>`;
            });
            return out;
        };

        const extractLinkedKeywords = (html = '') => {
            const keywords = new Set();
            let match;
            // 正規表現リテラルを使って修正
            const bracketRegex = /\[\[([^\]]+)\]\]/g;
            const dataRefRegex = /data-(?:link|ref)=\"([^\"]+)\"/g;
            const wikiLinkRegex = /class=\"wiki-link\"[^>]*>(.*?)<\//g;

            while ((match = bracketRegex.exec(html)) !== null) if (match[1]) keywords.add(match[1].trim());
            while ((match = dataRefRegex.exec(html)) !== null) if (match[1]) keywords.add(match[1].trim());
            while ((match = wikiLinkRegex.exec(html)) !== null) {
                const textValue = stripHtml(match[1] || '').trim();
                if (textValue) keywords.add(textValue);
            }
            return Array.from(keywords).filter(Boolean);
        };

        // ハイライトユーティリティ: HTML文字列中のテキストノードに対してキーワードをマークアップする
        const highlightHtml = (html = '', keyword = '') => {
            if (!keyword) return html || '';
            try {
                const parser = new DOMParser();
                const doc = parser.parseFromString(html || '', 'text/html');
                const esc = (s) => s.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
                const re = new RegExp(esc(keyword), 'ig');
                const walker = doc.createTreeWalker(doc.body, NodeFilter.SHOW_TEXT, null, false);
                const nodes = [];
                while (walker.nextNode()) nodes.push(walker.currentNode);
                nodes.forEach(t => {
                    const parent = t.parentNode;
                    if (!parent) return;
                    const text = t.nodeValue;
                    if (!text) return;
                    if (re.test(text)) {
                        const frag = document.createDocumentFragment();
                        let lastIndex = 0;
                        text.replace(re, (match, offset) => {
                            const idx = arguments[arguments.length - 2];
                            if (idx > lastIndex) frag.appendChild(document.createTextNode(text.substring(lastIndex, idx)));
                            const mark = doc.createElement('mark');
                            mark.textContent = match;
                            frag.appendChild(mark);
                            lastIndex = idx + match.length;
                            return match;
                        });
                        if (lastIndex < text.length) frag.appendChild(document.createTextNode(text.substring(lastIndex)));
                        parent.replaceChild(frag, t);
                    }
                });
                return doc.body.innerHTML;
            } catch (e) { return html; }
        };

        const Icon = ({ name, size = 20, className = "" }) => {
            const ref = React.useRef(null);
            React.useEffect(() => {
                if (window.lucide && ref.current) {
                    const i = document.createElement('i');
                    i.setAttribute('data-lucide', name);
                    i.setAttribute('width', size);
                    i.setAttribute('height', size);
                    if (className) i.className = className;
                    ref.current.innerHTML = '';
                    ref.current.appendChild(i);
                    window.lucide.createIcons({ root: ref.current });
                }
            }, [name, size, className]);
            return <span ref={ref} style={{ display: 'inline-flex', lineHeight: 0, verticalAlign: 'middle' }}></span>;
        };

        // ユーティリティ: テキストコピー
        const copyText = (text) => {
            if (navigator.clipboard && navigator.clipboard.writeText) {
                navigator.clipboard.writeText(text).then(() => alert("コピーしました: " + text)).catch(e => alert("コピー失敗"));
            } else {
                const textArea = document.createElement("textarea");
                textArea.value = text;
                textArea.style.position = "fixed";
                textArea.style.left = "-9999px";
                document.body.appendChild(textArea);
                textArea.focus();
                textArea.select();
                try { document.execCommand('copy'); alert("コピーしました: " + text); } catch (err) { alert("コピー失敗"); }
                document.body.removeChild(textArea);
            }
        };

        // --- Config Editor ---
        const ConfigEditor = ({ currentConfig, currentAppId, onSave, onCancel }) => {
            const [text, setText] = React.useState(`const firebaseConfig = ${JSON.stringify(currentConfig, null, 2)};`);
            const [appIdText, setAppIdText] = React.useState(currentAppId || DEFAULT_APP_CONTEXT_ID);
            const [parseError, setParseError] = React.useState(null);
            const handleSave = () => {
                try {
                    let cleanText = text.replace(/\/\/.*$/gm, '').replace(/\/\*[\s\S]*?\*\//g, '').replace(/^(const|var|let)\s+\w+\s*=\s*/, '').replace(/;+\s*$/, '').trim();
                    let config;
                    try { config = JSON.parse(cleanText); } catch (e) { config = new Function(`return ${cleanText}`)(); }
                    if (!config.apiKey) throw new Error("apiKey が空です。");
                    onSave(config, appIdText);
                } catch (e) { setParseError("設定エラー: " + e.message); }
            };
            return (
                <div className="fixed inset-0 bg-black/50 flex items-center justify-center z-[9999] p-4">
                    <div className="bg-white p-6 rounded-lg shadow-xl w-full max-w-2xl flex flex-col max-h-[90vh] overflow-y-auto">
                        <h3 className="text-lg font-bold mb-4 flex items-center gap-2 text-indigo-900 border-b pb-2"><Icon name="settings" /> システム設定</h3>
                        <div className="mb-6"><label className="block text-sm font-bold text-gray-700 mb-1">データID (App ID)</label><input className="w-full border p-2 rounded text-sm font-mono" value={appIdText} onChange={e => setAppIdText(e.target.value)} /></div>
                        <div className="mb-4"><label className="block text-sm font-bold text-gray-700 mb-1">Firebase接続設定</label><textarea className="w-full border p-4 font-mono text-xs h-32" value={text} onChange={e => setText(e.target.value)} /></div>
                        {parseError && <div className="text-red-600 text-xs mb-4 p-2 bg-red-50">{parseError}</div>}
                        <div className="flex justify-end gap-2"><button onClick={onCancel} className="px-4 py-2 bg-gray-200 rounded">キャンセル</button><button onClick={handleSave} className="px-4 py-2 bg-indigo-600 text-white rounded">保存</button></div>
                    </div>
                </div>
            );
        };

        // --- Member Manager ---
        const MemberManager = ({ db, worldId, appContextId, onClose }) => {
            const [members, setMembers] = React.useState([]);
            const [inviteId, setInviteId] = React.useState('');
            const [loading, setLoading] = React.useState(false);

            React.useEffect(() => {
                const { collection, onSnapshot } = window.firebaseModules;
                return onSnapshot(collection(db, 'artifacts', appContextId, 'public', 'data', 'worlds', worldId, 'members'), s => {
                    setMembers(s.docs.map(d => ({ id: d.id, ...d.data() })));
                });
            }, [db, worldId, appContextId]);

            const addMember = async () => {
                if (!inviteId.trim()) return;
                const name = prompt("メンバーの表示名を入力してください (任意)", "");
                setLoading(true);
                try {
                    const { doc, setDoc, serverTimestamp } = window.firebaseModules;
                    await setDoc(doc(db, 'artifacts', appContextId, 'public', 'data', 'worlds', worldId, 'members', inviteId.trim()), {
                        role: 'editor', username: name || '', addedAt: serverTimestamp()
                    });
                    setInviteId('');
                    alert('メンバーを追加しました');
                } catch (e) { alert('追加エラー: ' + e.message); }
                setLoading(false);
            };

            const updateMemberName = async (member) => {
                const newName = prompt("新しい表示名を入力してください", member.username || "");
                if (newName === null) return;
                try {
                    const { doc, updateDoc } = window.firebaseModules;
                    await updateDoc(doc(db, 'artifacts', appContextId, 'public', 'data', 'worlds', worldId, 'members', member.id), {
                        username: newName
                    });
                } catch (e) { alert('更新エラー: ' + e.message); }
            };

            const removeMember = async (uid) => {
                if (!confirm('このメンバーを削除しますか？')) return;
                try {
                    const { doc, deleteDoc } = window.firebaseModules;
                    await deleteDoc(doc(db, 'artifacts', appContextId, 'public', 'data', 'worlds', worldId, 'members', uid));
                } catch (e) { alert('削除エラー: ' + e.message); }
            };

            const toggleApprovalParams = async (member) => {
                try {
                    const { doc, updateDoc } = window.firebaseModules;
                    await updateDoc(doc(db, 'artifacts', appContextId, 'public', 'data', 'worlds', worldId, 'members', member.id), {
                        canApprove: !member.canApprove
                    });
                } catch (e) { alert('更新エラー: ' + e.message); }
            };

            return (
                <div className="fixed inset-0 bg-black/50 flex items-center justify-center z-[9999] p-4">
                    <div className="bg-white p-6 rounded-lg shadow-xl w-full max-w-md">
                        <h3 className="text-lg font-bold mb-4 text-indigo-900 border-b pb-2 flex justify-between items-center">
                            <span>メンバー管理</span>
                            <button onClick={onClose}><Icon name="x" size={20} /></button>
                        </h3>
                        <div className="flex gap-2 mb-4">
                            <input className="border p-2 rounded flex-1 text-sm" placeholder="ユーザーID (UID) を入力" value={inviteId} onChange={e => setInviteId(e.target.value)} />
                            <button onClick={addMember} disabled={loading} className="bg-indigo-600 text-white px-4 py-2 rounded text-sm font-bold">追加</button>
                        </div>
                        <div className="space-y-2 max-h-60 overflow-y-auto">
                            {members.map(m => (
                                <div key={m.id} className="flex justify-between items-center border-b pb-2">
                                    <div className="flex-1">
                                        <div className="flex items-center gap-2">
                                            <span className="text-sm font-bold text-gray-800">{m.username || 'No Name'}</span>
                                            <button onClick={() => updateMemberName(m)} className="text-gray-400 hover:text-indigo-600"><Icon name="edit-2" size={12} /></button>
                                            <span className="text-[10px] text-gray-400 font-mono">({m.id})</span>
                                        </div>
                                        <div className="flex items-center gap-2 mt-1">
                                            <span className={`text-[10px] px-2 py-0.5 rounded ${m.role === 'owner' ? 'bg-red-100 text-red-800' : 'bg-blue-100 text-blue-800'}`}>{m.role}</span>
                                            {m.role !== 'owner' && (
                                                <label className="flex items-center gap-1 text-[10px] cursor-pointer bg-gray-100 px-2 py-0.5 rounded hover:bg-gray-200">
                                                    <input type="checkbox" checked={!!m.canApprove} onChange={() => toggleApprovalParams(m)} />
                                                    承認権限
                                                </label>
                                            )}
                                        </div>
                                    </div>
                                    {m.role !== 'owner' && <button onClick={() => removeMember(m.id)} className="text-red-500 text-xs border px-2 py-1 rounded hover:bg-red-50 ml-2">削除</button>}
                                </div>
                            ))}
                        </div>
                    </div>
                </div>
            );
        };

        // --- Region Rule Editor (Map-based Interactive) ---
        const RegionRuleEditor = ({ rules = [], onSave, onClose, worldData }) => {
            const [items, setItems] = React.useState(rules);
            const [mode, setMode] = React.useState('view'); // view, drawing_rect, drawing_circle
            const [tempPoints, setTempPoints] = React.useState([]);
            const mapRef = React.useRef(null);
            const leafletMap = React.useRef(null);
            const layerGroupRef = React.useRef(null);

            // Init Map
            React.useEffect(() => {
                if (!mapRef.current || leafletMap.current) return;
                const map = L.map(mapRef.current, { crs: L.CRS.Simple, minZoom: -3, maxZoom: 4, zoomControl: true });
                leafletMap.current = map;
                layerGroupRef.current = L.layerGroup().addTo(map);

                // Load Background Image
                const layers = worldData?.mapLayers || (worldData?.mapImageUrl ? [{ id: 'default', url: worldData.mapImageUrl }] : []);
                if (layers.length > 0) {
                    const img = new Image();
                    img.src = layers[0].url;
                    img.onload = () => {
                        const bounds = [[-img.height / 2, -img.width / 2], [img.height / 2, img.width / 2]];
                        L.imageOverlay(layers[0].url, bounds).addTo(map);
                        map.fitBounds(bounds);
                    };
                } else {
                    const bounds = [[-500, -500], [500, 500]];
                    L.rectangle(bounds, { color: "#9ca3af", weight: 1, fill: false }).addTo(map);
                    map.fitBounds(bounds);
                }

                // Click Handler
                map.on('click', (e) => {
                    handleMapClick(e.latlng);
                });
            }, []);

            // Ref for accessing current mode in event handler (if needed) but state works if defined inside component (closure)
            // Render items on map
            React.useEffect(() => {
                if (!leafletMap.current || !layerGroupRef.current) return;
                layerGroupRef.current.clearLayers();

                items.forEach((item, idx) => {
                    const color = ['#6366f1', '#10b981', '#f59e0b', '#ef4444'][idx % 4];
                    let layer = null;
                    if (item.type === 'rect' && item.bounds) {
                        const b = [[item.bounds.latMin, item.bounds.lngMin], [item.bounds.latMax, item.bounds.lngMax]];
                        layer = L.rectangle(b, { color, weight: 2, fillOpacity: 0.2 });
                    } else if (item.type === 'circle' && item.center) {
                        layer = L.circle([item.center.lat, item.center.lng], { radius: (item.radiusKm || 1) * 1000, color, weight: 2, fillOpacity: 0.2 }); // Leaflet circle radius is meters roughly in CRS.Simple? No, it depends.
                        // In CRS.Simple, radius is map units. If "radiusKm" is treated as map units:
                        layer = L.circle([item.center.lat, item.center.lng], { radius: item.radiusKm, color, weight: 2, fillOpacity: 0.2 });
                    }

                    if (layer) {
                        layer.bindTooltip(`<b>${item.tag}</b>`, { permanent: true, direction: 'center', className: 'bg-transparent border-0 font-bold shadow-none' });
                        layer.addTo(layerGroupRef.current);
                    }
                });
            }, [items]);

            const handleMapClick = (latlng) => {
                setMode(prevMode => {
                    if (prevMode === 'drawing_rect') {
                        setTempPoints(prev => {
                            const newPoints = [...prev, latlng];
                            if (newPoints.length === 2) {
                                // Finish Rect
                                const [p1, p2] = newPoints;
                                const latMin = Math.min(p1.lat, p2.lat);
                                const latMax = Math.max(p1.lat, p2.lat);
                                const lngMin = Math.min(p1.lng, p2.lng);
                                const lngMax = Math.max(p1.lng, p2.lng);
                                const tag = prompt("タグ名を入力してください:");
                                if (tag) {
                                    setItems(current => [...current, { tag, type: 'rect', bounds: { latMin, latMax, lngMin, lngMax } }]);
                                }
                                setTempPoints([]);
                                return []; // Reset in next render by mode change
                            }
                            return newPoints;
                        });
                        if (tempPoints.length === 1) return 'view'; // Will be handled by effect or logic above? No, setState is async.
                        // Logic simplified:
                        // If we just added the 2nd point, we are done.
                        // But we need to check the updated state.
                        // Better to handle logic inside the setTempPoints callback or separate ref.
                        return prevMode; // Stay in mode until 2nd point logic executes
                    } else if (prevMode === 'drawing_circle') {
                        setTempPoints(prev => {
                            if (prev.length === 0) {
                                return [latlng]; // Set Center
                            } else {
                                // Set Radius
                                const center = prev[0];
                                const radius = Math.sqrt(Math.pow(latlng.lat - center.lat, 2) + Math.pow(latlng.lng - center.lng, 2));
                                const tag = prompt("タグ名を入力してください:");
                                if (tag) {
                                    setItems(current => [...current, { tag, type: 'circle', center: { lat: center.lat, lng: center.lng }, radiusKm: radius }]);
                                }
                                return [];
                            }
                        });
                    }
                    return prevMode;
                });
            };

            // Side effect to exit mode after shape completion
            React.useEffect(() => {
                if (mode === 'drawing_rect' && tempPoints.length === 2) setMode('view');
                if (mode === 'drawing_circle' && tempPoints.length === 0 && mode !== 'view') setMode('view'); // slightly buggy logic, fix below
            }, [tempPoints]);

            // Fix circle logic: clearing tempPoints implies done
            const handleModeChange = (m) => {
                setMode(m);
                setTempPoints([]);
            };

            const removeItem = (idx) => setItems(items.filter((_, i) => i !== idx));

            return (
                <div className="fixed inset-0 bg-black/50 flex items-center justify-center z-[9999] p-4">
                    <div className="bg-white w-full h-full max-w-6xl max-h-[90vh] rounded-lg shadow-2xl flex flex-col overflow-hidden">
                        <div className="p-4 border-b flex justify-between items-center bg-gray-50">
                            <div className="flex items-center gap-4">
                                <h3 className="text-lg font-bold flex items-center gap-2"><Icon name="map" /> 地域タグ設定</h3>
                                <div className="flex bg-white border rounded p-1 gap-1">
                                    <button onClick={() => handleModeChange('view')} className={`px-3 py-1 rounded text-sm ${mode === 'view' ? 'bg-indigo-100 text-indigo-700 font-bold' : 'hover:bg-gray-100'}`}><Icon name="mouse-pointer" size={14} /> 操作</button>
                                    <button onClick={() => handleModeChange('drawing_rect')} className={`px-3 py-1 rounded text-sm ${mode === 'drawing_rect' ? 'bg-indigo-600 text-white font-bold' : 'hover:bg-gray-100'}`}><Icon name="square" size={14} /> 矩形追加</button>
                                    <button onClick={() => handleModeChange('drawing_circle')} className={`px-3 py-1 rounded text-sm ${mode === 'drawing_circle' ? 'bg-indigo-600 text-white font-bold' : 'hover:bg-gray-100'}`}><Icon name="circle" size={14} /> 円追加</button>
                                </div>
                                <div className="text-sm text-gray-500">
                                    {mode === 'drawing_rect' && (tempPoints.length === 0 ? '始点をクリック' : '終点をクリック')}
                                    {mode === 'drawing_circle' && (tempPoints.length === 0 ? '中心をクリック' : '半径位置をクリック')}
                                </div>
                            </div>
                            <div className="flex gap-2">
                                <button onClick={onClose} className="px-4 py-2 border rounded hover:bg-gray-50">キャンセル</button>
                                <button onClick={() => onSave(items)} className="px-6 py-2 bg-indigo-600 text-white font-bold rounded hover:bg-indigo-700">保存</button>
                            </div>
                        </div>
                        <div className="flex-1 flex overflow-hidden">
                            <div className="w-64 border-r bg-gray-50 overflow-y-auto p-2 space-y-2">
                                <div className="text-xs font-bold text-gray-500 mb-2">登録済みルール ({items.length})</div>
                                {items.map((item, idx) => (
                                    <div key={idx} className="bg-white p-2 rounded border shadow-sm text-sm group">
                                        <div className="flex justify-between items-center font-bold text-gray-800">
                                            <span>{item.tag}</span>
                                            <button onClick={() => removeItem(idx)} className="text-gray-400 hover:text-red-500"><Icon name="trash-2" size={14} /></button>
                                        </div>
                                        <div className="text-xs text-gray-500 mt-1">
                                            {item.type === 'rect' ? '矩形エリア' : '円形エリア'}
                                        </div>
                                    </div>
                                ))}
                                {items.length === 0 && <div className="text-xs text-gray-400 text-center py-4">ルールはまだありません</div>}
                            </div>
                            <div className="flex-1 relative">
                                <div className="absolute inset-0 bg-slate-200" ref={mapRef}></div>
                            </div>
                        </div>
                    </div>
                </div>
            );
        };

        // --- Rich Editor (Quill.js) ---
        // CSV パーサ（簡易実装、引用符と改行に対応）
        const parseCSV = (text, delimiter = ',') => {
            const rows = [];
            let cur = '';
            let row = [];
            let inQuotes = false;
            for (let i = 0; i < text.length; i++) {
                const ch = text[i];
                if (ch === '"') {
                    if (inQuotes && text[i + 1] === '"') { cur += '"'; i++; }
                    else { inQuotes = !inQuotes; }
                } else if (ch === delimiter && !inQuotes) {
                    row.push(cur); cur = '';
                } else if ((ch === '\n' || ch === '\r') && !inQuotes) {
                    if (ch === '\r' && text[i + 1] === '\n') { i++; }
                    row.push(cur); rows.push(row); row = []; cur = '';
                } else { cur += ch; }
            }
            if (cur !== '' || row.length > 0) { row.push(cur); rows.push(row); }
            return rows.map(r => r.map(c => c.trim()));
        };

        const RichTextEditor = React.forwardRef(({ value, onChange }, ref) => {
            const containerRef = React.useRef(null);
            const quillRef = React.useRef(null);

            React.useImperativeHandle(ref, () => ({
                insertLink: (article) => {
                    if (quillRef.current) {
                        const cursor = quillRef.current.getSelection(true);
                        // 独自記法 [[Title|ID]] を挿入
                        quillRef.current.insertText(cursor ? cursor.index : 0, `[[${article.title}|${article.id}]]`);
                    }
                }
                , insertTable: (rows = 3, cols = 2) => {
                    if (quillRef.current) {
                        const cursor = quillRef.current.getSelection(true);
                        // Build a simple CSV representation instead of inserting raw <table> HTML
                        const rowsArr = [];
                        for (let r = 0; r < rows; r++) {
                            const row = [];
                            for (let c = 0; c < cols; c++) row.push(r === 0 ? ('ヘッダ' + (c + 1)) : '');
                            rowsArr.push(row);
                        }
                        const csvText = rowsArr.map(r => r.map(cell => String(cell).includes(',') ? `"${String(cell).replace(/"/g, '""')}"` : cell).join(',')).join('\n');
                        const encoded = encodeURIComponent(csvText);
                        const placeholder = `<div class="csv-block" data-csv="${encoded}"><div class="csv-placeholder">表 (${rows}行×${cols}列) - クリックで編集</div></div><p></p>`;
                        try { quillRef.current.clipboard.dangerouslyPasteHTML(cursor ? cursor.index : 0, placeholder); } catch (e) {
                            try { const editorRoot = containerRef.current.querySelector('.ql-editor'); if (editorRoot) editorRoot.insertAdjacentHTML('beforeend', placeholder); }
                            catch (err) { console.error(err); }
                        }
                    }
                }
                , insertCSV: (csvText) => {
                    if (!csvText) return;
                    const rows = parseCSV(csvText, ',');
                    if (!rows || rows.length === 0) return;
                    const useHeader = window.confirm('CSVの1行目をヘッダとして使いますか？ (はい=ヘッダ)');
                    // wrap CSV data into a csv-block div so the raw CSV is preserved in data-csv
                    const encoded = encodeURIComponent(csvText);
                    let tableHtml = '<table class="inserted-table" border="1" style="border-collapse:collapse;width:100%"><tbody>';
                    rows.forEach((r, ri) => {
                        tableHtml += '<tr>';
                        r.forEach((cell, ci) => {
                            const tag = (useHeader && ri === 0) ? 'th' : 'td';
                            tableHtml += `<${tag} style="padding:6px">${cell || '&nbsp;'}</${tag}>`;
                        });
                        tableHtml += '</tr>';
                    });
                    tableHtml += '</tbody></table>';
                    const wrapper = `<div class="csv-block" data-csv="${encoded}">${tableHtml}</div><p></p>`;
                    try {
                        // Try to paste at cursor (may be sanitized by Quill in some configs)
                        const cursor = quillRef.current.getSelection(true);
                        quillRef.current.clipboard.dangerouslyPasteHTML(cursor ? cursor.index : 0, wrapper);
                        // verify insertion: if no csv-block present after paste, fallback to append
                        const editorRoot = containerRef.current.querySelector('.ql-editor');
                        if (editorRoot && !editorRoot.querySelector('.csv-block')) {
                            // fallback: append to end
                            editorRoot.insertAdjacentHTML('beforeend', wrapper);
                        }
                    } catch (e) {
                        try {
                            const editorRoot = containerRef.current.querySelector('.ql-editor');
                            if (editorRoot) editorRoot.insertAdjacentHTML('beforeend', wrapper);
                        } catch (err) { console.error(err); }
                    }
                }
            }));

            React.useEffect(() => {
                if (containerRef.current && !quillRef.current) {
                    if (typeof Quill === 'undefined') {
                        console.error('Quill is not defined');
                        return;
                    }
                    const quill = new Quill(containerRef.current, {
                        theme: 'snow',
                        modules: {
                            toolbar: [
                                [{ 'header': [1, 2, 3, false] }],
                                ['bold', 'italic', 'underline', 'strike'],
                                [{ 'color': [] }, { 'background': [] }],
                                [{ 'list': 'ordered' }, { 'list': 'bullet' }],
                                [{ 'align': [] }],
                                ['link', 'image', 'blockquote', 'code-block'],
                                ['clean']
                            ]
                        }
                    });

                    quill.on('text-change', () => {
                        const html = containerRef.current.querySelector('.ql-editor').innerHTML;
                        onChange(html);
                    });

                    quillRef.current = quill;
                    // クリックで csv-block を編集するハンドラ
                    const editorRoot = containerRef.current;
                    const onClick = (e) => {
                        const csvEl = e.target.closest && e.target.closest('.csv-block');
                        if (csvEl) {
                            e.preventDefault();
                            const raw = csvEl.getAttribute('data-csv') || '';
                            const decoded = raw ? decodeURIComponent(raw) : '';
                            const newCsv = window.prompt('CSV を編集してください（カンマ区切り）。\nヘッダを含める場合は1行目にヘッダを入れてください。', decoded);
                            if (newCsv !== null) {
                                const rows = parseCSV(newCsv, ',');
                                // update data-csv but keep placeholder-only inner content (no raw table HTML)
                                csvEl.setAttribute('data-csv', encodeURIComponent(newCsv));
                                const rCount = rows.length; const cCount = rows[0] ? rows[0].length : 0;
                                csvEl.innerHTML = `<div class="csv-placeholder">表 (${rCount}行×${cCount}列) - クリックで編集</div>`;
                                // notify change to parent via onChange
                                try { const html = containerRef.current.querySelector('.ql-editor').innerHTML; onChange && onChange(html); } catch (e) { console.error(e); }
                            }
                        }
                    };
                    editorRoot.addEventListener('click', onClick);
                    // cleanup on unmount
                    const cleanup = () => editorRoot.removeEventListener('click', onClick);
                    // attach cleanup to quillRef for potential future removal
                    quillRef.current.__cleanupCsvHandler = cleanup;
                }
            }, []);

            React.useEffect(() => {
                return () => {
                    if (quillRef.current && quillRef.current.__cleanupCsvHandler) {
                        try { quillRef.current.__cleanupCsvHandler(); } catch (e) { }
                    }
                };
            }, []);

            // 初期値設定
            React.useEffect(() => {
                if (quillRef.current && value !== quillRef.current.root.innerHTML) {
                    if (!quillRef.current.hasFocus()) {
                        quillRef.current.root.innerHTML = value || '';
                    }
                }
            }, [value]);

            return (
                <div className="h-full flex flex-col bg-white rounded">
                    <div ref={containerRef} className="flex-1 overflow-hidden min-h-[280px]" style={{ height: '100%' }}></div>
                </div>
            );
        });

        // --- Stats Editor ---
        const StatsEditor = ({ stats = [], onChange }) => {
            const updateStat = (idx, field, val) => { const newStats = [...stats]; newStats[idx][field] = val; onChange(newStats); };
            return (
                <div className="space-y-2">
                    {stats.map((stat, idx) => (
                        <div key={idx} className="flex gap-2 items-center">
                            <input className="border p-1 rounded text-sm w-1/3" value={stat.label} onChange={e => updateStat(idx, 'label', e.target.value)} />
                            <input className="border p-1 rounded text-sm w-1/3" value={stat.value} onChange={e => updateStat(idx, 'value', e.target.value)} />
                            <select className="border p-1 rounded text-sm" value={stat.color} onChange={e => updateStat(idx, 'color', e.target.value)}>
                                <option value="gray">灰</option><option value="red">赤</option><option value="blue">青</option><option value="green">緑</option><option value="yellow">金</option>
                            </select>
                            <button onClick={() => onChange(stats.filter((_, i) => i !== idx))}><Icon name="x" size={16} /></button>
                        </div>
                    ))}
                    <button onClick={() => onChange([...stats, { label: '', value: '', color: 'gray' }])} className="text-xs flex items-center gap-1"><Icon name="plus" size={12} /> 追加</button>
                </div>
            );
        };

        // --- Locations Editor ---
        const LocationsEditor = ({ locations = [], onChange }) => {
            const updateLoc = (idx, field, val) => { const newLocs = [...locations]; newLocs[idx][field] = val; onChange(newLocs); };
            return (
                <div className="space-y-2 bg-gray-50 p-2 rounded border">
                    <label className="text-xs font-bold text-gray-500 block">地点リスト (複数登録可)</label>
                    {locations.map((loc, idx) => (
                        <div key={idx} className="flex gap-2 items-center text-sm">
                            <input placeholder="緯度" type="number" step="0.0001" className="border p-1 rounded w-20" value={loc.lat} onChange={e => updateLoc(idx, 'lat', e.target.value)} />
                            <input placeholder="経度" type="number" step="0.0001" className="border p-1 rounded w-20" value={loc.lng} onChange={e => updateLoc(idx, 'lng', e.target.value)} />
                            <input placeholder="ラベル" className="border p-1 rounded flex-1" value={loc.label} onChange={e => updateLoc(idx, 'label', e.target.value)} />
                            <button onClick={() => onChange(locations.filter((_, i) => i !== idx))} className="text-red-500"><Icon name="x" size={14} /></button>
                        </div>
                    ))}
                    <button onClick={() => onChange([...locations, { lat: 0, lng: 0, label: '' }])} className="text-xs text-indigo-600 flex items-center gap-1"><Icon name="plus" size={12} /> 地点追加</button>
                </div>
            );
        };

        // --- Article Link Inserter ---
        const ArticleLinkInserter = ({ articles, onInsert }) => {
            const [query, setQuery] = React.useState('');
            const [searchMode, setSearchMode] = React.useState('title'); // 'title' or 'tag'

            const filtered = React.useMemo(() => {
                if (!query) return [];
                const lowerQuery = query.toLowerCase();

                if (searchMode === 'tag') {
                    // タグ検索: 記事のタグ配列に部分一致するタグが含まれているかチェック
                    return articles.filter(a =>
                        a.tags && a.tags.some(tag => tag.toLowerCase().includes(lowerQuery))
                    );
                } else {
                    // 記事名検索
                    return articles.filter(a =>
                        a.title.toLowerCase().includes(lowerQuery)
                    );
                }
            }, [articles, query, searchMode]);

            return (
                <div className="space-y-2 bg-white border p-2 rounded">
                    <div className="flex items-center justify-between">
                        <label className="text-xs font-bold text-gray-500">
                            {searchMode === 'title' ? '記事名検索' : 'タグ検索'}
                        </label>
                        <div className="flex gap-1">
                            <button
                                onClick={() => setSearchMode('title')}
                                className={`px-2 py-0.5 text-xs rounded ${searchMode === 'title' ? 'bg-indigo-600 text-white' : 'bg-gray-100 text-gray-600'}`}
                            >
                                記事名
                            </button>
                            <button
                                onClick={() => setSearchMode('tag')}
                                className={`px-2 py-0.5 text-xs rounded ${searchMode === 'tag' ? 'bg-indigo-600 text-white' : 'bg-gray-100 text-gray-600'}`}
                            >
                                タグ
                            </button>
                        </div>
                    </div>
                    <input
                        className="w-full border p-1 text-sm rounded"
                        placeholder={searchMode === 'title' ? '記事名を検索...' : 'タグを検索...'}
                        value={query}
                        onChange={e => setQuery(e.target.value)}
                    />
                    <div className="max-h-48 overflow-y-auto space-y-1 custom-scrollbar">
                        {filtered.map(a => (
                            <div key={a.id} className="w-full text-left text-xs px-2 py-1 hover:bg-indigo-50 rounded group">
                                <div className="flex justify-between items-center gap-2">
                                    <div className="flex-1 pr-2 min-w-0">
                                        <div className="overflow-x-auto whitespace-nowrap text-sm font-medium" style={{ maxWidth: '100%' }} title={a.title}>
                                            {a.title}
                                        </div>
                                        {searchMode === 'tag' && a.tags && a.tags.length > 0 && (
                                            <div className="flex flex-wrap gap-1 mt-1">
                                                {a.tags.map(tag => (
                                                    <span key={tag} className="text-[10px] bg-gray-100 text-gray-600 px-1 rounded">
                                                        #{tag}
                                                    </span>
                                                ))}
                                            </div>
                                        )}
                                    </div>
                                    <div className="flex gap-2 shrink-0">
                                        <button onClick={() => { copyText(a.id); }} className="text-gray-400 hover:text-indigo-600 text-xs">IDコピー</button>
                                        <button onClick={() => { onInsert(a); setQuery(''); }} className="text-indigo-600 font-bold text-xs">挿入</button>
                                    </div>
                                </div>
                            </div>
                        ))}
                        {query && filtered.length === 0 && <div className="text-xs text-gray-400">見つかりません</div>}
                    </div>
                </div>
            );
        };

        // --- Image Uploader ---
        const ImageUploader = ({ onUploadComplete, label = "画像アップロード", storage, appContextId }) => {
            const [uploading, setUploading] = React.useState(false);
            const handleFileChange = async (e) => {
                const file = e.target.files[0];
                if (!file) return;
                if (!storage) { alert("Firebase Storage未設定"); return; }
                setUploading(true);
                const { ref, uploadBytes, getDownloadURL } = window.firebaseModules;
                try {
                    const path = `artifacts/${appContextId || 'default'}/uploads/${Date.now()}_${file.name}`;
                    const storageRef = ref(storage, path);
                    await uploadBytes(storageRef, file);
                    const url = await getDownloadURL(storageRef);
                    onUploadComplete(url);
                } catch (err) { alert("アップロード失敗: " + err.message); } finally { setUploading(false); }
            };
            return (
                <label className={`cursor-pointer inline-flex items-center gap-2 px-3 py-1.5 bg-gray-100 hover:bg-gray-200 rounded text-xs ${uploading ? 'opacity-50' : ''}`}>
                    {uploading ? "..." : <Icon name="image" size={14} />} {label}
                    <input type="file" className="hidden" onChange={handleFileChange} disabled={uploading} />
                </label>
            );
        };

        // --- Attachment Uploader ---
        const AttachmentUploader = ({ onAddAttachment, storage, appContextId }) => {
            const [uploading, setUploading] = React.useState(false);
            const handleFile = async (file) => {
                if (!file) return;
                setUploading(true);
                // If Firebase storage available, upload and use downloadable URL
                if (storage && window.firebaseModules && window.firebaseModules.ref) {
                    try {
                        const { ref, uploadBytes, getDownloadURL } = window.firebaseModules;
                        const path = `artifacts/${appContextId || 'default'}/attachments/${Date.now()}_${file.name}`;
                        const storageRef = ref(storage, path);
                        await uploadBytes(storageRef, file);
                        const url = await getDownloadURL(storageRef);
                        onAddAttachment({ name: file.name, url });
                    } catch (err) {
                        console.error(err);
                        alert('アップロード失敗: ' + err.message);
                    } finally { setUploading(false); }
                } else {
                    // Fallback: embed as data URL (base64)
                    const reader = new FileReader();
                    reader.onload = () => {
                        const url = reader.result;
                        onAddAttachment({ name: file.name, url });
                        setUploading(false);
                    };
                    reader.onerror = () => { alert('ファイル読み込み失敗'); setUploading(false); };
                    reader.readAsDataURL(file);
                }
            };
            return (
                <div className="space-y-2">
                    <label className={`cursor-pointer inline-flex items-center gap-2 px-3 py-1.5 bg-gray-100 hover:bg-gray-200 rounded text-xs ${uploading ? 'opacity-50' : ''}`}>
                        <svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4" /><polyline points="17 8 12 3 7 8" /><line x1="12" y1="3" x2="12" y2="15" /></svg>
                        添付ファイル
                        <input type="file" className="hidden" onChange={e => handleFile(e.target.files[0])} />
                    </label>
                </div>
            );
        };

        // --- Firebase Hooks ---
        const useFirebase = () => {
            const [db, setDb] = React.useState(null);
            const [auth, setAuth] = React.useState(null);
            const [storage, setStorage] = React.useState(null);
            const [user, setUser] = React.useState(null);
            const [loading, setLoading] = React.useState(true);
            const [error, setError] = React.useState(null);
            const [activeConfig, setActiveConfig] = React.useState(null);
            const [appContextId, setAppContextId] = React.useState(DEFAULT_APP_CONTEXT_ID);

            React.useEffect(() => {
                let retry = 0;
                const timer = setInterval(() => {
                    if (window.firebaseModules) { clearInterval(timer); init(window.firebaseModules); }
                    else if (retry++ > 50) { clearInterval(timer); setError("SDK Load Timeout"); setLoading(false); }
                }, 100);
                const init = (modules) => {
                    try {
                        let config = DEFAULT_CONFIG;
                        let appId = DEFAULT_APP_CONTEXT_ID;
                        try { const s = localStorage.getItem('worldweaver_firebase_config'); if (s) config = JSON.parse(s); } catch (e) { }
                        setActiveConfig(config);
                        setAppContextId(appId);
                        const { initializeApp, getAuth, getFirestore, getStorage, onAuthStateChanged, getApps, setPersistence, browserLocalPersistence } = modules;
                        let app = getApps().length > 0 ? getApps()[0] : initializeApp(config);
                        const authInstance = getAuth(app);
                        setAuth(authInstance);
                        setDb(getFirestore(app));
                        try { setStorage(getStorage(app)); } catch (e) { }
                        // ログイン情報を永続化（ブラウザを閉じても保持）
                        setPersistence(authInstance, browserLocalPersistence).catch(e => console.warn('Persistence setup failed:', e));
                        onAuthStateChanged(authInstance, u => { setUser(u); setLoading(false); });
                    } catch (e) { setError(e.message); setLoading(false); }
                };
                return () => clearInterval(timer);
            }, []);
            return { db, auth, storage, user, loading, error, activeConfig, appContextId };
        };

        // --- Views ---
        const WorldList = ({ db, appContextId, onSelect }) => {
            const [worlds, setWorlds] = React.useState([]);
            React.useEffect(() => {
                if (!db || !appContextId) return;
                const { collection, query, onSnapshot } = window.firebaseModules;
                const q = query(collection(db, 'artifacts', appContextId, 'public', 'data', 'worlds'));
                return onSnapshot(q, s => setWorlds(s.docs.map(d => ({ id: d.id, ...d.data() }))));
            }, [db, appContextId]);
            return (<div className="space-y-2 max-h-64 overflow-y-auto custom-scrollbar">{worlds.map(w => (<div key={w.id} onClick={() => onSelect(w.id)} className="p-3 border rounded hover:bg-indigo-50 cursor-pointer flex justify-between items-center transition group"><div><div className="font-bold text-indigo-900 group-hover:text-indigo-700">{w.name}</div><div className="text-xs text-gray-500 truncate w-64">{w.description}</div></div><Icon name="chevron-right" size={16} className="text-gray-300 group-hover:text-indigo-500" /></div>))}{worlds.length === 0 && <div className="text-gray-400 text-sm text-center py-4">世界はまだありません</div>}</div>);
        };

        const FolderTreeItem = ({ name, node, depth = 0, onSelect, selectedFolder }) => {
            const [isOpen, setIsOpen] = React.useState(true);
            const hasChildren = Object.keys(node.children).length > 0;
            const isSelected = selectedFolder === node.fullPath;
            return (
                <div className="select-none">
                    <div className={`flex items-center gap-2 py-1.5 px-2 rounded cursor-pointer transition ${isSelected ? 'bg-indigo-600 text-white font-bold' : 'hover:bg-slate-700 text-slate-300'}`} style={{ paddingLeft: `${depth * 16 + 8}px` }} onClick={() => { if (node.articles.length > 0) onSelect(node); else setIsOpen(!isOpen); }}>
                        {hasChildren ? (<span onClick={(e) => { e.stopPropagation(); setIsOpen(!isOpen); }} className="p-0.5 hover:bg-slate-600 rounded text-slate-400"><Icon name={isOpen ? "chevron-down" : "chevron-right"} size={14} /></span>) : (<span className="w-4"></span>)}
                        <Icon name={hasChildren ? (isOpen ? "folder-open" : "folder") : "folder"} size={14} className={hasChildren ? "text-indigo-400" : "text-slate-500"} />
                        <span className="truncate text-sm flex-1">{name}</span>
                        {node.articles.length > 0 && <span className="text-[10px] bg-slate-700 px-1.5 rounded-full text-slate-300">{node.articles.length}</span>}
                    </div>
                    {isOpen && hasChildren && <div>{Object.entries(node.children).sort((a, b) => a[0].localeCompare(b[0])).map(([childName, childNode]) => (<FolderTreeItem key={childName} name={childName} node={childNode} depth={depth + 1} onSelect={onSelect} selectedFolder={selectedFolder} />))}</div>}
                </div>
            );
        };

        const FolderIntegratedList = ({ articles, onSelectArticle, onTagClick, onOpenNoYear, onSearchChange, onlyApproved = false }) => {
            const [selectedFolderNode, setSelectedFolderNode] = React.useState(null);
            const [query, setQuery] = React.useState('');
            const [showSidebar, setShowSidebar] = React.useState(false);
            const handleContentClick = (e) => {
                const link = e.target.closest && e.target.closest('.wiki-link');
                if (!link) return;
                e.preventDefault(); e.stopPropagation();
                const id = link.getAttribute('data-article-id');
                const wikiTitle = link.getAttribute('data-wiki-title');
                if (id) {
                    const target = articles.find(a => a.id === id);
                    if (target) {
                        // 記事の年代状態に応じてフィルタを調整
                        const y = getArticleYear(target);
                        const hasYear = y && y !== 0 && !target.noYear;
                        if (typeof onSearchChange === 'function') {
                            try { onSearchChange({ excludeNoYear: hasYear }); } catch (e) { console.warn(e); }
                        }
                        if (onSelectArticle) onSelectArticle(target);
                    } else alert('リンク先の記事が見つかりません');
                } else if (wikiTitle) {
                    // handle special wiki titles (例: 年代なし)
                    if (wikiTitle === '年代なし' && onOpenNoYear) {
                        onOpenNoYear();
                        return;
                    }
                    // fallback: try find by exact title
                    const target = articles.find(a => (a.title || '').trim() === wikiTitle.trim());
                    if (target) {
                        // 記事の年代状態に応じてフィルタを調整
                        const y = getArticleYear(target);
                        const hasYear = y && y !== 0 && !target.noYear;
                        if (typeof onSearchChange === 'function') {
                            try { onSearchChange({ excludeNoYear: hasYear }); } catch (e) { console.warn(e); }
                        }
                        if (onSelectArticle) onSelectArticle(target);
                    } else alert('リンク先の記事が見つかりません');
                }
            };
            const folderTree = React.useMemo(() => {
                const root = { name: 'root', fullPath: '', children: {}, articles: [] };
                const allArticlesNode = { name: 'すべての記事', fullPath: 'ALL', children: {}, articles: articles };
                const uncategorizedNode = { name: '未分類', fullPath: '未分類', children: {}, articles: [] };
                articles.forEach(article => {
                    const folderPath = article.folder || '未分類';
                    if (folderPath === '未分類') uncategorizedNode.articles.push(article);
                    else {
                        const parts = folderPath.split('/').filter(Boolean);
                        let current = root;
                        let currentPath = '';
                        parts.forEach((part) => {
                            currentPath = currentPath ? `${currentPath}/${part}` : part;
                            if (!current.children[part]) current.children[part] = { name: part, fullPath: currentPath, children: {}, articles: [] };
                            current = current.children[part];
                        });
                        current.articles.push(article);
                    }
                });
                if (uncategorizedNode.articles.length > 0) root.children['未分類'] = uncategorizedNode;
                return { root, allNode: allArticlesNode };
            }, [articles]);
            React.useEffect(() => { if (!selectedFolderNode && articles.length > 0) setSelectedFolderNode(folderTree.allNode); }, [articles, selectedFolderNode, folderTree]);
            const displayArticles = React.useMemo(() => {
                let target = selectedFolderNode ? selectedFolderNode.articles : [];
                if (onlyApproved) target = target.filter(a => a.isApproved);
                if (query) { const lower = query.toLowerCase(); target = articles.filter(a => [a.title, a.folder, stripHtml(a.contentHtml)].join(' ').toLowerCase().includes(lower)); }
                return sortByChronology(target);
            }, [selectedFolderNode, query, articles, onlyApproved]);
            return (
                <div className="flex h-full bg-slate-900 relative">
                    <div className={`fixed inset-y-0 left-0 z-30 w-64 bg-slate-800 transition-transform transform ${showSidebar ? 'translate-x-0' : '-translate-x-full'} md:translate-x-0 md:static md:flex-shrink-0 border-r border-slate-700 flex flex-col h-full`}>
                        <div className="md:hidden absolute top-2 right-2">
                            <button onClick={() => setShowSidebar(false)} className="text-slate-400 hover:text-white"><Icon name="x" size={20} /></button>
                        </div>
                        <div className="p-3 border-b border-slate-700 bg-slate-800/50"><input className="w-full border border-slate-600 bg-slate-700 text-white placeholder-slate-400 rounded px-2 py-1 text-sm focus:border-indigo-500 focus:outline-none" placeholder="記事を検索..." value={query} onChange={e => setQuery(e.target.value)} /></div>
                        <div className="flex-1 overflow-y-auto p-2 custom-scrollbar">
                            {!query && <><div className={`flex items-center gap-2 py-1.5 px-2 rounded cursor-pointer transition mb-1 ${selectedFolderNode?.fullPath === 'ALL' ? 'bg-indigo-600 text-white font-bold' : 'hover:bg-slate-700 text-slate-300'}`} onClick={() => { setSelectedFolderNode(folderTree.allNode); if (window.innerWidth < 768) setShowSidebar(false); }}><Icon name="layers" size={14} className="text-indigo-400" /><span className="text-sm">すべての記事</span><span className="text-[10px] bg-slate-700 text-slate-300 px-1.5 rounded-full ml-auto">{articles.length}</span></div><hr className="my-2 border-slate-700" />{Object.entries(folderTree.root.children).sort((a, b) => a[0].localeCompare(b[0])).map(([name, node]) => (<FolderTreeItem key={name} name={name} node={node} onSelect={(n) => { setSelectedFolderNode(n); if (window.innerWidth < 768) setShowSidebar(false); }} selectedFolder={selectedFolderNode?.fullPath} />))}</>}
                        </div>
                    </div>
                    {showSidebar && <div className="fixed inset-0 bg-black/50 z-20 md:hidden" onClick={() => setShowSidebar(false)}></div>}
                    <button className="md:hidden fixed bottom-6 right-6 z-50 p-3 bg-indigo-600 rounded-full text-white shadow-lg flex items-center justify-center animate-bounce" onClick={() => setShowSidebar(!showSidebar)}><Icon name="menu" size={24} /></button>
                    <div className="flex-1 overflow-y-auto p-4 bg-slate-900 custom-scrollbar">
                        <div className="max-w-6xl mx-auto space-y-4">
                            {displayArticles.map(article => (
                                <div key={article.id} onClick={() => onSelectArticle && onSelectArticle(article)} className="bg-slate-800/50 border border-slate-700 rounded-xl p-6 cursor-pointer hover:border-indigo-500 hover:bg-slate-800 transition group">
                                    <div className="flex items-center justify-between text-xs text-slate-400 mb-3"><span className={`px-2 py-0.5 rounded ${ARTICLE_TYPES[article.type]?.color}`}>{ARTICLE_TYPES[article.type]?.label}</span><span className="font-mono bg-slate-700 text-slate-300 px-1 rounded">{article.dateStr || article.year}</span></div>
                                    <h3 className="text-xl font-bold text-white group-hover:text-indigo-400 mb-3 flex items-center gap-2">
                                        {article.isApproved && <Icon name="check-circle" size={16} className="text-emerald-400" />}
                                        {article.title}
                                    </h3>
                                    <div className="text-sm text-slate-300 mb-4 leading-relaxed" onClick={handleContentClick} dangerouslySetInnerHTML={{ __html: transformContent(article.contentHtml || '') }}></div>
                                    <div className="flex flex-wrap gap-1 pt-3 border-t border-slate-700">{article.tags?.map(tag => <span key={tag} className="text-xs bg-slate-700 text-slate-300 px-2 py-1 rounded">#{tag}</span>)}</div>
                                </div>
                            ))}
                        </div>
                    </div>
                </div>
            );
        };

        // MapLayerManager: 地図レイヤー管理
        const MapLayerManager = ({ layers = [], onUpdate, storage, appContextId }) => {
            const [name, setName] = React.useState('');
            const handleAdd = (url) => {
                const newLayer = { id: Math.random().toString(36).substr(2, 9), name: name || '新規レイヤー', url };
                onUpdate([...layers, newLayer]);
                setName('');
            };
            const handleRemove = (id) => {
                if (confirm('このレイヤーを削除しますか？')) {
                    onUpdate(layers.filter(l => l.id !== id));
                }
            };
            return (
                <div className="space-y-4">
                    {layers.map((l, i) => (
                        <div key={l.id} className="flex justify-between items-center border p-2 rounded bg-white">
                            <span className="font-bold text-sm">{l.name}</span>
                            <div className="flex items-center gap-2">
                                <a href={l.url} target="_blank" className="text-blue-500 text-xs underline">確認</a>
                                <button onClick={() => handleRemove(l.id)} className="text-red-500 text-xs hover:underline">削除</button>
                            </div>
                        </div>
                    ))}
                    <div className="border border-dashed p-3 rounded bg-gray-50">
                        <div className="text-xs font-bold mb-2 text-gray-500">新規レイヤー追加</div>
                        <input className="w-full border p-1.5 rounded mb-2 text-sm" placeholder="レイヤー名 (例: 1000年, 地下)" value={name} onChange={e => setName(e.target.value)} />
                        <ImageUploader storage={storage} appContextId={appContextId} onUploadComplete={handleAdd} label="画像を追加" />
                    </div>
                </div>
            );
        };

        // MapView: 年代バー付き・複数地点対応・レイヤー切り替え対応
        const MapView = ({ articles = [], worldData, onSelectArticle, onLocationSelect, isEditing = false, storage, highlightArticleId, appContextId, showControls = true, myRole = 'guest', externalQuery, onExternalQueryChange, restrictToHighlightOnEdit = true, minImportance = 0 }) => {
            const mapRef = React.useRef(null);
            const leafletMap = React.useRef(null);
            const markersRef = React.useRef([]);
            const [mapQuery, setMapQuery] = React.useState('');
            const [yearRange, setYearRange] = React.useState({ years: [], min: -1000, max: 3000, index: 0, currentCenter: 1000, range: 2000, manualRange: false });

            // Layer Management
            const [activeLayerId, setActiveLayerId] = React.useState(null);
            const layers = React.useMemo(() => {
                if (Array.isArray(worldData?.mapLayers) && worldData.mapLayers.length > 0) return worldData.mapLayers;
                // fallback legacy
                if (worldData?.mapImageUrl) return [{ id: 'default', name: '標準マップ', url: worldData.mapImageUrl }];
                return [];
            }, [worldData]);

            const activeLayer = React.useMemo(() => {
                if (activeLayerId) {
                    const found = layers.find(l => l.id === activeLayerId);
                    if (found) return found;
                }
                return layers.length > 0 ? layers[0] : null;
            }, [layers, activeLayerId]);

            // Sync active layer ID if needed (initially)
            React.useEffect(() => {
                if (!activeLayerId && layers.length > 0) setActiveLayerId(layers[0].id);
            }, [layers]);


            // 記事全体の年代範囲計算
            React.useEffect(() => {
                if (articles.length > 0) {
                    // build sorted unique integer years from articles
                    const yrs = Array.from(new Set(articles.map(getArticleYear).map(y => Math.floor(y)).filter(y => !isNaN(y)))).sort((a, b) => a - b);
                    if (yrs.length > 0) {
                        const idx = Math.floor(yrs.length / 2);
                        const computeRangeForIndex = (i) => {
                            if (yrs.length === 1) return 50;
                            if (i === 0) return Math.max(50, Math.floor((yrs[1] - yrs[0]) / 2));
                            if (i === yrs.length - 1) return Math.max(50, Math.floor((yrs[i] - yrs[i - 1]) / 2));
                            return Math.max(30, Math.floor(Math.min((yrs[i] - yrs[i - 1]) / 2, (yrs[i + 1] - yrs[i]) / 2)));
                        };
                        const initialRange = computeRangeForIndex(idx);
                        setYearRange({ years: yrs, min: yrs[0], max: yrs[yrs.length - 1], index: idx, currentCenter: yrs[idx], range: initialRange, manualRange: false });
                    }
                }
            }, [articles]);

            const filteredArticles = React.useMemo(() => {
                // Determine effective query (external overrides internal)
                const q = (externalQuery !== undefined ? externalQuery : mapQuery || '').trim().toLowerCase();

                // base set depending on editing mode and restriction flag
                let base = articles;
                if (isEditing && restrictToHighlightOnEdit) {
                    // only show the highlighted/draft article while editing
                    if (highlightArticleId) base = articles.filter(a => a.id === highlightArticleId);
                    else base = articles.filter(a => a.id === '__draft__');
                } else if (!(isEditing || !showControls)) {
                    base = articles.filter(a => {
                        const y = getArticleYear(a);
                        return Math.abs(y - yearRange.currentCenter) <= yearRange.range;
                    });
                }

                if (!q && !minImportance) return base;
                const matches = (a) => {
                    if (minImportance > 0 && (a.importance || 3) < minImportance) return false;
                    const hay = [a.title || '', stripHtml(a.contentHtml || ''), (a.tags || []).join(' '), a.representedTag || ''].join(' ').toLowerCase();
                    return hay.includes(q);
                };
                return base.filter(matches);
            }, [articles, yearRange, isEditing, showControls, mapQuery, externalQuery, highlightArticleId, restrictToHighlightOnEdit, minImportance]);

            React.useEffect(() => {
                if (!mapRef.current || leafletMap.current) return;
                const map = L.map(mapRef.current, { crs: L.CRS.Simple, minZoom: -3, maxZoom: 4, zoomControl: false });
                leafletMap.current = map;
                map.on('click', (e) => isEditing && onLocationSelect && onLocationSelect({ lat: e.latlng.lat, lng: e.latlng.lng }));
            }, []); // Initialize map once

            // Update Image Layer
            React.useEffect(() => {
                const map = leafletMap.current;
                if (!map) return;

                // Remove existing image layers
                map.eachLayer(layer => {
                    if (layer instanceof L.ImageOverlay || layer instanceof L.Rectangle) {
                        map.removeLayer(layer);
                    }
                });

                if (activeLayer) {
                    const img = new Image();
                    img.src = activeLayer.url;
                    img.onload = () => {
                        const bounds = [[-img.height / 2, -img.width / 2], [img.height / 2, img.width / 2]];
                        const overlay = L.imageOverlay(activeLayer.url, bounds).addTo(map);
                        overlay.bringToBack();
                        map.fitBounds(bounds);
                    };
                } else {
                    const bounds = [[-500, -500], [500, 500]];
                    const rect = L.rectangle(bounds, { color: "#9ca3af", weight: 1, fill: false }).addTo(map);
                    rect.bringToBack();
                    map.fitBounds(bounds);
                }
            }, [activeLayer]);

            React.useEffect(() => {
                if (!leafletMap.current) return;
                markersRef.current.forEach(m => m.remove());
                markersRef.current = [];
                filteredArticles.forEach(article => {
                    const locs = getArticleLocations(article);
                    locs.forEach((loc) => {
                        const highlighted = highlightArticleId && highlightArticleId === article.id;
                        const color = highlighted ? '#10b981' : '#3b82f6';
                        const marker = L.circleMarker([loc.lat, loc.lng], { color, fillColor: color, fillOpacity: highlighted ? 0.9 : 0.6, radius: highlighted ? 14 : 8, weight: 2 })
                            .addTo(leafletMap.current)
                            .bindTooltip(loc.label || article.title, { permanent: true, direction: 'top', className: 'map-label' });

                        if (onSelectArticle) {
                            marker.on('click', () => onSelectArticle(article));
                        }
                        markersRef.current.push(marker);

                        if (highlighted && showControls && leafletMap.current) {
                            leafletMap.current.panTo([loc.lat, loc.lng], { animate: true });
                        }
                    });
                });
            }, [filteredArticles, highlightArticleId, showControls]);

            React.useEffect(() => {
                const updateMapSize = () => { if (leafletMap.current) leafletMap.current.invalidateSize(); };
                const resizeObserver = new ResizeObserver(updateMapSize);
                if (mapRef.current) resizeObserver.observe(mapRef.current);
                const timers = [100, 300, 500, 1000].map(delay => setTimeout(updateMapSize, delay));
                return () => { resizeObserver.disconnect(); timers.forEach(clearTimeout); };
            }, []);

            React.useEffect(() => { if (leafletMap.current) setTimeout(() => leafletMap.current.invalidateSize(), 200); }, [highlightArticleId]);

            return (
                <div className="relative w-full h-full group">
                    <div ref={mapRef} className="w-full h-full bg-slate-200 rounded-lg overflow-hidden" />

                    {/* Layer Switcher */}
                    {layers.length > 1 && (
                        <div className="absolute top-4 right-4 z-[1000] bg-white/90 p-2 rounded shadow-sm flex items-center gap-2">
                            <Icon name="layers" size={14} className="text-gray-500" />
                            <select
                                value={activeLayerId || ''}
                                onChange={e => setActiveLayerId(e.target.value)}
                                className="text-sm bg-transparent outline-none font-bold text-gray-700"
                            >
                                {layers.map(l => <option key={l.id} value={l.id}>{l.name}</option>)}
                            </select>
                        </div>
                    )}

                    {/* Map search input (visible when controls shown and not editing, and no external query) */}
                    {!isEditing && showControls && externalQuery === undefined && (
                        <div className="absolute top-4 left-4 z-[1000]">
                            <input
                                value={mapQuery}
                                onChange={e => {
                                    setMapQuery(e.target.value);
                                }}
                                placeholder="地図検索 (タイトル/本文/タグ)..."
                                className="p-2 rounded bg-white/90 text-sm border w-64 shadow-sm"
                            />
                        </div>
                    )}

                    {!isEditing && showControls && (
                        <div className="absolute bottom-4 left-4 right-4 z-[1000] bg-white/90 p-3 rounded-lg shadow-lg backdrop-blur flex flex-col gap-2 opacity-90 hover:opacity-100 transition-opacity duration-300">
                            <div className="flex justify-between text-xs font-bold text-gray-600">
                                <span>中心年代: {Math.floor(yearRange.currentCenter)}年</span>
                                <span>範囲: ±{Math.floor(yearRange.range)}年</span>
                            </div>
                            <div className="flex flex-col gap-1">
                                <label className="text-[10px] text-gray-500">
                                    選択年代 {yearRange.years && yearRange.years.length > 0 ? `(${yearRange.years[0]} ~ ${yearRange.years[yearRange.years.length - 1]})` : ''}
                                </label>
                                <input
                                    type="range"
                                    min={0}
                                    max={Math.max(0, (yearRange.years ? yearRange.years.length - 1 : 0))}
                                    value={yearRange.index || 0}
                                    onChange={e => {
                                        const idx = Number(e.target.value);
                                        const yrs = yearRange.years || [];
                                        if (yrs.length === 0) return;
                                        const newCenter = yrs[idx];
                                        const computeRange = (i) => {
                                            if (yrs.length === 1) return 50;
                                            if (i === 0) return Math.max(50, Math.floor((yrs[1] - yrs[0]) / 2));
                                            if (i === yrs.length - 1) return Math.max(50, Math.floor((yrs[i] - yrs[i - 1]) / 2));
                                            return Math.max(30, Math.floor(Math.min((yrs[i] - yrs[i - 1]) / 2, (yrs[i + 1] - yrs[i]) / 2)));
                                        };
                                        setYearRange(prev => {
                                            const newState = { ...prev, index: idx, currentCenter: newCenter };
                                            // only auto-compute range if user didn't override it
                                            if (!prev.manualRange) newState.range = computeRange(idx);
                                            return newState;
                                        });
                                    }}
                                    className="w-full h-1 bg-indigo-200 rounded-lg appearance-none cursor-pointer"
                                />
                                <div className="flex items-center gap-2">
                                    <div className="text-[10px] text-gray-500">表示範囲: ±{Math.floor(yearRange.range)}年</div>
                                    <div className="flex-1">
                                        {/* range slider: allow manual adjustment of ± years */}
                                        <input type="range" min={0} max={Math.max(1, Math.ceil((yearRange.max - yearRange.min) || 100))} value={yearRange.range || 0} onChange={e => setYearRange(prev => ({ ...prev, range: Number(e.target.value), manualRange: true }))} className="w-full h-1 bg-gray-300 rounded-lg appearance-none cursor-pointer" />
                                    </div>
                                </div>
                            </div>
                        </div>
                    )}
                </div>
            );
        };

        const SearchFilterBar = ({ searchState, onSearchChange, onResetFilters, count, variant = 'light' }) => {
            const handleChange = (field, value) => onSearchChange && onSearchChange({ [field]: value });
            const isDark = variant === 'dark';
            const bgClass = isDark ? 'bg-slate-800 border-slate-700 text-white' : 'bg-white border-gray-100 text-gray-800';
            const inputClass = isDark ? 'bg-slate-700 border-slate-600 text-white placeholder-slate-400' : 'bg-white border-gray-200 text-gray-800';
            return (
                <div className={`${bgClass} rounded-xl shadow-sm border p-4 space-y-3`}>
                    <div className="grid grid-cols-3 gap-3">
                        <input className={`w-full border rounded px-2 py-1.5 text-sm ${inputClass}`} value={searchState.keyword || ''} onChange={e => handleChange('keyword', e.target.value)} placeholder="名称" />
                        <input className={`w-full border rounded px-2 py-1.5 text-sm ${inputClass}`} value={searchState.tag || ''} onChange={e => handleChange('tag', e.target.value)} placeholder="#タグ" />
                        <select className={`w-full border rounded px-2 py-1.5 text-sm ${inputClass}`} value={searchState.type || 'all'} onChange={e => handleChange('type', e.target.value)}>{['all', ...Object.keys(ARTICLE_TYPES)].map(k => <option key={k} value={k}>{ARTICLE_TYPES[k]?.label || 'すべて'}</option>)}</select>
                    </div>
                    <div className="flex items-center gap-2 mt-2">
                        <label className="text-xs font-bold opacity-70">重要度:</label>
                        <div className="flex bg-gray-100 rounded p-0.5">
                            {[1, 2, 3, 4, 5].map(v => (
                                <button key={v} onClick={() => handleChange('minImportance', searchState.minImportance === v ? 0 : v)} className={`px-2 py-0.5 text-xs rounded ${searchState.minImportance === v ? 'bg-indigo-600 text-white font-bold' : searchState.minImportance > v ? 'text-indigo-600' : 'text-gray-400'}`}>
                                    {v}
                                </button>
                            ))}
                            <span className="text-[10px] items-center flex px-1 text-gray-400">{searchState.minImportance ? '以上' : '指定なし'}</span>
                        </div>
                    </div>
                    <div className="flex justify-between items-center text-xs opacity-80 mt-2">
                        <div className="flex items-center gap-2">
                            <span>{count}件</span>
                            <label className="flex items-center gap-1 cursor-pointer bg-black/10 px-2 py-0.5 rounded">
                                <input type="checkbox" checked={!!searchState.onlyApproved} onChange={e => handleChange('onlyApproved', e.target.checked)} />
                                承認済みのみ
                            </label>
                        </div>
                        <button onClick={onResetFilters}>クリア</button>
                    </div>
                </div>
            );
        };

        const TagMiniTimeline = ({ tag, articles = [], onSelectArticle, isTreeMode = false, selectedArticleId, onTagClick }) => {
            if (!tag) return null;
            const items = React.useMemo(() => sortByChronology(articles.filter(a => (a.tags || []).includes(tag))), [articles, tag]);

            const displayItems = React.useMemo(() => {
                if (!selectedArticleId || items.length === 0) return items.slice(0, 3);
                const currentIndex = items.findIndex(item => item.id === selectedArticleId);
                if (currentIndex === -1) return items.slice(0, 3);
                const start = Math.max(0, currentIndex - 1);
                const end = Math.min(items.length, currentIndex + 2);
                return items.slice(start, end);
            }, [items, selectedArticleId]);

            if (isTreeMode) {
                return (
                    <div className="min-w-[200px] bg-white/5 rounded-lg p-3 border border-white/10 snap-start shrink-0 relative">
                        <div className="absolute top-4 -left-4 w-4 h-px bg-white/30"></div>
                        <div onClick={() => onTagClick && onTagClick(tag)} className="text-xs font-bold text-white/80 mb-4 flex items-center gap-2 border-b border-white/10 pb-2 cursor-pointer hover:text-indigo-300 transition-colors"><Icon name="hash" size={12} /> {tag}<span className="ml-auto text-[10px] bg-white/10 px-1.5 rounded-full">{items.length}</span></div>
                        <div className="relative pl-4 space-y-0">
                            <div className="absolute left-0 top-2 bottom-2 w-px bg-white/20"></div>
                            {displayItems.map(item => {
                                const isCurrent = item.id === selectedArticleId;
                                return (
                                    <div key={item.id} className="relative py-1">
                                        <div className="mindmap-branch"></div>
                                        <button onClick={() => onSelectArticle && onSelectArticle(item)} className={`text-left w-full pl-2 py-1.5 rounded transition flex flex-col relative z-10 ${isCurrent ? 'bg-white/20 shadow' : 'hover:bg-white/10'}`}>
                                            <span className={`text-xs font-bold truncate w-full ${isCurrent ? 'text-white' : 'text-white/70'}`}>{item.title}</span>
                                            <span className="text-[10px] text-white/40 font-mono">{item.year}</span>
                                        </button>
                                    </div>
                                );
                            })}
                            {items.length > displayItems.length && <div className="text-[10px] text-white/40 italic pl-2 pt-1">他 {items.length - displayItems.length} 件</div>}
                            {items.length === 0 && <div className="text-[10px] text-white/30 italic">記事なし</div>}
                        </div>
                    </div>
                );
            }
            return null;
        };

        const TagTimelineColumns = ({ tags = [], articles = [], onSelectArticle, selectedArticleId, onTagClick }) => (
            <div className="flex gap-8 overflow-x-auto pb-4 snap-x-mandatory w-full custom-scrollbar pl-4">
                {tags.map(tag => <TagMiniTimeline key={tag} tag={tag} articles={articles} onSelectArticle={onSelectArticle} selectedArticleId={selectedArticleId} isTreeMode={true} onTagClick={onTagClick} />)}
            </div>
        );

        // --- LargeTimelineView (構造年表: 統合版) ---
        const LargeTimelineView = ({ articles = [], onSelectArticle, onEditArticle, onDeleteArticle, onDuplicateArticle, focusedArticle, onFocusChange, allArticles = [], searchState, onSearchChange, onResetFilters, worldData, appContextId, myRole, onOpenNoYear, onOpenTagArticle, tagArticleValue, onTagArticleValueChange }) => {
            const [showSearch, setShowSearch] = React.useState(false);
            const [centeredArticleId, setCenteredArticleId] = React.useState(null);
            const [viewMode, setViewMode] = React.useState('broad'); // 'broad' (title only) or 'detailed'
            const containerRef = React.useRef(null);
            const articleRefs = React.useRef(new Map());
            const noYearRefs = React.useRef(new Map());
            const sortedArticles = React.useMemo(() => sortByChronology(articles), [articles]);
            const isJumpingRef = React.useRef(false);


            const noYearArticles = React.useMemo(() => sortedArticles.filter(a => {
                // noYearフラグが立っている、または年代が0/nullの記事
                if (a.noYear === true) return true;
                const y = Math.floor(getArticleYear(a));
                return !y || Number(y) === 0;
            }).sort((a, b) => String(a.title || '').localeCompare(String(b.title || ''))), [sortedArticles]);

            const datedArticles = React.useMemo(() => sortedArticles.filter(a => {
                // noYearフラグが立っている記事は除外
                if (a.noYear === true) return false;
                const y = Math.floor(getArticleYear(a));
                return y && Number(y) !== 0;
            }), [sortedArticles]);

            const displayArticles = React.useMemo(() => {
                // 詳細モードで年代あり記事を表示する場合のロジック
                // 年代なし記事は年表に表示しない（datedArticlesにはすでに含まれていない）
                // if (viewMode === 'detailed' && focusedArticle) {
                //     if (focusedArticle.noYear === true) return [focusedArticle];
                //     const y = Math.floor(getArticleYear(focusedArticle));
                //     if (!y || y === 0) return [focusedArticle];
                // }
                return datedArticles;
            }, [datedArticles]);

            const scrollToArticle = (id) => {
                // wait for render if switching modes
                setTimeout(() => {
                    const el = articleRefs.current.get(id);
                    if (el) el.scrollIntoView({ behavior: 'smooth', block: 'center' });
                }, 100);
            };

            const scrollToNoYearArticle = (id) => {
                const el = noYearRefs.current.get(id);
                if (el) el.scrollIntoView({ behavior: 'smooth', block: 'center' });
            };

            const handleJump = (item) => {
                isJumpingRef.current = true;
                const inList = sortedArticles.some(a => a.id === item.id);
                if (onResetFilters) onResetFilters();

                // Always switch to detailed view when jumping to a specific item
                if (viewMode === 'broad') setViewMode('detailed');

                if (!inList) {
                    if (onSelectArticle) onSelectArticle(item);
                    setTimeout(() => { scrollToArticle(item.id); isJumpingRef.current = false; }, 200);
                } else {
                    if (onSelectArticle) onSelectArticle(item);
                    setTimeout(() => { scrollToArticle(item.id); isJumpingRef.current = false; }, 100);
                }
            };

            const handleContentClick = (e) => {
                const link = e.target.closest('.wiki-link');
                if (link) {
                    e.preventDefault(); e.stopPropagation();
                    const id = link.getAttribute('data-article-id');
                    const wikiTitle = link.getAttribute('data-wiki-title');

                    const openTarget = (target) => {
                        if (onSelectArticle) onSelectArticle(target);

                        const y = getArticleYear(target);
                        const hasYear = y && Number(y) !== 0 && !target.noYear;

                        // 記事の年代状態に応じてフィルタを調整
                        if (typeof onSearchChange === 'function') {
                            onSearchChange({ excludeNoYear: hasYear });
                        }

                        if (hasYear) {
                            if (window.setAppViewMode) window.setAppViewMode('timeline_large');
                        } else {
                            if (window.setAppViewMode) window.setAppViewMode('single_article');
                        }

                        if (typeof onResetFilters !== 'undefined' && onResetFilters) onResetFilters();
                    };

                    if (id) {
                        const target = allArticles.find(a => a.id === id);
                        if (target) {
                            openTarget(target);
                        } else alert("リンク先の記事が見つかりません");
                    } else if (wikiTitle) {
                        if (wikiTitle === '年代なし') {
                            if (onOpenNoYear) onOpenNoYear();
                        } else {
                            const target = allArticles.find(a => (a.title || '').trim() === wikiTitle.trim());
                            if (target) openTarget(target); else alert("リンク先の記事が見つかりません");
                        }
                    }
                }
            };

            const handleScroll = () => {
                if (isJumpingRef.current || !containerRef.current || viewMode === 'broad') return;
                const container = containerRef.current;
                const center = container.scrollTop + container.clientHeight / 2;
                let closest = null, minDst = Infinity;
                sortedArticles.forEach(a => {
                    const el = articleRefs.current.get(a.id);
                    if (el) {
                        const dst = Math.abs((el.offsetTop + el.offsetHeight / 2) - center);
                        if (dst < minDst) { minDst = dst; closest = a; }
                    }
                });
                if (closest && closest.id !== centeredArticleId) {
                    setCenteredArticleId(closest.id);
                    if (onFocusChange) onFocusChange(closest);
                }
            };

            React.useEffect(() => { if (focusedArticle) { const t = setTimeout(() => scrollToArticle(focusedArticle.id), 500); return () => clearTimeout(t); } }, [focusedArticle]);
            const activeArticle = focusedArticle && focusedArticle.id === centeredArticleId ? focusedArticle : sortedArticles.find(a => a.id === centeredArticleId) || focusedArticle;


            // 外部から記事が選択されたとき（地図モードなどから遷移してきたとき）は詳細モードに切り替える
            React.useEffect(() => {
                if (focusedArticle && viewMode === 'broad') {
                    setViewMode('detailed');
                }
            }, [focusedArticle]);

            return (
                <div className="h-full w-full overflow-hidden bg-slate-900 text-white relative flex flex-col">
                    <div className="shrink-0 bg-slate-900/90 backdrop-blur px-4 md:px-6 py-4 border-b border-white/10 z-20 relative flex justify-between items-center">
                        <div className="flex flex-col">
                            <div className="text-[11px] uppercase tracking-widest text-white/60">LARGE TIMELINE</div>
                            <div className="flex items-center gap-3 flex-wrap">
                                <div className="text-sm text-white mt-1 flex-1">{searchState.keyword || searchState.tag || "全記事"}</div>
                                <input className="text-sm p-1 rounded bg-white/90 text-gray-800 w-full sm:w-64" placeholder="本文検索..." value={searchState.keyword || ''} onChange={e => onSearchChange({ keyword: e.target.value })} />
                                <label className="ml-3 text-xs text-white/70 flex items-center gap-2"><input type="checkbox" checked={!!searchState.excludeNoYear} onChange={e => onSearchChange({ excludeNoYear: e.target.checked })} /> 年代設定記事モード</label>

                                {onOpenTagArticle && (
                                    <div className="flex items-center gap-1 ml-0 sm:ml-4 w-full sm:w-auto">
                                        <input className="text-sm p-1 rounded bg-white/90 text-gray-800 w-full sm:w-40" placeholder="#タグ/キーワード" value={tagArticleValue || ''} onChange={e => onTagArticleValueChange && onTagArticleValueChange(e.target.value)} />
                                        <button onClick={() => { if (tagArticleValue) onOpenTagArticle(tagArticleValue); }} className="px-2 py-1 bg-emerald-500 text-white text-xs rounded">タグ記録</button>
                                    </div>
                                )}
                            </div>
                        </div>
                        <div className="flex items-center gap-2">
                            <div className="flex bg-white/10 rounded p-1">
                                <button onClick={() => setViewMode('broad')} className={`px-3 py-1 text-xs rounded transition ${viewMode === 'broad' ? 'bg-indigo-600 text-white font-bold' : 'text-white/60 hover:text-white'}`}>年表 (全体)</button>
                                <button onClick={() => setViewMode('detailed')} className={`px-3 py-1 text-xs rounded transition ${viewMode === 'detailed' ? 'bg-indigo-600 text-white font-bold' : 'text-white/60 hover:text-white'}`}>詳細</button>
                            </div>
                            <button onClick={() => setShowSearch(!showSearch)} className="p-2 bg-white/10 rounded"><Icon name="search" size={18} /></button>
                        </div>
                        {showSearch && <div className="absolute top-full left-0 right-0 z-30 mt-2 px-4"><SearchFilterBar searchState={searchState} onSearchChange={onSearchChange} onResetFilters={onResetFilters} count={articles.length} variant="dark" /></div>}
                    </div>
                    <div className="flex-1 flex relative overflow-hidden">
                        {/* 年代未設定記事のセクション（スクロール内の最上部に表示） */}
                        {noYearArticles.length > 0 && (
                            <div className="w-full p-6 border-b border-white/10 z-10 bg-transparent">
                                <div className="flex items-center justify-between mb-3">
                                    <div className="text-sm font-bold text-white">年代未設定の記事</div>
                                    <div className="text-xs text-white/60">編集で「年代なし」を設定した記事</div>
                                </div>
                                <div className="grid gap-3 sm:grid-cols-2 md:grid-cols-3 lg:grid-cols-4 max-h-60 overflow-y-auto">
                                    {noYearArticles.map(a => (
                                        <div key={a.id} ref={el => el ? noYearRefs.current.set(a.id, el) : noYearRefs.current.delete(a.id)} data-noyear-id={a.id} className="bg-white/5 p-3 rounded-lg border border-white/5 flex flex-col">
                                            <div className="flex justify-between items-start gap-2">
                                                <div className="text-sm font-bold text-white truncate">{a.title}</div>
                                                <div className="text-[10px] text-white/60">{a.dateStr || ''}</div>
                                            </div>
                                            <div className="text-xs text-white/60 mt-2 line-clamp-2" onClick={handleContentClick} dangerouslySetInnerHTML={{ __html: highlightHtml(transformContent(a.contentHtml || ''), searchState.keyword) }}></div>
                                            <div className="mt-3 flex gap-2 justify-end">
                                                <button type="button" style={{ position: 'relative', zIndex: 1000, pointerEvents: 'auto' }} onClick={(e) => {
                                                    e.stopPropagation();
                                                    if (typeof onSearchChange === 'function') {
                                                        try { onSearchChange({ type: 'all', keyword: '', tag: '', excludeNoYear: false }); }
                                                        catch (err) { console.warn('onSearchChange failed', err); }
                                                    }
                                                    if (typeof onOpenNoYear === 'function') {
                                                        onOpenNoYear(a.id);
                                                        return;
                                                    }
                                                    setTimeout(() => {
                                                        if (onSelectArticle) onSelectArticle(a);
                                                        // Switch to dedicated single article view for complex layouts
                                                        if (window.setAppViewMode) window.setAppViewMode('single_article');
                                                    }, 150);
                                                }} className="px-2 py-1 text-xs bg-white/10 rounded">表示</button>
                                                <button type="button" style={{ position: 'relative', zIndex: 1000, pointerEvents: 'auto' }} onClick={(e) => { e.stopPropagation(); onEditArticle && onEditArticle(a); }} className="px-2 py-1 text-xs bg-indigo-600 text-white rounded">編集</button>
                                                <button type="button" style={{ position: 'relative', zIndex: 1000, pointerEvents: 'auto' }} onClick={(e) => { e.stopPropagation(); onDuplicateArticle && onDuplicateArticle(a); }} className="px-2 py-1 text-xs bg-emerald-600 text-white rounded">複製</button>
                                                {(myRole === 'owner' || myRole === 'admin') && <button type="button" style={{ position: 'relative', zIndex: 1000, pointerEvents: 'auto' }} onClick={(e) => { e.stopPropagation(); onDeleteArticle && onDeleteArticle(a); }} className="px-2 py-1 text-xs bg-red-600 text-white rounded">削除</button>}
                                            </div>
                                        </div>
                                    ))}
                                </div>
                            </div>
                        )}

                        {viewMode === 'detailed' && (
                            <div className="w-12 bg-slate-950 border-r border-white/10 hidden md:block timeline-ruler z-10 sticky top-0 h-full"><div className="absolute top-1/2 w-full text-center text-[10px] text-indigo-400 font-bold bg-slate-900 py-1 border-y border-indigo-500/30 transform -translate-y-1/2">{activeArticle ? getArticleYear(activeArticle) : '???'}</div></div>
                        )}

                        <div ref={containerRef} className={`flex-1 overflow-y-auto scroll-smooth relative ${viewMode === 'detailed' ? 'p-4 md:p-10' : 'p-6'}`} onScroll={handleScroll}>
                            {viewMode === 'detailed' && <div className="absolute left-8 top-0 bottom-0 w-px bg-white/10 z-0 md:left-20"></div>}

                            {viewMode === 'broad' ? (
                                <div className="relative pb-16">
                                    <div className="absolute left-6 top-0 bottom-0 w-px bg-white/10"></div>
                                    <div className="flex flex-col gap-5">
                                        {datedArticles.map((article) => (
                                            <div
                                                key={article.id}
                                                ref={el => el ? articleRefs.current.set(article.id, el) : articleRefs.current.delete(article.id)}
                                                onClick={() => {
                                                    if (onSelectArticle) onSelectArticle(article);
                                                    setCenteredArticleId(article.id);
                                                    setViewMode('detailed');
                                                    setTimeout(() => scrollToArticle(article.id), 100);
                                                }}
                                                className="relative pl-12"
                                            >
                                                <div className="absolute left-3 top-4 w-3 h-3 rounded-full bg-indigo-400 shadow-[0_0_0_4px_rgba(99,102,241,0.25)]"></div>
                                                <div className="bg-white/5 border border-white/10 rounded-lg p-4 cursor-pointer hover:bg-white/10 hover:border-indigo-500/50 transition group flex flex-col">
                                                    <div className="flex justify-between items-start mb-1">
                                                        <span className={`text-[10px] px-1.5 py-0.5 rounded ${ARTICLE_TYPES[article.type]?.color || 'bg-gray-700 text-gray-300'}`}>{ARTICLE_TYPES[article.type]?.label}</span>
                                                        <span className="text-[10px] text-yellow-500">{'★'.repeat(article.importance || 3)}</span>
                                                        <span className="font-mono text-indigo-300 text-xs font-bold">{getArticleYear(article)}</span>
                                                    </div>
                                                    <h3 className="text-sm font-bold text-white group-hover:text-indigo-300 line-clamp-2">{article.title}</h3>
                                                    <div className="text-[11px] text-white/50 mt-2 line-clamp-2" onClick={handleContentClick} dangerouslySetInnerHTML={{ __html: highlightHtml(transformContent(article.contentHtml || ''), searchState.keyword) }}></div>
                                                    <div className="text-[10px] text-white/40 mt-2 truncate">{article.dateStr}</div>
                                                </div>
                                            </div>
                                        ))}
                                    </div>
                                </div>
                            ) : (
                                <div className="flex flex-col gap-12 py-10">
                                    {displayArticles.map((article) => {
                                        const isActive = (focusedArticle?.id === article.id) || (centeredArticleId === article.id);
                                        return (
                                            <div key={article.id} data-article-id={article.id} ref={el => el ? articleRefs.current.set(article.id, el) : articleRefs.current.delete(article.id)} className="w-full flex flex-col relative box-border">
                                                <div className="w-full flex flex-col md:flex-row items-center md:items-center gap-0 z-10 relative">
                                                    <div className={`flex-1 w-full transition-all duration-500 ${isActive ? 'opacity-100 scale-100' : 'opacity-30 scale-95 grayscale'}`}>
                                                        <div className="text-left text-gray-800 rounded-2xl shadow-2xl overflow-hidden border-4 relative w-full bg-white border-white/10">
                                                            <div className="h-32 bg-gradient-to-r from-indigo-900 to-slate-800 p-6 flex items-end relative" onClick={() => { isJumpingRef.current = true; if (onSelectArticle) onSelectArticle(article); scrollToArticle(article.id); setTimeout(() => isJumpingRef.current = false, 500); }}>
                                                                <h1 className="text-2xl md:text-3xl font-bold text-white z-10 serif flex items-center gap-2">
                                                                    {article.title}
                                                                    {article.isApproved && <Icon name="check-circle" size={24} className="text-emerald-400" title="承認済み" />}
                                                                </h1>
                                                                <div className="absolute right-4 bottom-4 text-white/20"><Icon name={ARTICLE_TYPES[article.type]?.icon} size={80} /></div>
                                                                <button onClick={(e) => { e.stopPropagation(); copyText(article.id); }} className="absolute top-2 right-2 text-white/50 hover:text-white bg-black/20 px-2 py-1 rounded text-xs">ID: {article.id.slice(0, 4)}...</button>
                                                            </div>
                                                            <div className="p-6">
                                                                <div className="flex gap-2 text-xs text-gray-500 mb-4">
                                                                    <span className="bg-gray-100 px-2 py-1 rounded">{ARTICLE_TYPES[article.type]?.label}</span>
                                                                    <span className="font-mono text-indigo-600 font-bold bg-indigo-50 px-2 py-1 rounded">{article.dateStr || `Year: ${article.year}`}</span>
                                                                </div>
                                                                <div className="prose prose-sm max-w-none text-gray-800 mb-4" dangerouslySetInnerHTML={{ __html: highlightHtml(transformContent(article.contentHtml), searchState.keyword) }} onClick={handleContentClick}></div>
                                                                {article.mainImageUrl && <img src={article.mainImageUrl} className="w-full rounded-lg object-cover max-h-48 border" alt={article.title} />}
                                                                <div className="mt-4 pt-4 border-t flex justify-end gap-2">
                                                                    <button onClick={(e) => { e.stopPropagation(); onEditArticle(article); }} className="flex items-center gap-1 text-xs text-gray-400 hover:text-indigo-600 border px-2 py-1 rounded hover:bg-gray-50"><Icon name="edit-2" size={12} /> 編集</button>
                                                                    <button onClick={(e) => { e.stopPropagation(); onDuplicateArticle && onDuplicateArticle(article); }} className="flex items-center gap-1 text-xs text-emerald-600 hover:text-emerald-800 border border-emerald-200 px-2 py-1 rounded hover:bg-emerald-50"><Icon name="copy" size={12} /> 複製</button>
                                                                    {(myRole === 'owner' || myRole === 'admin') && <button onClick={(e) => { e.stopPropagation(); onDeleteArticle && onDeleteArticle(article); }} className="flex items-center gap-1 text-xs text-red-500 hover:text-red-700 border border-red-200 px-2 py-1 rounded hover:bg-red-50"><Icon name="trash-2" size={12} /> 削除</button>}
                                                                </div>
                                                            </div>
                                                        </div>
                                                        {isActive && (
                                                            <div className="mt-4 h-64 w-full rounded-xl overflow-hidden border border-white/20 relative bg-slate-800 shadow-lg animate-[fadeIn_0.3s_ease-out]">
                                                                <div className="absolute top-2 left-2 z-[500] text-[10px] font-bold text-black bg-white/80 px-2 py-0.5 rounded shadow backdrop-blur">LOCATION</div>
                                                                <MapView articles={[article]} worldData={worldData} highlightArticleId={article.id} appContextId={appContextId} showControls={false} />
                                                            </div>
                                                        )}
                                                    </div>
                                                    {isActive && (
                                                        <div className="flex flex-row items-center animate-[fadeIn_0.5s_ease-out] self-stretch md:self-auto w-full md:w-auto mt-8 md:mt-0">
                                                            <div className="hidden md:block w-12 h-px bg-white/30 shrink-0"></div>
                                                            <div className="w-full md:w-[320px] shrink-0 pl-0 md:pl-0 border-l-0 md:border-l border-white/30 py-4 relative">
                                                                <div className="hidden md:block absolute left-[-1px] top-1/2 w-2 h-2 bg-white rounded-full -translate-y-1/2 -translate-x-1/2 shadow-[0_0_10px_white]"></div>
                                                                <div className="mb-2 flex items-center gap-2 text-white/60 text-xs font-bold uppercase tracking-widest pl-8">関連マインドマップ</div>
                                                                <TagTimelineColumns tags={article.tags} articles={allArticles} onSelectArticle={(item) => handleJump(item)} onTagClick={(t) => { isJumpingRef.current = true; if (onSearchChange) onSearchChange({ tag: t }); }} selectedArticleId={article.id} isTreeMode={true} variant="light" />
                                                                {article.stats && article.stats.length > 0 && (
                                                                    <div className="bg-white/5 rounded-xl p-4 border border-white/10 ml-8 mt-4"><div className="text-xs font-bold text-white/50 mb-2 border-b border-white/10 pb-1">STATS</div>{article.stats.map((s, i) => (<div key={i} className="flex justify-between text-sm text-white/80 py-1"><span>{s.label}</span><span className="font-bold font-mono text-indigo-300">{s.value}</span></div>))}</div>
                                                                )}
                                                            </div>
                                                        </div>
                                                    )}
                                                </div>
                                            </div>
                                        );
                                    })}
                                </div>
                            )}
                        </div>
                    </div>
                </div>
            );
        };

        // --- SimpleLineChart & GraphView: 年表からの統計表示機能 (年表(1)から移植・簡易化)
        // 記事本文中の <table> を解析して「ステータス名 -> 数値」マップを返す（年は記事の年を使う）
        const parseTablesFromHtml = (html) => {
            if (!html) return {};
            try {
                const parser = new DOMParser();
                const doc = parser.parseFromString(html, 'text/html');
                const map = {}; // label -> summed value within article

                // 1) csv-block があれば優先して読み取る
                const csvBlocks = Array.from(doc.querySelectorAll('.csv-block'));
                if (csvBlocks.length > 0) {
                    csvBlocks.forEach(cb => {
                        const raw = cb.getAttribute('data-csv') || '';
                        const decoded = raw ? decodeURIComponent(raw) : '';
                        if (!decoded) return;
                        const rows = parseCSV(decoded, ',');
                        rows.forEach(r => {
                            if (r.length >= 2) {
                                const label = r[0];
                                const val = parseFloat((r[1] || '').replace(/[,\s]/g, ''));
                                if (label && !isNaN(val)) map[label] = (map[label] || 0) + Number(val);
                            }
                        });
                    });
                    return map;
                }

                // 2) 通常の <table> 要素をパース
                const tables = Array.from(doc.querySelectorAll('table'));
                tables.forEach((table) => {
                    const rows = Array.from(table.querySelectorAll('tr'));
                    rows.forEach((row) => {
                        const cells = Array.from(row.querySelectorAll('td,th')).map(c => c.textContent.trim());
                        if (cells.length >= 2) {
                            const label = cells[0];
                            const val = parseFloat(cells[1].replace(/[,\s]/g, ''));
                            if (label && !isNaN(val)) {
                                map[label] = (map[label] || 0) + Number(val);
                            }
                        }
                    });
                });
                return map;
            } catch (e) { return {}; }
        };

        const collectAllTags = (articles = []) => {
            const set = new Set();
            articles.forEach(a => (a.tags || []).forEach(t => t && set.add(t)));
            return Array.from(set).sort((a, b) => a.localeCompare(b));
        };

        // articles: list, selectedTags: 条件タグ(複数), groupTag: 要素タグ（同一要素扱い）
        // statusA/statusB: 統計ステータス名（ラベル）
        // op: '+','-','*','/'
        const collectAllStatusLabels = (articles = []) => {
            const set = new Set();
            articles.forEach(a => {
                // from article.stats
                if (Array.isArray(a.stats)) a.stats.forEach(s => { if (s && s.label) set.add(String(s.label)); });
                // from tables
                const tableMap = parseTablesFromHtml(a.contentHtml || '');
                Object.keys(tableMap).forEach(k => set.add(k));
            });
            return Array.from(set).sort((a, b) => a.localeCompare(b));
        };

        const aggregateSeriesByGroup = (articles = [], selectedTags = [], groupTags = [], statusA = '', statusB = '', op = '+') => {
            // filter by condition tags: if none selected include all, otherwise include articles that have ANY of the selectedTags
            const selected = articles.filter(a => {
                if (!selectedTags || selectedTags.length === 0) return true;
                const tags = (a.tags || []).map(t => String(t));
                return selectedTags.some(st => tags.includes(st));
            });

            // prepare per-article status map: label -> numeric value
            const perArticle = selected.map(a => {
                const year = Math.floor(getArticleYear(a));
                const map = {};
                // stats array
                if (Array.isArray(a.stats)) {
                    a.stats.forEach(s => {
                        const lbl = s.label || s.name || '';
                        const v = parseFloat(s.value || s.v || s.gdp || s.population || NaN);
                        if (lbl && !isNaN(v)) map[String(lbl)] = (map[String(lbl)] || 0) + Number(v);
                    });
                }
                // tables
                const tableMap = parseTablesFromHtml(a.contentHtml || '');
                Object.keys(tableMap).forEach(k => { map[k] = (map[k] || 0) + Number(tableMap[k]); });
                return { article: a, year, map };
            });

            // grouping: support multiple groupTags (element tags). If groupTags provided, only create groups for those tags
            const groups = new Map();
            const useGroupTags = Array.isArray(groupTags) && groupTags.length > 0;
            perArticle.forEach(({ article, year, map }) => {
                const tags = (article.tags || []).map(t => String(t));
                if (useGroupTags) {
                    groupTags.forEach(gt => {
                        if (tags.includes(gt)) {
                            const key = gt;
                            if (!groups.has(key)) groups.set(key, new Map());
                            const yearMap = groups.get(key);
                            if (!yearMap.has(year)) yearMap.set(year, { A: 0, B: 0 });
                            const entry = yearMap.get(year);
                            if (statusA) entry.A += Number(map[statusA] || 0);
                            if (statusB) entry.B += Number(map[statusB] || 0);
                        }
                    });
                } else {
                    const key = (article.representedTag || article.title || article.id);
                    if (!groups.has(key)) groups.set(key, new Map());
                    const yearMap = groups.get(key);
                    if (!yearMap.has(year)) yearMap.set(year, { A: 0, B: 0 });
                    const entry = yearMap.get(year);
                    if (statusA) entry.A += Number(map[statusA] || 0);
                    if (statusB) entry.B += Number(map[statusB] || 0);
                }
            });

            // build series per group applying operator
            const series = [];
            groups.forEach((yearMap, key) => {
                const points = [];
                Array.from(yearMap.entries()).sort((a, b) => a[0] - b[0]).forEach(([year, vals]) => {
                    let value = null;
                    const A = vals.A || 0; const B = vals.B || 0;
                    if (statusA && statusB) {
                        switch (op) {
                            case '+': value = A + B; break;
                            case '-': value = A - B; break;
                            case '*': value = A * B; break;
                            case '/': value = B === 0 ? null : A / B; break;
                            default: value = A + B;
                        }
                    } else if (statusA) { value = A; }
                    else if (statusB) { value = B; }
                    if (value !== null) points.push({ year: Number(year), value: Number(value) });
                });
                series.push({ key, points });
            });
            return series;
        };

        const SimpleLineChart = ({ width = 700, height = 260, series = [], formatValue = (v) => String(v) }) => {
            if (!series || series.length === 0) return <div className="bg-white p-6 rounded shadow text-center text-gray-400">データがありません</div>;
            // collect years
            const yearsSet = new Set();
            let maxVal = 0;
            series.forEach(s => s.points.forEach(p => { yearsSet.add(p.year); if (p.value > maxVal) maxVal = p.value; }));
            const years = Array.from(yearsSet).sort((a, b) => a - b);
            if (years.length === 0) return <div className="bg-white p-6 rounded shadow text-center text-gray-400">データ不足</div>;
            const padding = { l: 50, r: 20, t: 20, b: 30 };
            const gw = width - padding.l - padding.r; const gh = height - padding.t - padding.b;
            const getX = (y) => padding.l + (years.indexOf(y) / (years.length - 1 || 1)) * gw;
            const getY = (v) => padding.t + gh - ((v / (maxVal || 1)) * gh);
            const colors = ['#3b82f6', '#ef4444', '#10b981', '#f59e0b', '#8b5cf6', '#06b6d4'];

            // Y-axis ticks (縦軸ラベル)
            const yTicksCount = 5;
            const yTicks = Array.from({ length: yTicksCount }).map((_, i) => {
                // descending values: top -> maxVal
                const val = maxVal * (1 - i / (yTicksCount - 1));
                // round to sensible precision
                if (Math.abs(val) >= 1000) return Math.round(val);
                return Math.round(val * 100) / 100;
            });

            return (
                <svg width={width} height={height} className="bg-white rounded-lg shadow-sm">
                    <rect x="0" y="0" width={width} height={height} fill="transparent" />
                    {/* grid lines + y-axis labels */}
                    {Array.from({ length: yTicksCount }).map((_, i) => {
                        const y = padding.t + (gh / (yTicksCount - 1)) * i;
                        const tickVal = yTicks[i];
                        return (
                            <g key={`yg_${i}`}>
                                <line x1={padding.l} x2={width - padding.r} y1={y} y2={y} stroke="#eee" />
                                <text x={padding.l - 8} y={y + 4} fontSize="10" textAnchor="end" fill="#666">{formatValue(tickVal)}</text>
                            </g>
                        );
                    })}
                    {/* x labels */}
                    {years.map((y, i) => (<text key={y} x={getX(y)} y={height - 6} fontSize="10" textAnchor="middle" fill="#666">{y}</text>))}
                    {/* series paths */}
                    {series.map((s, si) => {
                        const d = s.points.map((p, idx) => `${idx === 0 ? 'M' : 'L'} ${getX(p.year)} ${getY(p.value)}`).join(' ');
                        const color = colors[si % colors.length];
                        return (<g key={s.key}><path d={d} fill="none" stroke={color} strokeWidth={2.5} strokeLinejoin="round" strokeLinecap="round" /><text x={width - padding.r - 6} y={padding.t + 12 + si * 14} fontSize="12" textAnchor="end" fill={color}>{s.key}</text></g>);
                    })}
                </svg>
            );
        };

        const GraphView = ({ setView, articles = [] }) => {
            const [conditionTags, setConditionTags] = React.useState([]); // 条件タグ（複数）
            const [elementTags, setElementTags] = React.useState([]); // 要素タグ（複数選択）
            const [statusA, setStatusA] = React.useState('');
            const [statusB, setStatusB] = React.useState('');
            const [op, setOp] = React.useState('+');
            const [series, setSeries] = React.useState([]);
            const tags = collectAllTags(articles);
            const statuses = collectAllStatusLabels(articles);

            const toggleConditionTag = (t) => setConditionTags(prev => prev.includes(t) ? prev.filter(x => x !== t) : [...prev, t]);
            const toggleElementTag = (t) => setElementTags(prev => prev.includes(t) ? prev.filter(x => x !== t) : [...prev, t]);

            const runAggregate = () => {
                if (!statusA && !statusB) { alert('少なくとも1つの統計ステータスを選択してください'); return; }
                const s = aggregateSeriesByGroup(articles, conditionTags, elementTags, statusA, statusB, op);
                setSeries(s);
            };

            return (
                <div className="space-y-6 p-6 animate-[fadeIn_0.2s_ease-out]">
                    <div className="flex items-center gap-4"><button onClick={() => setView('timeline_large')} className="flex items-center gap-2 px-3 py-2 bg-white text-gray-700 rounded border"><Icon name="arrow-left" size={16} /> 年表へ戻る</button><h2 className="text-xl font-bold">統計ビュー</h2></div>

                    <div className="bg-white p-4 rounded shadow grid grid-cols-3 gap-4">
                        <div className="col-span-3">
                            <div className="text-sm font-bold mb-2">条件タグ（これらのタグを持つ記事が集計対象になります。複数選択可）</div>
                            <div className="flex flex-wrap gap-2">{tags.map(t => (<button key={t} onClick={() => toggleConditionTag(t)} className={`px-2 py-1 text-sm rounded ${conditionTags.includes(t) ? 'bg-indigo-600 text-white' : 'bg-gray-100 text-gray-700'}`}>#{t}</button>))}</div>
                        </div>
                        <div className="col-span-3">
                            <div className="text-sm font-bold mb-2">要素タグ（これらを同一要素として扱い比較します。複数選択可）</div>
                            <div className="flex flex-wrap gap-2">{tags.map(t => (<button key={t} onClick={() => toggleElementTag(t)} className={`px-2 py-1 text-sm rounded ${elementTags.includes(t) ? 'bg-emerald-600 text-white' : 'bg-gray-100 text-gray-700'}`}>#{t}</button>))}</div>
                        </div>
                        <div>
                            <div className="text-sm font-bold mb-2">統計ステータス A</div>
                            <select className="w-full border p-2 rounded" value={statusA} onChange={e => setStatusA(e.target.value)}>
                                <option value="">-- 選択しない --</option>
                                {statuses.map(s => <option key={s} value={s}>{s}</option>)}
                            </select>
                        </div>
                        <div>
                            <div className="text-sm font-bold mb-2">統計ステータス B</div>
                            <select className="w-full border p-2 rounded" value={statusB} onChange={e => setStatusB(e.target.value)}>
                                <option value="">-- 選択しない --</option>
                                {statuses.map(s => <option key={s} value={s}>{s}</option>)}
                            </select>
                        </div>
                        <div>
                            <div className="text-sm font-bold mb-2">演算子 (A op B)</div>
                            <select className="w-full border p-2 rounded" value={op} onChange={e => setOp(e.target.value)}>
                                <option value="+">+</option>
                                <option value="-">-</option>
                                <option value="*">×</option>
                                <option value="/">÷</option>
                            </select>
                        </div>
                    </div>

                    <div className="flex gap-2"><button onClick={runAggregate} className="px-4 py-2 bg-indigo-600 text-white rounded font-bold">グラフ生成</button><button onClick={() => { setConditionTags([]); setElementTag(''); setStatusA(''); setStatusB(''); setOp('+'); setSeries([]); }} className="px-4 py-2 border rounded">リセット</button></div>

                    <div>
                        <SimpleLineChart series={series} />
                        {series.length === 0 && <div className="text-sm text-gray-500 mt-2">記事の時間を X 軸（記事の年代）として、選択した統計ステータスを記事単位で集計します。記事内のテーブルや `stats` のラベルをステータス名として扱います。</div>}
                    </div>
                </div>
            );
        };

        // --- AdjacentArticlePreview (Not used but kept for compatibility) ---
        const AdjacentArticlePreview = () => null;

        // --- ArticleDetailPanel (Not used in new integrated view but kept for compatibility) ---
        const ArticleDetailPanel = () => null;

        const App = () => {
            const { db, auth, storage, user, loading, error, activeConfig, appContextId } = useFirebase();
            const [viewMode, setViewMode] = React.useState('world_select');
            const [worldId, setWorldId] = React.useState(null);
            const [worldData, setWorldData] = React.useState(null);
            const [articles, setArticles] = React.useState([]);
            const [selectedArticle, setSelectedArticle] = React.useState(null);
            const [formData, setFormData] = React.useState(createEmptyArticle());
            const [mapTabQuery, setMapTabQuery] = React.useState('');
            const [stats, setStats] = React.useState([]);
            const [tagInput, setTagInput] = React.useState('');
            const [mapTabImportance, setMapTabImportance] = React.useState(0);
            const [authMode, setAuthMode] = React.useState('login');
            const [authForm, setAuthForm] = React.useState({ username: '', password: '', worldName: '', worldDesc: '' });
            const [showConfigEditor, setShowConfigEditor] = React.useState(false);
            const [showMemberManager, setShowMemberManager] = React.useState(false);
            const [showAdminPanel, setShowAdminPanel] = React.useState(false);
            const [showRegionRuleEditor, setShowRegionRuleEditor] = React.useState(false);
            const [myMemberData, setMyMemberData] = React.useState(null);
            const [authError, setAuthError] = React.useState(null);
            const [timelineFilters, setTimelineFilters] = React.useState({ type: 'all', keyword: '', tag: '', excludeNoYear: true, onlyApproved: false });

            const [tagArticleInput, setTagArticleInput] = React.useState('');
            const [uiScale, setUiScale] = React.useState(100); // UI拡大率 (%)
            const [previousViewMode, setPreviousViewMode] = React.useState('timeline_large'); // 編集前のビューモードを記憶
            const isRestoringFromURL = React.useRef(false);
            const hasCheckedWorldURL = React.useRef(false); // URL復元中のフラグ

            // Expose setViewMode to window for deep component access (hacky but effective for current structure)
            React.useEffect(() => { window.setAppViewMode = setViewMode; return () => delete window.setAppViewMode; }, []);

            // これにより、エディタの参照を保持
            const editorRef = React.useRef(null);
            const htmlTextareaRef = React.useRef(null);

            React.useEffect(() => {
                if (!user || !db || hasCheckedWorldURL.current) return;
                const params = new URLSearchParams(window.location.search);
                const urlWorldId = params.get('world');
                if (urlWorldId) {
                    hasCheckedWorldURL.current = true;
                    isRestoringFromURL.current = true;
                    setWorldId(urlWorldId);
                    setViewMode('timeline_large');
                    console.log('URL復元: 世界選択', urlWorldId);
                } else {
                    hasCheckedWorldURL.current = true;
                }
            }, [user, db]);

            // URLから状態を復元（初回読み込み時）
            React.useEffect(() => {
                if (!user || !worldId || articles.length === 0 || isRestoringFromURL.current) return;

                const params = new URLSearchParams(window.location.search);
                const urlView = params.get('view');
                const urlArticleId = params.get('article');
                const urlKeyword = params.get('keyword');
                const urlTag = params.get('tag');
                const urlMapQuery = params.get('mapQuery');
                const urlMapImportance = params.get('mapImportance');

                let updated = false;

                if (urlArticleId) {
                    // 記事IDが指定されている場合、その記事を表示
                    const article = articles.find(a => a.id === urlArticleId);
                    if (article) {
                        isRestoringFromURL.current = true;
                        setSelectedArticle(article);
                        if (urlView) setViewMode(urlView);
                        else setViewMode('single_article');
                        console.log('URL復元: 記事表示', article.title, urlView);
                    }
                } else if (urlView && urlView !== viewMode) {
                    // ビューモードのみ指定されている場合
                    isRestoringFromURL.current = true;
                    setViewMode(urlView);
                    console.log('URL復元: ビューモード', urlView);
                }

                if (urlKeyword || urlTag) {
                    setTimelineFilters(prev => ({ ...prev, keyword: urlKeyword || '', tag: urlTag || '' }));
                    console.log('URL復元: 検索条件', { keyword: urlKeyword, tag: urlTag });
                    updated = true;
                }

                // 年代なしフィルタ状態を復元
                if (params.has('excludeNoYear')) {
                    const excludeNoYear = params.get('excludeNoYear') === 'true';
                    setTimelineFilters(prev => ({ ...prev, excludeNoYear }));
                    console.log('URL復元: 年代なしフィルタ', excludeNoYear);
                    updated = true;
                }

                if (urlMapQuery) {
                    setMapTabQuery(urlMapQuery);
                    console.log('URL復元: マップクエリ', urlMapQuery);
                    updated = true;
                }

                if (urlMapImportance) {
                    setMapTabImportance(Number(urlMapImportance));
                    console.log('URL復元: マップ重要度', urlMapImportance);
                    updated = true;
                }

                if (updated) {
                    isRestoringFromURL.current = true;
                }
            }, [user, worldId, articles]);

            // 状態が変更されたらURLを更新（ブラウザの履歴に追加）
            React.useEffect(() => {
                if (!worldId || !user || isRestoringFromURL.current) {
                    isRestoringFromURL.current = false;
                    return;
                }

                const timeoutId = setTimeout(() => {
                    const params = new URLSearchParams();
                    params.set('world', worldId);
                    params.set('view', viewMode);

                    if (selectedArticle) {
                        params.set('article', selectedArticle.id);
                    }

                    if (timelineFilters.keyword) {
                        params.set('keyword', timelineFilters.keyword);
                    }
                    if (timelineFilters.tag) {
                        params.set('tag', timelineFilters.tag);
                    }

                    // 年代なしフィルタ状態もURLに含める
                    if (timelineFilters.excludeNoYear !== undefined) {
                        params.set('excludeNoYear', timelineFilters.excludeNoYear.toString());
                    }

                    if (viewMode === 'map' && mapTabQuery) {
                        params.set('mapQuery', mapTabQuery);
                    }
                    if (viewMode === 'map' && mapTabImportance > 0) {
                        params.set('mapImportance', mapTabImportance.toString());
                    }

                    const newUrl = `${window.location.pathname}?${params.toString()}`;
                    const currentUrl = `${window.location.pathname}${window.location.search}`;

                    if (newUrl !== currentUrl) {
                        window.history.pushState({ viewMode, worldId, articleId: selectedArticle?.id }, '', newUrl);
                        console.log('URL更新:', newUrl);
                    }
                }, 1000);

                return () => clearTimeout(timeoutId);
            }, [viewMode, selectedArticle, worldId, user]);

            // ブラウザの戻る/進むボタンに対応
            React.useEffect(() => {
                const handlePopState = (event) => {
                    if (event.state) {
                        console.log('履歴から復元:', event.state);
                        isRestoringFromURL.current = true;

                        if (event.state.viewMode) {
                            setViewMode(event.state.viewMode);
                        }

                        if (event.state.articleId && articles.length > 0) {
                            const article = articles.find(a => a.id === event.state.articleId);
                            if (article) {
                                setSelectedArticle(article);
                            }
                        } else if (!event.state.articleId) {
                            setSelectedArticle(null);
                        }
                    }
                };

                window.addEventListener('popstate', handlePopState);
                return () => window.removeEventListener('popstate', handlePopState);
            }, [articles]);

            React.useEffect(() => {
                if (!db || !worldId || !appContextId) return;
                const { onSnapshot, doc, collection } = window.firebaseModules;
                const unsubWorld = onSnapshot(doc(db, 'artifacts', appContextId, 'public', 'data', 'worlds', worldId), s => setWorldData(s.data()));
                const unsubArticles = onSnapshot(collection(db, 'artifacts', appContextId, 'public', 'data', 'worlds', worldId, 'articles'), s => {
                    setArticles(s.docs.map(d => ({ ...d.data(), id: d.id })).sort((a, b) => getArticleYear(a) - getArticleYear(b)));
                });
                return () => { unsubWorld(); unsubArticles(); };
            }, [db, worldId, appContextId]);

            React.useEffect(() => {
                if (!db || !worldId || !user || !appContextId) return;
                const { onSnapshot, doc, updateDoc } = window.firebaseModules;
                return onSnapshot(doc(db, 'artifacts', appContextId, 'public', 'data', 'worlds', worldId, 'members', user.uid), async s => {
                    if (s.exists()) {
                        const data = s.data();
                        setMyMemberData(data);
                        // 名前が未登録または変更されている場合は更新 (自分の情報のみ)
                        if (user.displayName && data.username !== user.displayName) {
                            try {
                                await updateDoc(doc(db, 'artifacts', appContextId, 'public', 'data', 'worlds', worldId, 'members', user.uid), {
                                    username: user.displayName
                                });
                            } catch (e) { console.error("Name sync failed", e); }
                        }
                    }
                    else setMyMemberData(null);
                });
            }, [db, worldId, user, appContextId]);

            const myRole = myMemberData?.role || 'guest';
            const canIApprove = myRole === 'owner' || myMemberData?.canApprove === true;

            const articleIndex = React.useMemo(() => { const map = new Map(); articles.forEach(a => map.set(a.id, a)); return map; }, [articles]);
            // previewArticles: merge current formData into articles for instant preview in edit mode
            const previewArticles = React.useMemo(() => {
                try {
                    if (!formData) return articles;
                    const merged = articles.map(a => (formData.id && a.id === formData.id ? { ...a, ...formData } : a));
                    if (!formData.id) {
                        // append draft preview for new article
                        const draft = { ...(formData || {}), id: '__draft__' };
                        merged.push(draft);
                    }
                    return merged;
                } catch (e) { return articles; }
            }, [articles, formData]);
            const filteredTimelineArticles = React.useMemo(() => filterTimelineArticles(articles, timelineFilters), [articles, timelineFilters]);
            const timelineSummary = React.useMemo(() => {
                const summary = [];
                if (timelineFilters.keyword) summary.push(`KW:${timelineFilters.keyword}`);
                if (timelineFilters.tag) summary.push(`#${timelineFilters.tag}`);
                if (timelineFilters.type && timelineFilters.type !== 'all') summary.push(ARTICLE_TYPES[timelineFilters.type]?.label || timelineFilters.type);
                return summary.join(' / ') || '全記事';
            }, [timelineFilters]);

            // Remove localStorage region rules hooks
            const regionRules = worldData?.regionRules || REGION_TAG_RULES_DEFAULT;

            const handleConfigSave = (newConfig, newAppId) => {
                localStorage.setItem('worldweaver_firebase_config', JSON.stringify(newConfig));
                localStorage.setItem('worldweaver_app_id', newAppId);
                setShowConfigEditor(false);
                window.location.reload();
            };

            const handleAuth = async () => {
                setAuthError(null);
                const { signInWithEmailAndPassword, createUserWithEmailAndPassword, updateProfile } = window.firebaseModules;
                const email = `${authForm.username}@worldweaver.local`;
                try {
                    if (authMode === 'login') await signInWithEmailAndPassword(auth, email, authForm.password);
                    else {
                        const cred = await createUserWithEmailAndPassword(auth, email, authForm.password);
                        await updateProfile(cred.user, { displayName: authForm.username });
                    }
                    setViewMode('world_select');
                } catch (e) { setAuthError(e.message); }
            };

            const handleCreateWorld = async () => {
                if (!authForm.worldName) return alert("名前を入力してください");
                const { addDoc, collection, doc, setDoc, serverTimestamp } = window.firebaseModules;
                try {
                    const ref = await addDoc(collection(db, 'artifacts', appContextId, 'public', 'data', 'worlds'), {
                        name: authForm.worldName, description: authForm.worldDesc, ownerId: user.uid, createdAt: serverTimestamp()
                    });
                    await setDoc(doc(db, 'artifacts', appContextId, 'public', 'data', 'worlds', ref.id, 'members', user.uid), {
                        username: user.displayName, role: 'owner', joinedAt: serverTimestamp()
                    });
                    setWorldId(ref.id); setViewMode('timeline_large');
                } catch (e) { alert(e.message); }
            };

            const handleSaveArticle = async () => {
                if (!formData.title) return alert("タイトルを入力してください");
                const { addDoc, collection, doc, updateDoc, serverTimestamp } = window.firebaseModules;
                const tagsFromInput = tagInput.split(',').map(t => t.trim()).filter(t => t);
                const locationCandidates = [];
                if (Array.isArray(formData.locations)) {
                    formData.locations.forEach(l => {
                        const lat = Number(l.lat);
                        const lng = Number(l.lng);
                        if (Number.isFinite(lat) && Number.isFinite(lng)) locationCandidates.push({ lat, lng });
                    });
                }
                if (formData.lat !== undefined && formData.lng !== undefined && formData.lat !== '' && formData.lng !== '') {
                    const lat = Number(formData.lat);
                    const lng = Number(formData.lng);
                    if (Number.isFinite(lat) && Number.isFinite(lng)) locationCandidates.push({ lat, lng });
                }
                const regionTags = computeRegionTags(locationCandidates, regionRules);
                const tags = Array.from(new Set([...tagsFromInput, ...regionTags]));
                // 年代の計算
                let yearVal = parseInt(formData.year) || 0;
                if (!formData.noYear) {
                    if (formData.dateStr) {
                        const m = formData.dateStr.match(/^(\-?\d+)/);
                        if (m) yearVal = parseInt(m[1], 10);
                    } else if (formData.period?.start) {
                        const m = formData.period.start.match(/^(\-?\d+)/);
                        if (m) yearVal = parseInt(m[1], 10);
                    }
                } else {
                    yearVal = 0;
                }

                // Approval Status Logic
                let isApproved = !!formData.isApproved;
                // If not authorized to approve, keep it as is if existing, or false if new (unless default changes)
                // However, if unauthorized user edits an approved article, does it stay approved?
                // For now, adhere to formData state but verify permission if changing to true from false
                // But simplified: Only approvers see the checkbox. Editors just submit.
                // If I am NOT an approver, force preserving original state (if exists) or false (if new)
                if (!canIApprove) {
                    // 非承認者が編集した場合は、承認を取り下げる (または新規作成時は未承認)
                    isApproved = false;
                }

                const data = {
                    ...formData,
                    contentHtml: formData.contentHtml || '',
                    stats,
                    tags,
                    attachments: formData.attachments || [],
                    dateStr: formData.noYear ? '' : (formData.dateStr || ''),
                    period: formData.noYear ? { start: '', end: '' } : (formData.period || { start: '', end: '' }),
                    year: yearVal,
                    noYear: !!formData.noYear,
                    lat: Number.isFinite(formData.lat) ? formData.lat : null,
                    lng: Number.isFinite(formData.lng) ? formData.lng : null,
                    locationArticleId: formData.locationArticleId || '',
                    mainImageUrl: formData.mainImageUrl || '',
                    importance: Number(formData.importance) || 3,
                    isApproved: isApproved, // Save approval status
                    isApproved: isApproved, // Save approval status
                    updatedAt: serverTimestamp(), updatedBy: user.uid
                };
                // IDは保存データに含めない（ドキュメントIDとして管理されるため）
                delete data.id;

                try {
                    let artId = formData.id;
                    if (formData.id) {
                        await updateDoc(doc(db, 'artifacts', appContextId, 'public', 'data', 'worlds', worldId, 'articles', formData.id), data);
                    } else {
                        data.createdAt = serverTimestamp(); data.createdBy = user.uid;
                        const ref = await addDoc(collection(db, 'artifacts', appContextId, 'public', 'data', 'worlds', worldId, 'articles'), data);
                        artId = ref.id;
                        data.id = artId;
                    }

                    // Discord Webhook Notification
                    if (worldData?.discordWebhookUrl) {
                        const webhookUrl = worldData.discordWebhookUrl;
                        const isNew = !formData.id;
                        const editorName = user.displayName || 'Anonymous';
                        const title = data.title;
                        const checkStatus = isApproved ? 'Approved' : 'Unapproved';

                        // HTMLタグ除去 + Wikiリンク構文([[Title]]や[[Title|ID]])の除去(テキストは残す) + 空白整理
                        const rawText = stripHtml(data.contentHtml || '')
                            // [[Title|ID]] -> Title, [[Title]] -> Title
                            .replace(/\[\[([^|\]]+)(?:\|[^\]]+)?\]\]/g, '$1')
                            .replace(/\s+/g, ' ').trim();
                        const summary = rawText.length > 200 ? rawText.slice(0, 200) + '...' : (rawText || 'No Content');

                        const content = isNew
                            ? `🆕 **New Article Created** in ${worldData.name}\n**Title**: ${title}\n**Editor**: ${editorName}\n**Status**: ${checkStatus}\n**Summary**: ${summary}`
                            : `📝 **Article Updated** in ${worldData.name}\n**Title**: ${title}\n**Editor**: ${editorName}\n**Status**: ${checkStatus}\n**Summary**: ${summary}`;

                        // Fire and forget
                        fetch(webhookUrl, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ content })
                        }).catch(err => console.error("Discord Webhook Error:", err));
                    }

                    setSelectedArticle({ ...data, id: artId });

                    // 年代なし判定: noYearフラグが立っている、または年代が0/nullの場合
                    const hasYear = !data.noYear && data.year && Number(data.year) !== 0;

                    // 編集前のビューモードを考慮しつつ、適切なビューに遷移
                    if (previousViewMode === 'timeline_noyear' && !hasYear) {
                        // 年代なしビューから編集し、年代なしのまま → 年代なしビューに戻る
                        setViewMode('timeline_noyear');
                    } else if (previousViewMode === 'single_article') {
                        // 単独記事表示から編集 → 単独記事表示に戻る
                        setViewMode('single_article');
                    } else if (previousViewMode === 'list') {
                        // 一覧から編集 → 一覧に戻る
                        setViewMode('list');
                    } else {
                        // その他の場合は年代に基づいて判定
                        if (hasYear) {
                            setViewMode('timeline_large');
                        } else {
                            setViewMode('timeline_noyear');
                        }
                    }
                    // Success Message
                    alert(isApproved ? "保存しました" : "編集リクエストを送信しました (承認待ち)");

                } catch (e) { alert(e.message); }
            };

            const handleMapLayersUpdate = async (newLayers) => {
                const { updateDoc, doc } = window.firebaseModules;
                try {
                    await updateDoc(doc(db, 'artifacts', appContextId, 'public', 'data', 'worlds', worldId), { mapLayers: newLayers });
                    // compatibility with old field if needed, defaulting to first layer's url
                    if (newLayers.length > 0) {
                        await updateDoc(doc(db, 'artifacts', appContextId, 'public', 'data', 'worlds', worldId), { mapImageUrl: newLayers[0].url });
                    }
                } catch (e) { alert(e.message); }
            };

            const handleSaveRegionRules = async (newRules) => {
                const { updateDoc, doc } = window.firebaseModules;
                try {
                    await updateDoc(doc(db, 'artifacts', appContextId, 'public', 'data', 'worlds', worldId), { regionRules: newRules });
                } catch (e) { alert("ルール保存失敗: " + e.message); }
            };

            const handleReapplyRegionTags = async () => {
                if (!confirm('現在の全記事に対して、地域タグ・ルールを再適用しますか？\n\n・ルールに合致するタグが自動追加されます\n・場所が範囲外になった地域タグは自動削除されます\n・手動タグは維持されます')) return;
                const { updateDoc, doc } = window.firebaseModules;
                try {
                    const updates = [];
                    const managedTags = new Set(regionRules.map(r => r.tag));

                    for (const article of articles) {
                        const locationCandidates = [];
                        if (Array.isArray(article.locations)) {
                            article.locations.forEach(l => {
                                const lat = Number(l.lat);
                                const lng = Number(l.lng);
                                if (Number.isFinite(lat) && Number.isFinite(lng)) locationCandidates.push({ lat, lng });
                            });
                        }
                        if (article.lat !== undefined && article.lat !== null && article.lat !== '') {
                            const lat = Number(article.lat);
                            const lng = Number(article.lng);
                            if (Number.isFinite(lat) && Number.isFinite(lng)) locationCandidates.push({ lat, lng });
                        }

                        const validRegionTags = new Set(computeRegionTags(locationCandidates, regionRules));
                        const currentTags = article.tags || [];
                        const finalTags = new Set();
                        let changed = false;

                        currentTags.forEach(t => {
                            if (managedTags.has(t)) {
                                if (validRegionTags.has(t)) finalTags.add(t);
                                else changed = true;
                            } else {
                                finalTags.add(t);
                            }
                        });

                        validRegionTags.forEach(t => {
                            if (!finalTags.has(t)) {
                                finalTags.add(t);
                                changed = true;
                            }
                        });

                        if (changed) {
                            updates.push(updateDoc(doc(db, 'artifacts', appContextId, 'public', 'data', 'worlds', worldId, 'articles', article.id), {
                                tags: Array.from(finalTags)
                            }));
                        }
                    }
                    if (updates.length > 0) {
                        await Promise.all(updates);
                        alert(`${updates.length} 件の記事のタグを更新しました。`);
                    } else {
                        alert("更新が必要な記事はありませんでした。");
                    }
                } catch (e) { console.error(e); alert("エラーが発生しました: " + e.message); }
            };

            // When switching to the no-year view, if a selectedArticle is set then scroll to it inside that view
            React.useEffect(() => {
                try {
                    if (viewMode === 'timeline_noyear' && selectedArticle && selectedArticle.id) {
                        const id = selectedArticle.id;
                        // wait for render
                        setTimeout(() => {
                            const el = document.querySelector(`[data-noyear-id="${id}"]`);
                            if (el) {
                                try { el.scrollIntoView({ behavior: 'smooth', block: 'center' }); console.log('App: scrolled to no-year element', id); }
                                catch (err) { console.warn('scrollIntoView failed', err); }
                            } else {
                                console.log('App: no-year element not found for', id);
                            }
                        }, 200);
                    }
                } catch (e) { console.warn(e); }
            }, [viewMode, selectedArticle]);

            const openDetailView = (article, origin = viewMode) => {
                setSelectedArticle(article);

                // 記事の年代状態に応じてフィルタを調整
                const y = getArticleYear(article);
                const hasYear = y && y !== 0 && !article.noYear;

                // 年代なし記事を開く場合はexcludeNoYearをfalseに、年代あり記事はtrueに
                setTimelineFilters(prev => ({ ...prev, excludeNoYear: hasYear }));

                // 一覧、マップ、その他どこからでも詳細ビュー（全画面）へ遷移
                setViewMode('single_article');
            };

            const startEditingArticle = (article) => {
                if (!article) return;
                setPreviousViewMode(viewMode); // 編集前のビューモードを保存
                setFormData({
                    ...createEmptyArticle(),
                    ...article,
                    locations: article.locations || [],
                    period: article.period || { start: '', end: '' },
                    lat: article.lat || null,
                    lng: article.lng || null
                });
                setStats(article.stats || []);
                setTagInput((article.tags || []).join(', '));
                setViewMode('edit');
            };

            const handleTagClick = (tagName) => {
                setTimelineFilters(prev => ({ ...prev, tag: tagName }));
                const motherArticle = articles.find(a => a.representedTag === tagName);
                if (motherArticle) {
                    openDetailView(motherArticle);
                } else if (confirm(`タグ ${tagName} の記事はまだありません。作成しますか?`)) {
                    openTagArticle(tagName);
                }
            };

            const openTagArticle = (tagNameRaw) => {
                const tagName = (tagNameRaw || '').trim();
                if (!tagName) return;
                setTagArticleInput(tagName);
                const existing = articles.find(a => (a.representedTag || '').toLowerCase() === tagName.toLowerCase());
                if (existing) { startEditingArticle(existing); return; }
                const byTitle = articles.find(a => (a.title || '').toLowerCase() === tagName.toLowerCase());
                if (byTitle) { startEditingArticle(byTitle); return; }
                const draft = {
                    ...createEmptyArticle(),
                    title: tagName,
                    representedTag: tagName,
                    type: 'other',
                    folder: 'Keywords',
                    contentHtml: `<p>#${tagName} の説明を書いてください。</p>`,
                    noYear: true,
                    dateStr: '',
                    period: { start: '', end: '' },
                    tags: [tagName]
                };
                setFormData(draft);
                setStats([]);
                setTagInput(tagName);
                setViewMode('edit');
            };


            const copyMyId = () => {
                if (!user) return;
                const text = user.uid;
                const fallbackCopy = (text) => { const textArea = document.createElement("textarea"); textArea.value = text; textArea.style.position = "fixed"; textArea.style.left = "-9999px"; document.body.appendChild(textArea); textArea.focus(); textArea.select(); try { document.execCommand('copy'); alert("IDコピー: " + text); } catch (err) { console.error(err); alert("失敗"); } document.body.removeChild(textArea); };
                if (navigator.clipboard && navigator.clipboard.writeText) { navigator.clipboard.writeText(text).then(() => alert("IDコピー: " + text)).catch(() => fallbackCopy(text)); } else { fallbackCopy(text); }
            };

            const handleDeleteArticle = async (article) => {
                if (!article) return;
                const canDelete = myRole === 'owner' || myRole === 'admin';
                if (!canDelete) { alert("削除権限がありません（管理者のみ）"); return; }
                if (!confirm(`本当に「${article.title}」を削除しますか？\nこの操作は取り消せません。`)) return;

                const { deleteDoc, doc } = window.firebaseModules;
                try {
                    await deleteDoc(doc(db, 'artifacts', appContextId, 'public', 'data', 'worlds', worldId, 'articles', article.id));
                    // If we are currently viewing this article, close it or go back
                    if (selectedArticle && selectedArticle.id === article.id) {
                        setSelectedArticle(null);
                        setViewMode('timeline_large');
                    }
                } catch (e) { alert("削除失敗: " + e.message); }
            };

            const handleDuplicateArticle = (article) => {
                if (!article) return;
                if (!['owner', 'editor', 'admin'].includes(myRole)) { alert("作成権限がありません"); return; }

                const newTitle = article.title + " (複製)";
                const duplicated = {
                    ...article,
                    title: newTitle,
                    id: null,
                    isApproved: false,
                    createdAt: null,
                    updatedAt: null,
                    createdBy: null,
                    updatedBy: null
                };

                // Use existing startEditingArticle logic but override state with duplicated data
                setFormData({
                    ...createEmptyArticle(),
                    ...duplicated,
                    locations: duplicated.locations || [],
                    period: duplicated.period || { start: '', end: '' },
                    lat: duplicated.lat || null,
                    lng: duplicated.lng || null
                });
                setStats(duplicated.stats || []);
                setTagInput((duplicated.tags || []).join(','));
                setViewMode('edit');
            };

            // 匿名ログインを自動実行（閲覧のみ可能）
            React.useEffect(() => {
                if (!user && !loading && auth) {
                    const { signInAnonymously } = window.firebaseModules;
                    signInAnonymously(auth).catch(err => {
                        console.error('匿名ログイン失敗:', err);
                        setAuthError('自動ログインに失敗しました: ' + err.message);
                    });
                }
            }, [user, loading, auth]);

            if (loading) return <div className="h-screen flex items-center justify-center text-indigo-600 font-bold animate-pulse">Loading...</div>;
            if (!user) return <div className="h-screen flex items-center justify-center text-indigo-600 font-bold">接続中...</div>;

            if (viewMode === 'world_select') return (
                <div className="min-h-screen bg-gray-100 p-6">
                    <div className="max-w-4xl mx-auto">
                        <div className="flex justify-between items-center mb-6">
                            <h1 className="text-2xl font-bold serif text-gray-800">世界の選択</h1>
                            <div className="flex gap-2 items-center">
                                <span className="text-xs text-gray-400 font-mono">{appContextId}</span>
                                <button onClick={() => setShowConfigEditor(true)} className="text-xs text-gray-500 hover:text-indigo-600"><Icon name="settings" size={14} /></button>
                                <button onClick={() => window.firebaseModules.signOut(auth)} className="text-sm text-red-500 hover:underline ml-2">ログアウト</button>
                            </div>
                        </div>
                        {showConfigEditor && <ConfigEditor currentConfig={activeConfig} currentAppId={appContextId} onSave={handleConfigSave} onCancel={() => setShowConfigEditor(false)} />}
                        <div className="grid md:grid-cols-2 gap-6">
                            <div className="bg-white p-6 rounded-lg shadow"><h2 className="text-lg font-bold mb-4"><Icon name="search" /> 世界を探す</h2><WorldList db={db} appContextId={appContextId} onSelect={(id) => { setWorldId(id); setViewMode('timeline_large'); }} /></div>
                            <div className="bg-white p-6 rounded-lg shadow"><h2 className="text-lg font-bold mb-4"><Icon name="plus-circle" /> 新世界創造</h2>
                                <div className="space-y-3"><input className="w-full border p-2 rounded" placeholder="名前" value={authForm.worldName} onChange={e => setAuthForm({ ...authForm, worldName: e.target.value })} /><button onClick={handleCreateWorld} className="w-full bg-emerald-600 text-white py-2 rounded font-bold">創造</button></div>
                            </div>
                        </div>
                    </div>
                </div>
            );

            return (
                <div className="flex h-screen overflow-hidden bg-gray-100">
                    <div className="flex-1 flex flex-col relative h-full overflow-hidden">
                        <header className="bg-white shadow-sm px-4 py-2 flex items-center justify-between z-10 border-b">
                            <div className="flex items-center gap-4">
                                <div className="hidden md:flex flex-col text-xs text-gray-500">
                                    <span className="text-sm font-bold text-gray-800">{worldData?.name}</span>
                                    <span className="text-[11px] cursor-pointer hover:text-indigo-600" onClick={copyMyId} title="IDコピー">{user?.displayName} (ID)</span>
                                </div>
                                <div className="flex bg-gray-100 p-1 rounded-lg overflow-x-auto no-scrollbar max-w-[200px] md:max-w-none">{VIEW_TABS.map(tab => (<button key={tab.key} onClick={() => setViewMode(tab.key)} className={`px-3 py-1.5 rounded text-sm flex items-center gap-1 whitespace-nowrap ${viewMode === tab.key ? 'bg-white shadow text-indigo-600 font-bold' : 'text-gray-500'}`}><Icon name={tab.icon} size={16} /> {tab.label}</button>))}</div>
                            </div>
                            <div className="flex items-center gap-2 md:gap-4">
                                {(viewMode === 'timeline_large' || viewMode === 'list' || viewMode === 'map') && (
                                    <button onClick={() => setTimelineFilters(prev => ({ ...prev, onlyApproved: !prev.onlyApproved }))} className={`flex items-center gap-1 text-xs px-2 py-1 rounded transition-colors ${timelineFilters.onlyApproved ? 'bg-emerald-600 text-white font-bold' : 'bg-gray-200 text-gray-500 hover:bg-gray-300'}`} title="承認済み記事のみ表示">
                                        <Icon name="check-circle" size={14} />
                                        <span className="hidden sm:inline">承認済のみ</span>
                                    </button>
                                )}
                                <div className="hidden lg:flex items-center text-[11px] text-gray-400"><Icon name="filter" size={12} className="mr-1" /> {timelineSummary} {timelineFilters.onlyApproved && <span className="text-emerald-600 font-bold ml-1">(ON)</span>}</div>
                                <div className="flex items-center gap-1 bg-gray-100 rounded px-1 ml-2">
                                    <button onClick={() => setUiScale(s => Math.max(50, s - 10))} className="p-1 hover:text-indigo-600 text-gray-500" title="縮小"><Icon name="minus" size={12} /></button>
                                    <span className="text-[10px] w-8 text-center text-gray-500 font-mono">{uiScale}%</span>
                                    <button onClick={() => setUiScale(s => Math.min(200, s + 10))} className="p-1 hover:text-indigo-600 text-gray-500" title="拡大"><Icon name="plus" size={12} /></button>
                                </div>
                                {(myRole === 'owner' || myRole === 'admin') && <button onClick={() => setShowAdminPanel(true)} title="管理パネル" className="text-gray-500 hover:text-indigo-600 p-2 rounded-full bg-gray-100"><Icon name="settings" size={18} /></button>}<button onClick={() => { setFormData(createEmptyArticle()); setStats([]); setTagInput(''); setViewMode('edit'); }} className="bg-indigo-600 text-white px-4 py-1.5 rounded text-sm font-bold shadow-sm flex items-center gap-1"><Icon name="plus" size={16} /> {canIApprove ? '作成' : '作成申請'}</button></div>
                        </header>
                        <div className="flex-1 overflow-y-auto relative bg-slate-50" style={{ zoom: uiScale / 100, scrollbarGutter: 'stable' }}>
                            {viewMode === 'list' && <FolderIntegratedList articles={articles} onSelectArticle={(article) => openDetailView(article, 'list')} onTagClick={handleTagClick} onlyApproved={timelineFilters.onlyApproved} onOpenNoYear={(id) => { if (id) { const art = articles.find(x => x.id === id); if (art) setSelectedArticle(art); } setViewMode('timeline_noyear'); }} onSearchChange={p => setTimelineFilters(prev => ({ ...prev, ...p }))} />}
                            {viewMode === 'map' && <div className="absolute inset-0 flex flex-col">
                                <div className="p-3 z-10 bg-white/90 border-b flex items-center gap-4">
                                    <input className="flex-1 p-2 rounded border text-sm max-w-sm" placeholder="地図検索 (タイトル/本文/タグ)..." value={mapTabQuery || ''} onChange={e => setMapTabQuery(e.target.value)} />
                                    <div className="flex items-center gap-2 border-l pl-4">
                                        <span className="text-xs font-bold text-gray-500">重要度:</span>
                                        <div className="flex bg-gray-100 rounded p-0.5">
                                            {[1, 2, 3, 4, 5].map(v => (
                                                <button key={v} onClick={() => setMapTabImportance(mapTabImportance === v ? 0 : v)} className={`px-2 py-0.5 text-xs rounded ${mapTabImportance === v ? 'bg-indigo-600 text-white font-bold' : mapTabImportance > v ? 'text-indigo-600' : 'text-gray-400'}`}>
                                                    {v}
                                                </button>
                                            ))}
                                            <span className="text-[10px] items-center flex px-1 text-gray-400">{mapTabImportance ? '以上' : '指定なし'}</span>
                                        </div>
                                    </div>
                                </div>
                                <div className="flex-1 relative"><MapView articles={articles} worldData={worldData} isEditing={false} externalQuery={mapTabQuery} onExternalQueryChange={v => setMapTabQuery(v)} highlightArticleId={selectedArticle?.id} minImportance={mapTabImportance} onSelectArticle={a => {
                                    // 年代がある記事は年表ビューで拡大表示、年代なしは単独の拡大記事表示
                                    const y = getArticleYear(a);
                                    const hasYear = y && y !== 0 && !a.noYear;

                                    // 記事の年代状態に応じてフィルタを調整
                                    setTimelineFilters(prev => ({ ...prev, excludeNoYear: hasYear }));

                                    if (hasYear) {
                                        setSelectedArticle(a);
                                        setViewMode('timeline_large');
                                    } else {
                                        openDetailView(a, 'map');
                                    }
                                }} appContextId={appContextId} /></div>
                            </div>}
                            {viewMode === 'timeline_large' && <LargeTimelineView articles={filteredTimelineArticles} onSelectArticle={setSelectedArticle} onEditArticle={startEditingArticle} onDeleteArticle={handleDeleteArticle} onDuplicateArticle={handleDuplicateArticle} focusedArticle={selectedArticle} onFocusChange={setSelectedArticle} allArticles={articles} searchState={timelineFilters} onSearchChange={p => setTimelineFilters(prev => ({ ...prev, ...p }))} onResetFilters={() => setTimelineFilters({ type: 'all', keyword: '', tag: '', excludeNoYear: true })} worldData={worldData} appContextId={appContextId} myRole={myRole} onOpenNoYear={(id) => { if (id) { const art = articles.find(x => x.id === id); if (art) { setSelectedArticle(art); setViewMode('single_article'); } } else { setViewMode('timeline_noyear'); } }} onOpenTagArticle={openTagArticle} tagArticleValue={tagArticleInput} onTagArticleValueChange={setTagArticleInput} />}
                            {viewMode === 'stats' && <GraphView setView={setViewMode} articles={articles} />}
                            {viewMode === 'timeline_noyear' && (
                                <div className="absolute inset-0 overflow-auto p-6 bg-slate-900">
                                    <div className="flex items-center justify-between mb-4">
                                        <h2 className="text-xl font-bold text-white">年代未設定の記事一覧</h2>
                                        <div className="flex gap-2"><button onClick={() => setViewMode('timeline_large')} className="px-3 py-1 rounded bg-slate-700 text-white hover:bg-slate-600">年表に戻る</button><button onClick={() => { setPreviousViewMode('timeline_noyear'); setViewMode('edit'); }} className="px-3 py-1 rounded bg-indigo-600 text-white hover:bg-indigo-700">新規作成</button></div>
                                    </div>
                                    <div className="max-w-6xl mx-auto space-y-4">
                                        {articles.filter(a => {
                                            if (a.noYear === true) return true;
                                            const y = Math.floor(getArticleYear(a));
                                            return !y || Number(y) === 0;
                                        }).map(a => (
                                            <div key={a.id} className="bg-slate-800/50 border border-slate-700 rounded-xl p-6 hover:bg-slate-800 transition">
                                                <div className="flex items-center justify-between mb-3"><h3 className="font-bold text-xl text-white">{a.title}</h3><span className="text-xs text-slate-400 font-mono">{a.dateStr || ''}</span></div>
                                                <div className="text-sm text-slate-300 mb-4 rich-editor leading-relaxed" onClick={(e) => {
                                                    const link = e.target.closest && e.target.closest('.wiki-link');
                                                    if (link) {
                                                        e.preventDefault(); e.stopPropagation();
                                                        const id = link.getAttribute('data-article-id');
                                                        const wikiTitle = link.getAttribute('data-wiki-title');
                                                        if (id) {
                                                            const target = articleIndex.get(id);
                                                            if (target) {
                                                                setSelectedArticle(target);
                                                                setViewMode('single_article');
                                                                setTimelineFilters({ type: 'all', keyword: '', tag: '', excludeNoYear: true });
                                                            } else {
                                                                alert('リンク先の記事が見つかりません');
                                                            }
                                                        } else if (wikiTitle) {
                                                            if (wikiTitle === '年代なし') {
                                                                setViewMode('timeline_noyear');
                                                            } else {
                                                                const target = articles.find(x => (x.title || '').trim() === wikiTitle.trim());
                                                                if (target) {
                                                                    setSelectedArticle(target);
                                                                    setViewMode('single_article');
                                                                    setTimelineFilters({ type: 'all', keyword: '', tag: '', excludeNoYear: true });
                                                                } else {
                                                                    alert('リンク先の記事が見つかりません');
                                                                }
                                                            }
                                                        }
                                                    }
                                                }} dangerouslySetInnerHTML={{ __html: transformContent(a.contentHtml || '') }}></div>
                                                <div className="flex justify-end gap-2 border-t border-slate-700 pt-3">
                                                    <button onClick={() => { startEditingArticle(a); }} className="px-3 py-1 rounded bg-slate-700 text-white text-sm hover:bg-slate-600">編集</button>
                                                    <button onClick={() => { handleDuplicateArticle(a); }} className="px-3 py-1 rounded bg-emerald-600 text-white text-sm hover:bg-emerald-700">複製</button>
                                                    {(myRole === 'owner' || myRole === 'admin') && <button onClick={() => { handleDeleteArticle(a); }} className="px-3 py-1 rounded bg-red-600 text-white text-sm hover:bg-red-700">削除</button>}
                                                </div>
                                            </div>
                                        ))}
                                    </div>
                                </div>
                            )}
                            {viewMode === 'single_article' && selectedArticle && (
                                <div className="absolute inset-0 bg-slate-900 overflow-y-auto z-50 p-0">
                                    <div className="sticky top-0 bg-slate-900/95 backdrop-blur border-b border-slate-700 p-4 flex justify-between items-center z-50 shadow-lg">
                                        <div className="flex items-center gap-4">
                                            <button onClick={() => setViewMode('timeline_noyear')} className="flex items-center gap-1 text-sm text-slate-400 hover:text-white"><Icon name="arrow-left" size={16} /> 一覧に戻る</button>
                                            <h2 className="font-bold text-lg truncate max-w-xl flex items-center gap-2 text-white">
                                                {selectedArticle.title}
                                                {selectedArticle.isApproved && <span className="bg-emerald-600 text-white text-xs px-2 py-0.5 rounded flex items-center gap-1"><Icon name="check" size={12} /> 承認済</span>}
                                            </h2>
                                        </div>
                                        <div className="flex gap-2">
                                            <button onClick={() => startEditingArticle(selectedArticle)} className="px-4 py-1.5 bg-indigo-600 text-white text-sm font-bold rounded shadow-sm hover:bg-indigo-700">編集</button>
                                            <button onClick={() => handleDuplicateArticle(selectedArticle)} className="px-4 py-1.5 bg-emerald-600 text-white text-sm font-bold rounded shadow-sm hover:bg-emerald-700">複製</button>
                                            {(myRole === 'owner' || myRole === 'admin') && <button onClick={() => handleDeleteArticle(selectedArticle)} className="px-4 py-1.5 bg-red-600 text-white text-sm font-bold rounded shadow-sm hover:bg-red-700">削除</button>}
                                        </div>
                                    </div>
                                    <div className="max-w-none p-8 md:p-12 mx-auto">
                                        {/* Full width rendering container without constraints for complex tables */}
                                        <div className="prose prose-xl max-w-none prose-invert" style={{ color: '#e2e8f0' }} dangerouslySetInnerHTML={{ __html: transformContent(selectedArticle.contentHtml || '') }} onClick={(e) => {
                                            const link = e.target.closest && e.target.closest('.wiki-link');
                                            if (link) {
                                                e.preventDefault(); e.stopPropagation();
                                                const id = link.getAttribute('data-article-id');
                                                if (id) {
                                                    const target = articleIndex.get(id);
                                                    if (target) {
                                                        const y = getArticleYear(target);
                                                        // 年代設定ありの記事なら年表ビューへ飛ぶ
                                                        if (y && y !== 0 && !target.noYear) {
                                                            setSelectedArticle(target);
                                                            setViewMode('timeline_large');
                                                            // フォーカスを当てるなど
                                                        } else {
                                                            setSelectedArticle(target);
                                                            /* stay in single view */
                                                        }
                                                    }
                                                    else alert('リンク先が見つかりません');
                                                }
                                            }
                                        }}></div>
                                    </div>
                                </div>
                            )}
                            {viewMode === 'edit' && (
                                <div className="absolute inset-0 flex flex-col bg-white z-50">
                                    <div className="border-b px-6 py-3 flex justify-between items-center bg-gray-50">
                                        <h2 className="font-bold text-gray-700 flex items-center gap-2">
                                            {canIApprove ? '編集' : '編集リクエスト'}
                                            {!canIApprove && <span className="text-[10px] bg-amber-100 text-amber-700 px-2 py-0.5 rounded">※承認待ちとなります</span>}
                                        </h2>
                                        <div className="flex gap-2">
                                            <button onClick={() => setViewMode(previousViewMode || 'timeline_large')} className="px-4 py-2 rounded bg-gray-200 text-sm">キャンセル</button>
                                            <button onClick={handleSaveArticle} className={`px-6 py-2 rounded text-white font-bold text-sm ${canIApprove ? 'bg-indigo-600 hover:bg-indigo-700' : 'bg-emerald-600 hover:bg-emerald-700'}`}>
                                                {canIApprove ? '保存' : '申請する'}
                                            </button>
                                        </div>
                                    </div>
                                    <div className="flex-1 flex overflow-hidden">
                                        <div className="flex-1 p-6 overflow-y-auto flex flex-col gap-4">
                                            <input className="w-full text-3xl font-bold p-2 border-b outline-none serif" placeholder="タイトル" value={formData.title} onChange={e => setFormData(prev => ({ ...prev, title: e.target.value }))} />
                                            <div className="grid grid-cols-2 gap-4"><div><label className="text-xs font-bold text-gray-500 block mb-1">期間 (開始) (yyyy/mm/dd-hh:mm:ss)</label><input type="text" className="w-full border p-2 rounded" placeholder="2023/01/01-00:00:00" value={formData.period?.start || ''} onChange={e => setFormData(prev => ({ ...prev, period: { ...(prev.period || {}), start: e.target.value } }))} /></div><div><label className="text-xs font-bold text-gray-500 block mb-1">期間 (終了) (yyyy/mm/dd-hh:mm:ss)</label><input type="text" className="w-full border p-2 rounded" placeholder="2023/12/31-23:59:59" value={formData.period?.end || ''} onChange={e => setFormData(prev => ({ ...prev, period: { ...(prev.period || {}), end: e.target.value } }))} /></div></div>
                                            <div className="grid grid-cols-3 gap-4">
                                                <div>
                                                    <label className="text-xs font-bold text-gray-500 block mb-1">種別</label>
                                                    <select className="w-full border p-2 rounded" value={formData.type} onChange={e => setFormData(prev => ({ ...prev, type: e.target.value }))}>
                                                        {Object.entries(ARTICLE_TYPES).map(([k, v]) => <option key={k} value={k}>{v.label}</option>)}
                                                    </select>
                                                </div>
                                                <div>
                                                    <label className="text-xs font-bold text-gray-500 block mb-1">フォルダ</label>
                                                    <input className="w-full border p-2 rounded" placeholder="国/組織" value={formData.folder} onChange={e => setFormData(prev => ({ ...prev, folder: e.target.value }))} />
                                                </div>
                                                <div>
                                                    <label className="text-xs font-bold text-gray-500 block mb-1">日時 (yyyy/mm/dd-hh:mm:ss)</label>
                                                    <input className="w-full border p-2 rounded" placeholder="2023/11/20-14:00:00" value={formData.dateStr || ''} onChange={e => setFormData(prev => ({ ...prev, dateStr: e.target.value }))} />
                                                </div>
                                            </div>
                                            <div className="my-2">
                                                <label className="text-xs font-bold text-gray-500 block mb-1">重要度 (1-5)</label>
                                                <div className="flex gap-1">
                                                    {[1, 2, 3, 4, 5].map(v => (
                                                        <button key={v} onClick={() => setFormData(prev => ({ ...prev, importance: v }))} className={`px-3 py-1 rounded text-sm font-bold border ${formData.importance === v ? 'bg-yellow-100 text-yellow-600 border-yellow-300' : 'bg-gray-50 text-gray-400'}`}>
                                                            {v}
                                                        </button>
                                                    ))}
                                                </div>
                                            </div>
                                            <div className="flex items-center gap-4">
                                                <label className="flex items-center gap-2 text-sm"><input type="checkbox" checked={!!formData.noYear} onChange={e => setFormData(prev => ({ ...prev, noYear: e.target.checked }))} /> <span className="text-sm text-gray-600">年代なしにする</span></label>
                                                {canIApprove && (
                                                    <label className="flex items-center gap-2 text-sm bg-emerald-50 px-2 py-1 rounded border border-emerald-200">
                                                        <input type="checkbox" checked={!!formData.isApproved} onChange={e => setFormData(prev => ({ ...prev, isApproved: e.target.checked }))} />
                                                        <span className="text-sm font-bold text-emerald-800">承認済みにする</span>
                                                    </label>
                                                )}
                                            </div>
                                            {!canIApprove && (
                                                <div className="text-xs text-gray-500">
                                                    現在のステータス: <span className={`font-bold ${formData.isApproved ? 'text-emerald-600' : 'text-gray-400'}`}>{formData.isApproved ? '承認済み' : '未承認'}</span>
                                                    (承認権限がありません)
                                                </div>
                                            )}
                                            <div className="flex gap-2">
                                                <div className="flex-1"><LocationsEditor locations={formData.locations} onChange={l => setFormData(prev => ({ ...prev, locations: l }))} /></div>
                                                <div className="w-1/3 space-y-2">
                                                    <ArticleLinkInserter articles={articles} onInsert={(a) => {
                                                        if (formData._editorMode === 'html' && htmlTextareaRef.current) {
                                                            const ta = htmlTextareaRef.current;
                                                            const start = ta.selectionStart;
                                                            const end = ta.selectionEnd;
                                                            const text = formData.contentHtml || '';
                                                            const wikiLink = `[[${a.title}|${a.id}]]`;
                                                            const newText = text.substring(0, start) + wikiLink + text.substring(end);
                                                            setFormData(prev => ({ ...prev, contentHtml: newText }));
                                                            setTimeout(() => {
                                                                ta.focus();
                                                                ta.setSelectionRange(start + wikiLink.length, start + wikiLink.length);
                                                            }, 0);
                                                        } else if (editorRef.current) {
                                                            editorRef.current.insertLink(a);
                                                        }
                                                    }} />
                                                    <div className="text-xs text-gray-500">※文字色はエディタのカラー機能で変更できます</div>
                                                </div>
                                            </div>
                                            <div className="space-y-2">
                                                <div className="mt-2 flex items-center gap-3">
                                                    <label className="text-xs font-bold text-gray-500">本文</label>
                                                    <div className="flex items-center gap-2">
                                                        <button onClick={() => setFormData(prev => ({ ...prev, _editorMode: 'wysiwyg' }))} className={`px-2 py-1 rounded text-xs ${formData._editorMode !== 'html' ? 'bg-indigo-600 text-white' : 'bg-white'}`}>WYSIWYG</button>
                                                        <button onClick={() => setFormData(prev => ({ ...prev, _editorMode: 'html' }))} className={`px-2 py-1 rounded text-xs ${formData._editorMode === 'html' ? 'bg-indigo-600 text-white' : 'bg-white'}`}>HTML編集</button>
                                                    </div>
                                                </div>
                                                {formData._editorMode === 'html' ? (
                                                    <div className="flex-1 border rounded overflow-hidden flex flex-col min-h-[320px] bg-white">
                                                        <label className="text-xs font-bold text-gray-500 p-2">HTML ソース</label>
                                                        <textarea ref={htmlTextareaRef} className="w-full h-48 p-2 font-mono text-sm border-t" value={formData.contentHtml || ''} onChange={e => setFormData(prev => ({ ...prev, contentHtml: e.target.value }))} />
                                                        <div className="p-2 border-t">
                                                            <AttachmentUploader storage={storage} appContextId={appContextId} onAddAttachment={(att) => setFormData(prev => ({ ...prev, attachments: [...(prev.attachments || []), att] }))} />
                                                            <div className="mt-2 space-y-1 text-xs">
                                                                {(formData.attachments || []).map((att, i) => (
                                                                    <div key={i} className="flex items-center justify-between gap-2 p-1 bg-gray-50 rounded mb-1">
                                                                        <a className="text-indigo-600 underline truncate flex-1" href={att.url} target="_blank" rel="noreferrer" title={att.name}>{att.name}</a>
                                                                        <div className="flex gap-1">
                                                                            <button onClick={() => copyText(att.url)} className="text-gray-500 hover:text-indigo-600 text-[10px] border px-1 rounded bg-white">URL</button>
                                                                            <button onClick={() => {
                                                                                const tag = `<img src="${att.url}" alt="${att.name}" style="max-width:100%;" />`;
                                                                                if (htmlTextareaRef.current) {
                                                                                    const ta = htmlTextareaRef.current;
                                                                                    const start = ta.selectionStart;
                                                                                    const end = ta.selectionEnd;
                                                                                    const text = formData.contentHtml || '';
                                                                                    const newText = text.substring(0, start) + tag + text.substring(end);
                                                                                    setFormData(prev => ({ ...prev, contentHtml: newText }));
                                                                                    setTimeout(() => {
                                                                                        ta.focus();
                                                                                        ta.setSelectionRange(start + tag.length, start + tag.length);
                                                                                    }, 0);
                                                                                }
                                                                            }} className="text-indigo-600 hover:text-indigo-800 text-[10px] border px-1 rounded font-bold bg-white">IMG挿入</button>
                                                                            <button onClick={() => setFormData(prev => ({ ...prev, attachments: prev.attachments.filter((_, ii) => ii !== i) }))} className="text-red-500 hover:text-red-700 text-[10px] border px-1 rounded bg-white">削除</button>
                                                                        </div>
                                                                    </div>
                                                                ))}
                                                            </div>
                                                        </div>
                                                    </div>
                                                ) : (
                                                    <div className="flex-1 border rounded overflow-hidden flex flex-col min-h-[320px] bg-white"><RichTextEditor ref={editorRef} value={formData.contentHtml || ''} onChange={val => setFormData(prev => ({ ...prev, contentHtml: val }))} /></div>
                                                )}
                                            </div>
                                            <div className="bg-gray-50 p-2 rounded"><label className="text-xs font-bold text-gray-500 block mb-1">タグ (カンマ区切り)</label><input className="w-full border p-2 rounded" placeholder="王, 歴史, 重要" value={tagInput} onChange={e => setTagInput(e.target.value)} /></div>
                                            <div className="bg-white border rounded p-3 shadow-sm space-y-3">
                                                <div className="flex items-center justify-between">
                                                    <div><label className="text-xs font-bold text-gray-500 block mb-1">メイン画像</label></div>
                                                    <ImageUploader storage={storage} appContextId={appContextId} onUploadComplete={url => setFormData(prev => ({ ...prev, mainImageUrl: url }))} label="アップロード" />
                                                </div>
                                                {formData.mainImageUrl && <>
                                                    <img src={formData.mainImageUrl} alt="preview" className="w-full rounded border" />
                                                    <div className="flex gap-2 text-[11px] text-gray-500">
                                                        <button type="button" onClick={() => setFormData(prev => ({ ...prev, mainImageUrl: '' }))} className="px-2 py-1 border rounded">削除</button>
                                                    </div>
                                                </>}
                                            </div>
                                        </div>
                                        <div className="w-80 border-l bg-gray-50 flex flex-col overflow-y-auto">
                                            <div className="h-52 relative border-b">
                                                <MapView
                                                    articles={previewArticles}
                                                    worldData={worldData}
                                                    highlightArticleId={formData?.id || '__draft__'}
                                                    isEditing={true}
                                                    onLocationSelect={c => {
                                                        const newLoc = { lat: Number(c.lat.toFixed(4)), lng: Number(c.lng.toFixed(4)), label: 'New Point' };
                                                        setFormData(prev => ({ ...prev, locations: [...(prev.locations || []), newLoc] }));
                                                    }}
                                                    appContextId={appContextId}
                                                    storage={storage}
                                                    onMapImageUpdate={null} // Disable direct image update in edit sidebar in favor of admin panel
                                                    myRole={myRole}
                                                />
                                            </div>
                                            <div className="p-4 border-t"><div className="text-xs font-bold text-gray-500 mb-2 border-b pb-1">ステータス</div><StatsEditor stats={stats} onChange={setStats} /></div>
                                        </div>
                                    </div>
                                </div>
                            )}
                            {showMemberManager && <MemberManager db={db} worldId={worldId} appContextId={appContextId} onClose={() => setShowMemberManager(false)} />}
                            {showRegionRuleEditor && <RegionRuleEditor rules={regionRules} worldData={worldData} onSave={(r) => { handleSaveRegionRules(r); setShowRegionRuleEditor(false); }} onClose={() => setShowRegionRuleEditor(false)} />}
                            {showAdminPanel && (
                                <div className="fixed inset-0 bg-black/50 flex items-center justify-center z-[9999] p-4">
                                    <div className="bg-white p-6 rounded-lg shadow-xl w-full max-w-md">
                                        <div className="flex justify-between items-center mb-4">
                                            <h3 className="text-lg font-bold text-gray-800">管理パネル</h3>
                                            <button onClick={() => setShowAdminPanel(false)} className="text-gray-500"><Icon name="x" size={18} /></button>
                                        </div>
                                        <div className="space-y-4">
                                            <div className="flex items-center justify-between">
                                                <div>
                                                    <div className="text-sm font-bold">メンバー管理</div>
                                                    <div className="text-xs text-gray-500">メンバーの追加・削除を行います</div>
                                                </div>
                                                <div>
                                                    <button onClick={() => { setShowMemberManager(true); setShowAdminPanel(false); }} className="px-3 py-1.5 bg-indigo-600 text-white rounded text-sm">開く</button>
                                                </div>
                                            </div>
                                            <div className="flex items-center justify-between">
                                                <div>
                                                    <div className="text-sm font-bold">地図レイヤー管理</div>
                                                    <div className="text-xs text-gray-500">複数の地図レイヤーを管理します</div>
                                                </div>
                                                <div>
                                                    {/* Just a placeholder, main UI is below */}
                                                </div>
                                            </div>
                                            <div className="border border-indigo-100 rounded bg-indigo-50 p-3">
                                                <MapLayerManager
                                                    layers={worldData?.mapLayers || (worldData?.mapImageUrl ? [{ id: 'default', name: '標準マップ', url: worldData.mapImageUrl }] : [])}
                                                    onUpdate={handleMapLayersUpdate}
                                                    storage={storage}
                                                    appContextId={appContextId}
                                                />
                                            </div>

                                            <div className="flex items-center justify-between">
                                                <div>
                                                    <div className="text-sm font-bold">地域タグ自動付与</div>
                                                    <div className="text-xs text-gray-500">座標に応じたタグ割り当てルールを設定します</div>
                                                </div>
                                                <div className="flex gap-2">
                                                    <button onClick={handleReapplyRegionTags} className="px-3 py-1.5 bg-gray-500 text-white rounded text-sm hover:bg-gray-600" title="現在のルールに基づいてタグを再計算・追加します">再適用</button>
                                                    <button onClick={() => { setShowRegionRuleEditor(true); setShowAdminPanel(false); }} className="px-3 py-1.5 bg-emerald-600 text-white rounded text-sm">編集</button>
                                                </div>
                                            </div>
                                            <div className="flex items-center justify-between pt-4 border-t">
                                                <div>
                                                    <div className="text-sm font-bold">Discord Webhook設定</div>
                                                    <div className="text-xs text-gray-500">記事更新通知の送信先</div>
                                                </div>
                                                <button onClick={async () => {
                                                    const currentUrl = worldData?.discordWebhookUrl || '';
                                                    const newUrl = prompt('Discord Webhook URLを入力:', currentUrl);
                                                    if (newUrl !== null) {
                                                        try {
                                                            const { doc, updateDoc } = window.firebaseModules;
                                                            await updateDoc(doc(db, 'artifacts', appContextId, 'public', 'data', 'worlds', worldId), { discordWebhookUrl: newUrl });
                                                            alert('Webhook URLを保存しました');
                                                        } catch (e) { alert('保存失敗: ' + e.message); }
                                                    }
                                                }} className="px-3 py-1.5 bg-indigo-500 text-white rounded text-sm">設定</button>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            )}
                        </div>
                    </div >
                </div >
            );
        };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>

</html>