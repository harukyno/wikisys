<!DOCTYPE html>
<html lang="ja">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WorldWeaver - 次世代創作Wiki</title>

    <!-- React & ReactDOM -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>

    <!-- Babel -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>

    <!-- Leaflet -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

    <!-- Lucide Icons -->
    <script src="https://unpkg.com/lucide@latest"></script>

    <!-- Quill.js -->
    <link href="https://cdn.quilljs.com/1.3.6/quill.snow.css" rel="stylesheet">
    <script src="https://cdn.quilljs.com/1.3.6/quill.min.js"></script>

    <!-- Google Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link
        href="https://fonts.googleapis.com/css2?family=Noto+Sans+JP:wght@300;400;500;700&family=Shippori+Mincho:wght@400;600&display=swap"
        rel="stylesheet">
    <!-- JSpreadsheet (Excel-like Grid) -->
    <script src="https://cdn.jsdelivr.net/npm/jspreadsheet-ce@4.13.1/dist/index.min.js"></script>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/jspreadsheet-ce@4.13.1/dist/jspreadsheet.min.css"
        type="text/css" />
    <script src="https://cdn.jsdelivr.net/npm/jsuites/dist/jsuites.min.js"></script>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/jsuites/dist/jsuites.min.css" type="text/css" />

    <!-- Vis Network -->
    <script type="text/javascript" src="https://unpkg.com/vis-network/standalone/umd/vis-network.min.js"></script>

    <!-- Firebase SDK -->
    <script type="module">
        import { initializeApp, deleteApp, getApps } from "https://www.gstatic.com/firebasejs/10.14.1/firebase-app.js";
        import { getAuth, signInWithEmailAndPassword, createUserWithEmailAndPassword, signInAnonymously, onAuthStateChanged, signOut, updateProfile, setPersistence, browserLocalPersistence } from "https://www.gstatic.com/firebasejs/10.14.1/firebase-auth.js";
        import { getFirestore, collection, doc, setDoc, addDoc, updateDoc, deleteDoc, onSnapshot, serverTimestamp, query, where, getDoc } from "https://www.gstatic.com/firebasejs/10.14.1/firebase-firestore.js";
        import { getStorage, ref, uploadBytes, getDownloadURL } from "https://www.gstatic.com/firebasejs/10.14.1/firebase-storage.js";

        window.firebaseModules = {
            initializeApp, deleteApp, getApps,
            getAuth, signInWithEmailAndPassword, createUserWithEmailAndPassword, signInAnonymously, onAuthStateChanged, signOut, updateProfile, setPersistence, browserLocalPersistence,
            getFirestore, collection, doc, setDoc, addDoc, updateDoc, deleteDoc, onSnapshot, serverTimestamp, query, where, getDoc,
            getStorage, ref, uploadBytes, getDownloadURL
        };
    </script>

    <style>
        /* フォント指定 */
        body {
            font-family: 'Noto Sans JP', sans-serif;
            background-color: #f3f4f6;
        }

        .serif {
            font-family: 'Shippori Mincho', serif;
        }

        /* その他のスタイル */
        #map-container {
            height: 100%;
            width: 100%;
            z-index: 0;
        }

        .wiki-link {
            color: #2563eb;
            text-decoration: underline;
            cursor: pointer;
        }

        .wiki-link:hover {
            color: #1d4ed8;
            background-color: rgba(37, 99, 235, 0.1);
        }

        .folder-tree-item {
            cursor: pointer;
            user-select: none;
        }

        .folder-tree-item:hover {
            background-color: #f3f4f6;
        }

        .rich-editor h1 {
            font-size: 1.5em;
            font-weight: bold;
            margin: 0.5em 0;
        }

        .rich-editor h2 {
            font-size: 1.3em;
            font-weight: bold;
            margin: 0.5em 0;
            border-bottom: 1px solid #ddd;
        }

        .rich-editor ul {
            list-style-type: disc;
            margin-left: 1.5em;
        }

        .rich-editor ol {
            list-style-type: decimal;
            margin-left: 1.5em;
        }

        .rich-editor blockquote {
            border-left: 4px solid #ccc;
            padding-left: 1em;
            color: #666;
        }

        /* Quill Editor Customization */
        .ql-container {
            font-family: 'Noto Sans JP', sans-serif;
            font-size: 16px;
        }

        .ql-editor {
            min-height: 200px;
        }

        /* カスタムスクロールバー */
        .custom-scrollbar::-webkit-scrollbar {
            width: 6px;
            height: 6px;
        }

        .custom-scrollbar::-webkit-scrollbar-track {
            background: #f1f1f1;
        }

        .custom-scrollbar::-webkit-scrollbar-thumb {
            background: #ccc;
            border-radius: 3px;
        }

        .custom-scrollbar::-webkit-scrollbar-thumb:hover {
            background: #aaa;
        }

        /* テーブルの基本スタイル（記事表示用） */
        .prose table {
            border-collapse: collapse;
            width: 100%;
            margin: 1rem 0;
            border: 1px solid #444;
            background-color: rgba(255, 255, 255, 0.05);
        }

        .prose th,
        .prose td {
            border: 1px solid #444;
            padding: 8px;
            text-align: left;
        }

        .prose th {
            background-color: rgba(255, 255, 255, 0.1);
            font-weight: bold;
        }

        /* ダークモード環境用（.prose-invertなど） */
        .prose-invert table,
        .prose-invert th,
        .prose-invert td {
            border-color: #475569;
            /* slate-600 */
        }

        /* Placeholder style when table HTML is omitted from editor content */
        .csv-block .csv-placeholder {
            border: 1px dashed #666;
            padding: 8px;
            background: #fff;
            color: #222;
            font-size: 13px;
            border-radius: 6px;
            text-align: center;
        }

        /* スナップスクロール用 */
        .snap-y-mandatory {
            scroll-snap-type: y mandatory;
        }

        .snap-center {
            scroll-snap-align: center;
        }

        .snap-x-mandatory {
            scroll-snap-type: x mandatory;
        }

        .snap-start {
            scroll-snap-align: start;
        }

        /* マインドマップ風ライン */
        .mindmap-branch {
            position: absolute;
            left: -2rem;
            top: 50%;
            width: 2rem;
            height: 1px;
            background-color: rgba(255, 255, 255, 0.3);
        }

        /* タイムラインメーター */
        .timeline-ruler {
            background-image: linear-gradient(to bottom, rgba(255, 255, 255, 0.2) 1px, transparent 1px);
            background-size: 100% 40px;
        }

        /* スムーズスクロール */
        .scroll-smooth {
            scroll-behavior: smooth;
        }

        /* マップラベル */
        .leaflet-tooltip.map-label {
            background-color: rgba(255, 255, 255, 0.85);
            border: 1px solid rgba(0, 0, 0, 0.1);
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.2);
            font-size: 11px;
            font-weight: bold;
            color: #333;
            padding: 0px 4px;
            border-radius: 4px;
            margin-top: -3px;
        }
    </style>
</head>

<body>
    <div id="root"></div>

    <script type="text/babel">
        // --- デフォルト設定 ---
        const DEFAULT_CONFIG = {
            apiKey: "AIzaSyDp-ct-XP-4O-6Z_sZVFjyrgmDGbTplCps",
            authDomain: "rtts-studio.firebaseapp.com",
            projectId: "rtts-studio",
            storageBucket: "rtts-studio.firebasestorage.app",
            messagingSenderId: "980630089634",
            appId: "1:980630089634:web:7a3ee9ed7e118b99598cfb",
            measurementId: "G-D5YX71KKVP"
        };

        // 初期のデータID
        const DEFAULT_APP_CONTEXT_ID = 'world-weaver-wiki-v4';

        const ARTICLE_TYPES = {
            person: { label: '人物', color: 'bg-blue-100 text-blue-800', icon: 'user' },
            event: { label: '事象', color: 'bg-red-100 text-red-800', icon: 'flame' },
            region: { label: '地域', color: 'bg-green-100 text-green-800', icon: 'map' },
            organization: { label: '組織', color: 'bg-purple-100 text-purple-800', icon: 'building' },
            ideology: { label: '思想・宗教', color: 'bg-emerald-100 text-emerald-800', icon: 'star' },
            item: { label: '物品', color: 'bg-amber-100 text-amber-800', icon: 'package' },
            spreadsheet: { label: 'データ表', color: 'bg-cyan-100 text-cyan-800', icon: 'table-2' },
            other: { label: 'その他', color: 'bg-gray-100 text-gray-800', icon: 'box' }
        };

        // ビュー設定：構造年表（Large Timeline）をメインの年表として統合
        const VIEW_TABS = [
            { key: 'list', label: '一覧', icon: 'list' },
            { key: 'map', label: '地図', icon: 'map' },
            { key: 'timeline_large', label: '構造年表', icon: 'git-branch' },
            { key: 'network', label: '相関図', icon: 'share-2' },
            { key: 'spreadsheet', label: 'データ', icon: 'table-2' },
            { key: 'stats', label: '統計', icon: 'bar-chart-2' }
        ];

        // Region tag rules: define rectangles or circles to auto-assign tags when a location falls inside.
        // Rectangle example: { tag: 'north', type: 'rect', bounds: { latMin: -500, latMax: 500, lngMin: -500, lngMax: 0 } }
        // Circle example: { tag: 'capital', type: 'circle', center: { lat: 0, lng: 0 }, radiusKm: 100 }
        // Leave empty to disable auto region tags.
        const REGION_TAG_RULES = [
            // { tag: 'north', type: 'rect', bounds: { latMin: -500, latMax: 500, lngMin: -500, lngMax: 0 } },
            // { tag: 'capital', type: 'circle', center: { lat: 0, lng: 0 }, radiusKm: 100 }
        ];

        // Region auto-tag rules default (editable via GUI)
        const REGION_TAG_RULES_DEFAULT = [
            // { tag: 'north', type: 'rect', bounds: { latMin: -500, latMax: 500, lngMin: -500, lngMax: 0 } },
            // { tag: 'capital', type: 'circle', center: { lat: 0, lng: 0 }, radiusKm: 100 }
        ];

        const createEmptyArticle = () => ({
            title: '',
            type: 'person',
            folder: '未分類',
            contentHtml: '',
            year: 0,
            period: { start: '', end: '' }, // 期間設定用
            dateStr: '',
            representedTag: '',
            locations: [], // 複数地点用 { lat, lng, label }
            locationArticleId: '',
            mainImageUrl: ''
            , noYear: false
            , importance: 3 // 重要度 (1-5)
            , attachments: [] // { name, url }
            , _editorMode: 'wysiwyg' // default editor view
        });

        const stripHtml = (html = '') => html.replace(/<[^>]*>/g, ' ');

        const safeArray = (val) => {
            if (Array.isArray(val)) return val;
            if (typeof val === 'string') return val.split(',').map(s => s.trim()).filter(Boolean);
            return [];
        };

        // 年代抽出ユーティリティ
        const parseYear = (val) => {
            if (!val) return 0;
            if (typeof val === 'number') return val;
            // 文字列の場合、先頭の数字（負号含む）を年とみなす
            const match = val.toString().match(/^(\-?\d+)/);
            return match ? parseInt(match[1], 10) : 0;
        };

        // ソート用キー計算（期間がある場合は平均年を使用）
        const getArticleYear = (article) => {
            if (article.period && (article.period.start || article.period.end)) {
                const start = parseYear(article.period.start) || parseYear(article.year);
                const end = parseYear(article.period.end) || start;
                return (start + end) / 2;
            }
            // dateStrがある場合はそちらを優先
            if (article.dateStr) {
                return parseYear(article.dateStr);
            }
            return article.year || 0;
        };

        const chronologyKey = (article) => {
            const y = getArticleYear(article);
            // ゼロ埋めして文字列化（マイナス年も考慮してオフセットを加える簡易実装）
            return String(Math.floor(y + 100000)).padStart(10, '0');
        };

        const sortByChronology = (list = []) => [...list].sort((a, b) => {
            const ya = getArticleYear(a);
            const yb = getArticleYear(b);
            // treat missing/zero year as large value so they sort after dated items
            const va = (!ya || Number.isNaN(ya) || Number(ya) === 0) ? Number.MAX_SAFE_INTEGER : ya;
            const vb = (!yb || Number.isNaN(yb) || Number(yb) === 0) ? Number.MAX_SAFE_INTEGER : yb;
            return va - vb;
        });

        const filterTimelineArticles = (articles = [], filters = { type: 'all', keyword: '', tag: '', excludeNoYear: false }) => {
            const keyword = (filters.keyword || '').trim().toLowerCase();
            const tag = (filters.tag || '').replace(/^#/, '').trim().toLowerCase();
            const type = (filters.type || 'all');
            const minImportance = Number(filters.minImportance) || 0;
            return sortByChronology(articles).filter(article => {
                if (filters.excludeNoYear) {
                    const y = getArticleYear(article);
                    if (!y || Number.isNaN(y) || Number(y) === 0) return false;
                }
                if (filters.onlyApproved && !article.isApproved) return false;
                if (type !== 'all' && article.type !== type) return false;
                if (minImportance > 0 && (article.importance || 3) < minImportance) return false;
                if (keyword) {
                    const haystack = [
                        article.title,
                        article.folder,
                        stripHtml(article.contentHtml || ''),
                        safeArray(article.tags).join(' '),
                        article.representedTag || ''
                    ].join(' ').toLowerCase();
                    if (!haystack.includes(keyword)) return false;
                }
                if (tag) {
                    const tags = safeArray(article.tags).map(t => t.toLowerCase());
                    const rep = (article.representedTag || '').toLowerCase();
                    if (!tags.includes(tag) && rep !== tag) return false;
                }
                return true;
            });
        };

        // 記事が持つ全ての地点を取得
        const getArticleLocations = (article) => {
            if (!article) return [];
            const locs = [];
            // 新仕様: locations配列
            if (article.locations && Array.isArray(article.locations)) {
                article.locations.forEach(l => {
                    if (l.lat != null && l.lng != null) locs.push({ lat: parseFloat(l.lat), lng: parseFloat(l.lng), label: l.label || article.title, sourceId: article.id });
                });
            }
            // 旧仕様: lat, lng (互換性のため)
            if (article.lat != null && article.lng != null && article.lat !== '' && article.lng !== '') {
                const lat = parseFloat(article.lat);
                const lng = parseFloat(article.lng);
                // 重複チェック（簡易）
                if (!locs.some(l => Math.abs(l.lat - lat) < 0.0001 && Math.abs(l.lng - lng) < 0.0001)) {
                    locs.push({ lat, lng, label: article.title, sourceId: article.id });
                }
            }
            return locs;
        };

        // 再帰的に場所解決
        const resolveArticleLocation = (article, lookup = new Map(), visited = new Set()) => {
            if (!article) return null;
            const locs = getArticleLocations(article);
            if (locs.length > 0) return locs[0]; // 代表地点を返す

            if (article.locationArticleId) {
                if (visited.has(article.locationArticleId)) return null;
                visited.add(article.locationArticleId);
                return resolveArticleLocation(lookup.get(article.locationArticleId), lookup, visited);
            }
            return null;
        };

        // haversine distance (km) for circle-based region checks
        const haversineDistanceKm = (a, b) => {
            const R = 6371;
            const toRad = (x) => (x * Math.PI) / 180;
            const dLat = toRad(b.lat - a.lat);
            const dLng = toRad(b.lng - a.lng);
            const lat1 = toRad(a.lat);
            const lat2 = toRad(b.lat);
            const sinDLat = Math.sin(dLat / 2);
            const sinDLng = Math.sin(dLng / 2);
            const h = sinDLat * sinDLat + Math.cos(lat1) * Math.cos(lat2) * sinDLng * sinDLng;
            return 2 * R * Math.asin(Math.min(1, Math.sqrt(h)));
        };

        // --- Large Spreadsheet View (Database View for Viewer) ---
        const LargeSpreadsheetView = ({ articles, filters }) => {
            const containerRef = React.useRef(null);
            const jexcelRef = React.useRef(null);

            const filtered = articles.filter(a => {
                const typeMatch = filters.type === 'all' || a.type === filters.type;
                const keywordMatch = !filters.keyword ||
                    a.title.toLowerCase().includes(filters.keyword.toLowerCase()) ||
                    (a.folder || '').toLowerCase().includes(filters.keyword.toLowerCase());
                return typeMatch && keywordMatch;
            }).sort((a, b) => (a.year || 0) - (b.year || 0));

            React.useEffect(() => {
                if (!containerRef.current) return;
                const data = filtered.map(a => [
                    a.id,
                    a.title,
                    a.type,
                    a.folder,
                    a.year || 0,
                    a.importance || 3,
                    safeArray(a.tags).join(', ')
                ]);
                if (jexcelRef.current) jexcelRef.current.destroy();
                jexcelRef.current = jspreadsheet(containerRef.current, {
                    data: data,
                    columns: [
                        { type: 'text', title: 'ID', width: 100, readOnly: true },
                        { type: 'text', title: 'タイトル', width: 250, readOnly: true },
                        { type: 'text', title: '種別', width: 100, readOnly: true },
                        { type: 'text', title: 'フォルダ', width: 120, readOnly: true },
                        { type: 'numeric', title: '年代', width: 80, readOnly: true },
                        { type: 'numeric', title: '重要度', width: 60, readOnly: true },
                        { type: 'text', title: 'タグ', width: 200, readOnly: true },
                    ],
                    search: true,
                    pagination: 20,
                });
            }, [filtered.length]);

            return (
                <div className="p-4 bg-white/10 backdrop-blur rounded-xl border border-white/10 h-full flex flex-col">
                    <h2 className="text-xl font-bold text-slate-800 mb-4 flex items-center gap-2 px-2">
                        <Icon name="table-2" className="text-indigo-600" /> 世界データ・スプレッドシート
                    </h2>
                    <div className="flex-1 overflow-auto bg-white rounded-lg shadow-inner">
                        <div ref={containerRef}></div>
                    </div>
                </div>
            );
        };

        // --- Network Graph View ---
        const NetworkGraphView = ({ articles, onArticleSelect, focusedArticle, worldData }) => {
            const containerRef = React.useRef(null);
            const networkRef = React.useRef(null);
            const [searchQuery, setSearchQuery] = React.useState('');
            const [groupingTag, setGroupingTag] = React.useState('');
            const [showTagNodes, setShowTagNodes] = React.useState(false); // Tag Hub Mode
            const [showMapMode, setShowMapMode] = React.useState(false); // Map Mode
            const [availableTags, setAvailableTags] = React.useState([]);
            const [targetYear, setTargetYear] = React.useState(null); // Time Sizing Mode
            const [yearRange, setYearRange] = React.useState({ min: 0, max: 0 });

            // Map Image Loading
            // Map Image Loading & Aspect Ratio
            const mapImageRef = React.useRef(null);
            const [mapAspectRatio, setMapAspectRatio] = React.useState(2); // Default 2:1 (Equirectangular)

            React.useEffect(() => {
                if (worldData?.mapImageUrl) {
                    const img = new Image();
                    img.src = worldData.mapImageUrl;
                    img.onload = () => {
                        mapImageRef.current = img;
                        setMapAspectRatio(img.width / img.height);
                        if (networkRef.current) networkRef.current.redraw();
                    };
                }
            }, [worldData?.mapImageUrl]);

            // Collect all unique tags and Year Range
            React.useEffect(() => {
                const tags = new Set();
                let minYear = Infinity;
                let maxYear = -Infinity;
                let hasYears = false;

                articles.forEach(a => {
                    safeArray(a.tags).forEach(t => tags.add(t));
                    const y = getArticleYear(a);
                    if (y && y !== 0 && !a.noYear) {
                        minYear = Math.min(minYear, y);
                        maxYear = Math.max(maxYear, y);
                        hasYears = true;
                    }
                });
                setAvailableTags(Array.from(tags).sort());
                if (hasYears) {
                    setYearRange({ min: Math.floor(minYear), max: Math.ceil(maxYear) });
                    if (targetYear === null) setTargetYear(Math.floor(minYear)); // Default to start
                }
            }, [articles]);

            React.useEffect(() => {
                if (!containerRef.current || !articles) return;

                console.log(`[NetworkGraph] Rendering with showMapMode=${showMapMode}, articles=${articles.length}`);

                // Count articles with coordinates
                const articlesWithCoords = articles.filter(a => {
                    if (Array.isArray(a.locations) && a.locations.length > 0) {
                        const loc = a.locations[0];
                        return loc.lat != null && loc.lng != null;
                    }
                    return false;
                });
                console.log(`[NetworkGraph] Articles with coordinates: ${articlesWithCoords.length}`, articlesWithCoords.map(a => ({ title: a.title, loc: a.locations[0] })));

                // 1. Prepare Data
                const nodes = [];
                const edges = [];
                const articleMap = new Map(); // Title -> ID mapping for link resolution
                const idMap = new Map();

                articles.forEach(a => {
                    articleMap.set(a.title, a.id);
                    idMap.set(a.id, a);
                });

                // Coordinate conversion constants
                const DEG_TO_PX = 15; // 1度あたりのピクセル数

                // Create Nodes
                articles.forEach(a => {
                    const typeInfo = ARTICLE_TYPES[a.type] || ARTICLE_TYPES.other;
                    let color = '#e5e7eb'; // default gray-200
                    if (typeInfo.color.includes('blue')) color = '#bfdbfe';
                    if (typeInfo.color.includes('red')) color = '#fecaca';
                    if (typeInfo.color.includes('green')) color = '#bbf7d0';
                    if (typeInfo.color.includes('purple')) color = '#e9d5ff';
                    if (typeInfo.color.includes('emerald')) color = '#a7f3d0';
                    if (typeInfo.color.includes('amber')) color = '#fde68a';
                    if (typeInfo.color.includes('cyan')) color = '#a5f3fc';

                    // Highlight logic if search query matches
                    let borderWidth = 1;
                    let borderColor = '#666';
                    if (searchQuery) {
                        const match = (a.title || '').toLowerCase().includes(searchQuery.toLowerCase()) ||
                            safeArray(a.tags).some(t => t.toLowerCase().includes(searchQuery.toLowerCase()));
                        if (match) {
                            borderColor = '#ef4444';
                            borderWidth = 3;
                        }
                    }

                    // Center high importance nodes
                    let initialX = undefined;
                    let initialY = undefined;
                    let fixed = false;
                    let nodeMass;
                    let importance = a.importance || 3;

                    // Time Sizing Logic
                    // If targetYear is active, attenuate importance based on time distance
                    // UNLESS noYear is true or year is missing
                    if (targetYear !== null) {
                        const y = getArticleYear(a);
                        if (y && y !== 0 && !a.noYear) {
                            const diff = Math.abs(y - targetYear);
                            // Decay factor: Half-life of 50 years?
                            // Scale factor decreases as diff increases
                            const scale = 1 / (1 + diff / 50);
                            importance = importance * scale;
                            // Ensure minimum size visibility (but small)
                            if (importance < 0.5) importance = 0.5;
                        }
                    }

                    // Map Mode Logic: Lock coords if exists
                    if (showMapMode && Array.isArray(a.locations) && a.locations.length > 0) {
                        const loc = a.locations[0]; // Use first location
                        if (loc.lat != null && loc.lng != null) {
                            const valLng = Number(loc.lng) || 0;
                            const valLat = Number(loc.lat) || 0;

                            // Use pixel coordinates directly (same as MapView)
                            // MapView uses: L.circleMarker([loc.lat, loc.lng], ...)
                            // vis.js canvas: x = lng, y = lat (no conversion needed)
                            initialX = valLng;
                            initialY = valLat;

                            fixed = { x: true, y: true };
                            console.log(`[Map Mode] Locking node: ${a.title} at (${valLng}, ${valLat}) -> px(${initialX}, ${initialY})`);
                        }
                    } else if (importance >= 4 && !showMapMode) {
                        // Standard Mode High Importance logic
                        nodeMass = importance * 1.5;
                        initialX = (Math.random() - 0.5) * 100;
                        initialY = (Math.random() - 0.5) * 100;
                        fixed = false;
                    } else {
                        nodeMass = 1;
                        fixed = false;
                    }

                    const nodeData = {
                        id: a.id,
                        label: a.title,
                        group: a.type,
                        value: importance, // Size based on importance
                        mass: nodeMass,
                        x: initialX,
                        y: initialY,
                        color: { background: color, border: borderColor },
                        borderWidth: borderWidth,
                        shape: 'dot',
                        font: { size: 14, color: '#333' },
                        tags: safeArray(a.tags),
                        // Custom props for edge logic
                        lng: Number(a.lng) || 0,
                        hasLoc: (a.lng != null)
                    };

                    // Only set fixed if it's actually fixed (vis.js requires object or undefined, not false)
                    if (fixed) {
                        nodeData.fixed = fixed;
                    }

                    nodes.push(nodeData);

                    // Create Edges from [[Link]]
                    const linkRegex = /\[\[(.*?)(?:\|(.*?))?\]\]/g;
                    let match;
                    const content = (a.contentHtml || '') + (a.summary || ''); // Search in content

                    const addEdge = (targetId) => {
                        if (targetId && targetId !== a.id && idMap.has(targetId)) {
                            // Infinite Edge Wrapping Logic prep
                            const target = idMap.get(targetId);
                            let hidden = false;

                            if (showMapMode && mapImageRef.current) {
                                const aLoc = Array.isArray(a.locations) && a.locations.length > 0 ? a.locations[0] : null;
                                const tLoc = Array.isArray(target.locations) && target.locations.length > 0 ? target.locations[0] : null;

                                if (aLoc?.lng != null && tLoc?.lng != null) {
                                    const diff = Math.abs(Number(aLoc.lng) - Number(tLoc.lng));
                                    // If edge crosses more than half the map width, it wraps
                                    if (diff > mapImageRef.current.width / 2) {
                                        hidden = true; // Use custom drawing for these
                                    }
                                }
                            }

                            edges.push({
                                from: a.id,
                                to: targetId,
                                arrows: 'to',
                                color: { color: '#ccc', opacity: hidden ? 0 : 0.5 },
                                hidden: false, // We use 'opacity:0' to hide but keep physics/data, or actual hidden:true
                                width: hidden ? 0 : 1, // Minimize visual impact if "hidden"
                                isWrapped: hidden
                            });
                        }
                    };

                    while ((match = linkRegex.exec(content)) !== null) {
                        const linkText = match[1];
                        const linkId = match[2];
                        if (linkId) {
                            addEdge(linkId);
                        } else {
                            const targetId = articleMap.get(linkText);
                            if (targetId) addEdge(targetId);
                        }
                    }
                });

                // Tag Node Generation (Hubs)
                if (showTagNodes) {
                    const uniqueTags = new Set();
                    articles.forEach(a => safeArray(a.tags).forEach(t => uniqueTags.add(t)));

                    uniqueTags.forEach(tag => {
                        const tagId = `tag_${tag}`;
                        nodes.push({
                            id: tagId,
                            label: '#' + tag,
                            group: '__tag__',
                            value: 5,
                            mass: 3,
                            color: { background: '#818cf8', border: '#4f46e5' }, // Indigo-400/600
                            shape: 'diamond',
                            font: { size: 14, color: '#4f46e5', face: 'arial' },
                            isTagNode: true
                        });
                        idMap.set(tagId, { title: tag, isTag: true }); // Dummy obj for selection safety
                    });

                    // Add edges from articles to their tags
                    articles.forEach(a => {
                        safeArray(a.tags).forEach(tag => {
                            const tagId = `tag_${tag}`;
                            edges.push({
                                from: a.id,
                                to: tagId,
                                arrows: undefined, // No arrows for tag relations
                                color: { color: '#a5b4fc', opacity: 0.3 },
                                length: 250,
                                dashes: true
                            });
                        });
                    });
                }

                const data = { nodes: new vis.DataSet(nodes), edges: new vis.DataSet(edges) };

                const options = {
                    nodes: {
                        shape: 'dot',
                        scaling: {
                            min: 10,
                            max: 30,
                            label: { enabled: true, min: 14, max: 24 }
                        }
                    },
                    edges: {
                        smooth: { type: 'continuous' }
                    },
                    physics: {
                        stabilization: false,
                        barnesHut: {
                            gravitationalConstant: -30000,
                            springConstant: 0.04,
                            springLength: 300
                        },
                        enabled: true // Always enable physics so un-anchored nodes float
                    },
                    layout: {
                        improvedLayout: false // Disable to prevent infinite loop/warnings on large graphs
                    },
                    interaction: {
                        tooltipDelay: 200,
                        hideEdgesOnDrag: true
                    }
                };

                // Initialize Network
                networkRef.current = new vis.Network(containerRef.current, data, options);

                // --- Canvas Events for Map Mode ---
                networkRef.current.on("beforeDrawing", (ctx) => {
                    if (!showMapMode || !mapImageRef.current) return;

                    const mapImg = mapImageRef.current;

                    // Use image pixel dimensions directly (same as MapView)
                    // MapView bounds: [[-img.height/2, -img.width/2], [img.height/2, img.width/2]]
                    const worldWidth = mapImg.width;
                    const worldHeight = mapImg.height;

                    // Draw centered at 0,0
                    const drawMap = (offsetX) => {
                        ctx.save();
                        ctx.globalAlpha = 0.5;
                        ctx.drawImage(mapImg, -worldWidth / 2 + offsetX, -worldHeight / 2, worldWidth, worldHeight);
                        ctx.restore();
                    };

                    drawMap(0);
                    drawMap(-worldWidth);
                    drawMap(worldWidth);
                });

                networkRef.current.on("afterDrawing", (ctx) => {
                    if (!showMapMode || !mapImageRef.current) return;

                    // Custom Edge Wrapping Drawing
                    const worldWidth = mapImageRef.current.width;

                    edges.forEach(edge => {
                        if (edge.isWrapped) {
                            const nodeFrom = data.nodes.get(edge.from);
                            const nodeTo = data.nodes.get(edge.to);
                            if (!nodeFrom || !nodeTo) return;

                            const posFrom = networkRef.current.getPositions([edge.from])[edge.from];
                            const posTo = networkRef.current.getPositions([edge.to])[edge.to];

                            if (posFrom && posTo) {
                                ctx.save();
                                ctx.strokeStyle = '#ccc';
                                ctx.lineWidth = 1;
                                ctx.setLineDash([5, 5]); // Dashed line for wrapped connections

                                let leftX = -worldWidth / 2;
                                let rightX = worldWidth / 2;

                                if (posFrom.x < posTo.x) { // Left to Right wrap
                                    ctx.beginPath();
                                    ctx.moveTo(posFrom.x, posFrom.y);
                                    ctx.lineTo(leftX, (posFrom.y + posTo.y) / 2);
                                    ctx.stroke();

                                    ctx.beginPath();
                                    ctx.moveTo(rightX, (posFrom.y + posTo.y) / 2);
                                    ctx.lineTo(posTo.x, posTo.y);
                                    ctx.stroke();
                                } else { // Right to Left wrap
                                    ctx.beginPath();
                                    ctx.moveTo(posFrom.x, posFrom.y);
                                    ctx.lineTo(rightX, (posFrom.y + posTo.y) / 2);
                                    ctx.stroke();

                                    ctx.beginPath();
                                    ctx.moveTo(leftX, (posFrom.y + posTo.y) / 2);
                                    ctx.lineTo(posTo.x, posTo.y);
                                    ctx.stroke();
                                }
                                ctx.restore();
                            }
                        }
                    });
                });
            });

            networkRef.current.on("click", function (params) {
                if (params.nodes.length > 0) {
                    const nodeId = params.nodes[0];
                    // check if it is a cluster
                    if (networkRef.current.isCluster(nodeId)) {
                        networkRef.current.openCluster(nodeId);
                        return;
                    }
                    if (onArticleSelect) onArticleSelect(idMap.get(nodeId));
                }
            });

            // Apply Clustering if groupingTag is set
            if (groupingTag) {
                const clusterOptions = {
                    joinCondition: (nodeOptions) => {
                        return nodeOptions.tags && nodeOptions.tags.includes(groupingTag);
                    },
                    clusterNodeProperties: {
                        id: 'cluster_' + groupingTag,
                        label: groupingTag,
                        color: '#fbbf24',
                        shape: 'ellipse',
                        borderWidth: 3,
                        font: { size: 18, color: '#000', face: 'arial' },
                        allowSingleNodeCluster: true
                    }
                };
                networkRef.current.cluster(clusterOptions);
            }

            return () => {
                if (networkRef.current) networkRef.current.destroy();
            };
        }, [articles, searchQuery, groupingTag, showTagNodes, showMapMode, worldData, targetYear, mapAspectRatio]); // Re-render when these change

        // Handle Focus on External Select (or Search Result Click if we implement that)
        React.useEffect(() => {
            if (focusedArticle && networkRef.current) {
                // check if node exists or is in cluster
                const indices = networkRef.current.body.nodeIndices;
                if (indices.includes(focusedArticle.id)) {
                    networkRef.current.focus(focusedArticle.id, { animation: true, scale: 1.0 });
                    networkRef.current.selectNodes([focusedArticle.id]);
                }
            }
        }, [focusedArticle]);

        return (
            <div className="h-full flex flex-col bg-white/10 backdrop-blur rounded-xl border border-white/10 overflow-hidden relative group">
                <div className="p-4 bg-white/80 border-b flex justify-between items-center">
                    <h2 className="text-xl font-bold text-gray-800 flex items-center gap-2">
                        <Icon name="share-2" className="text-indigo-500" /> 相関図ネットワーク
                    </h2>
                    <div className="text-sm text-gray-500 hidden md:block">
                        ノードをダブルクリックで開く / タグでバブル化
                    </div>
                </div>

                {/* Graph Controls Overlay */}
                <div className="absolute top-16 left-4 z-10 flex flex-col gap-2 w-64">
                    <input
                        className="w-full bg-white/90 border border-gray-300 rounded px-3 py-1.5 text-sm shadow-sm focus:ring-2 focus:ring-indigo-500 focus:outline-none"
                        placeholder="検索 (ノード強調)..."
                        value={searchQuery}
                        onChange={e => setSearchQuery(e.target.value)}
                    />
                    <div className="relative">
                        <input
                            className="w-full bg-white/90 border border-gray-300 rounded px-3 py-1.5 text-sm shadow-sm focus:ring-2 focus:ring-amber-500 focus:outline-none"
                            placeholder="タグでバブル化 (例: History)..."
                            value={groupingTag}
                            onChange={e => setGroupingTag(e.target.value)}
                            list="grouping-tags-list"
                        />
                        <datalist id="grouping-tags-list">
                            {availableTags.slice(0, 50).map(t => <option key={t} value={t} />)}
                        </datalist>
                        {groupingTag && (
                            <button onClick={() => setGroupingTag('')} className="absolute right-2 top-1.5 text-gray-400 hover:text-gray-600">
                                <Icon name="x" size={14} />
                            </button>
                        )}

                    </div>

                    <label className="flex items-center gap-2 cursor-pointer bg-white/90 border border-gray-300 rounded px-3 py-1.5 shadow-sm hover:bg-white transition-colors">
                        <input
                            type="checkbox"
                            checked={showTagNodes}
                            onChange={e => setShowTagNodes(e.target.checked)}
                            className="rounded text-indigo-600 focus:ring-indigo-500"
                        />
                        <span className="text-sm font-bold text-gray-700">タグをノード化 (Hub)</span>
                    </label>

                    <label className="flex items-center gap-2 cursor-pointer bg-white/90 border border-gray-300 rounded px-3 py-1.5 shadow-sm hover:bg-white transition-colors">
                        <input
                            type="checkbox"
                            checked={showMapMode}
                            onChange={e => setShowMapMode(e.target.checked)}
                            className="rounded text-emerald-600 focus:ring-emerald-500"
                        />
                        <span className="text-sm font-bold text-gray-700">地図背景モード</span>
                    </label>

                    {yearRange.min !== yearRange.max && targetYear !== null && (
                        <div className="bg-white/90 border border-gray-300 rounded px-3 py-2 shadow-sm space-y-1">
                            <label className="text-xs font-bold text-gray-500 flex justify-between">
                                <span>時代: {targetYear}年</span>
                                <button onClick={() => setTargetYear(null)} className="text-[10px] text-red-500 hover:underline">解除</button>
                            </label>
                            <input
                                type="range"
                                min={yearRange.min}
                                max={yearRange.max}
                                value={targetYear}
                                onChange={e => setTargetYear(Number(e.target.value))}
                                className="w-full h-1 bg-gray-200 rounded-lg appearance-none cursor-pointer accent-indigo-600"
                            />
                            <div className="flex justify-between text-[10px] text-gray-400 font-mono">
                                <span>{yearRange.min}</span>
                                <span>{yearRange.max}</span>
                            </div>
                        </div>
                    )}
                </div>

                <div ref={containerRef} className="flex-1 bg-gray-50/50" style={{ minHeight: '500px' }}></div>
            </div>
        );
        };
        const computeRegionTags = (locations = [], rules = REGION_TAG_RULES_DEFAULT) => {
            const tags = new Set();
            if (!Array.isArray(locations) || locations.length === 0) return [];
            (rules || []).forEach(rule => {
                if (!rule || !rule.tag) return;
                if (rule.type === 'rect' && rule.bounds) {
                    const { latMin, latMax, lngMin, lngMax } = rule.bounds;
                    locations.forEach(loc => {
                        if (loc.lat == null || loc.lng == null) return;
                        if (loc.lat >= latMin && loc.lat <= latMax && loc.lng >= lngMin && loc.lng <= lngMax) {
                            tags.add(rule.tag);
                        }
                    });
                } else if (rule.type === 'circle' && rule.center && rule.radiusKm != null) {
                    locations.forEach(loc => {
                        if (loc.lat == null || loc.lng == null) return;
                        const d = haversineDistanceKm(rule.center, { lat: Number(loc.lat), lng: Number(loc.lng) });
                        if (d <= rule.radiusKm) tags.add(rule.tag);
                    });
                }
            });
            return Array.from(tags);
        };

        const getAdjacentArticles = (articles = [], currentId = null) => {
            if (!currentId) return { previous: null, next: null };
            const idx = articles.findIndex(a => a.id === currentId);
            return {
                previous: idx > 0 ? articles[idx - 1] : null,
                next: idx >= 0 && idx < articles.length - 1 ? articles[idx + 1] : null
            };
        };

        // Wiki Plugin Processor & Parser (PukiWiki Style)
        let parsePukiWikiSyntax; // Forward declaration

        const processPukiWikiPlugin = (name, args, content, isBlock) => {
            const argList = (args || '').split(',').map(s => s.trim());

            if (name.toLowerCase() === 'br') return '<br />';

            if (name === 'size') {
                return `<span style="font-size:${argList[0]}px">${content}</span>`;
            }
            if (name === 'color') {
                return `<span style="color:${argList[0]}; ${argList[1] ? 'background-color:' + argList[1] : ''}">${content}</span>`;
            }
            if (name === 'attachref' || name === 'ref') {
                const src = argList[0] || content;
                let w, h;
                if (argList[1]) {
                    const dim = argList[1].match(/(\d+)x(\d+)/);
                    if (dim) { w = dim[1]; h = dim[2]; }
                    else if (argList[1].endsWith('%')) { w = argList[1]; }
                }
                return `<img src="${src}" style="${w ? 'width:' + w + (w.includes('%') ? '' : 'px') + ';' : ''} ${h ? 'height:' + h + 'px;' : ''}" class="inline-block" />`;
            }
            if (name === 'cssbox') {
                return `<div style="${args}">${parsePukiWikiSyntax ? parsePukiWikiSyntax(content) : content}</div>`;
            }
            if (name === 'flex_container') {
                const [jus, ali, wrp] = argList;
                let style = 'display:flex; gap:10px;';
                if (jus) style += `justify-content:${jus};`;
                if (ali) style += `align-items:${ali};`;
                if (wrp) style += `flex-wrap:${wrp};`;
                return `<div style="${style}">${parsePukiWikiSyntax ? parsePukiWikiSyntax(content) : content}</div>`;
            }
            if (name === 'flex_box') {
                const w = argList[0];
                return `<div style="${w ? 'flex-basis:' + w + '; width:' + w + ';' : 'flex:1;'}">${parsePukiWikiSyntax ? parsePukiWikiSyntax(content) : content}</div>`;
            }
            if (name === 'skin') return content;
            if (name === 'marquee') return `<marquee>${args}</marquee>`;
            if (name === 'contents') return '';
            if (name === 'fold') return `<details><summary class="cursor-pointer font-bold text-indigo-600">${args || '詳細'}</summary><div class="pl-4 border-l-2 ml-1 mt-1">${parsePukiWikiSyntax ? parsePukiWikiSyntax(content) : content}</div></details>`;
            if (name === 'comment') return '<div class="text-xs text-gray-400 p-2 border bg-gray-50 my-2">[コメント欄]</div>';
            if (name === 'googlesheet') {
                const url = argList[0] || '';
                if (!url) return '<div class="p-4 bg-red-50 text-red-500 text-xs">GoogleスプレッドシートのURLを指定してください</div>';

                let embedUrl = url;
                if (url.includes('docs.google.com/spreadsheets')) {
                    // /edit, /view, /preview, /pub などが含まれる場合、
                    // 共有設定（リンクを知っている全員）だけで表示可能な /preview に変換します
                    if (!url.includes('/pubhtml')) {
                        embedUrl = url.replace(/\/(edit|view|preview|pub|htmlview)(.*)$/, '/preview$2');
                        if (!embedUrl.includes('/preview')) {
                            const mid = url.match(/\/d\/([^\/]+)/);
                            if (mid) embedUrl = `https://docs.google.com/spreadsheets/d/${mid[1]}/preview`;
                        }
                    } else if (!url.includes('widget=')) {
                        // すでに pubhtml の場合はパラメータを補完
                        embedUrl += (embedUrl.includes('?') ? '&' : '?') + 'widget=true&headers=false';
                    }
                }

                return `<div class="googlesheet-container my-4 border rounded overflow-hidden shadow-sm bg-white" style="height:500px">
                    <iframe src="${embedUrl}" class="w-full h-full border-0"></iframe>
                </div>`;
            }
            if (name === 'datatable') {
                const folder = argList.find(a => a.startsWith('folder='))?.split('=')[1] || '';
                const tag = argList.find(a => a.startsWith('tag='))?.split('=')[1] || '';
                const id = 'dt-' + Math.random().toString(36).substr(2, 9);

                // 動的にデータを読み込むためのプレースホルダ
                setTimeout(async () => {
                    const el = document.getElementById(id);
                    if (!el || !window.articles) return;

                    const filtered = window.articles.filter(a => {
                        if (folder && a.folder !== folder) return false;
                        if (tag && !(a.tags || []).includes(tag)) return false;
                        return true;
                    }).sort((a, b) => (a.year || 0) - (b.year || 0));

                    if (filtered.length === 0) {
                        el.innerHTML = '<div class="p-4 text-gray-400 text-xs italic">該当する記事が見つかりません。</div>';
                        return;
                    }

                    // マッピング設定を取得
                    const mappings = window.worldData?.sheetFieldMappings || [];

                    // 各記事のスプレッドシートデータを取得する関数
                    const fetchSheetData = async (article) => {
                        // 記事内容からスプレッドシートURLを抽出
                        const content = article.contentHtml || '';
                        const sheetMatch = content.match(/#googlesheet\(([^)]+)\)/);
                        if (!sheetMatch || mappings.length === 0) return {};

                        const sheetUrl = sheetMatch[1];
                        const sheetIdMatch = sheetUrl.match(/\/d\/([a-zA-Z0-9-_]+)/);
                        if (!sheetIdMatch) return {};

                        const sheetId = sheetIdMatch[1];
                        const proxyUrl = window.worldData?.spreadsheetProxyUrl;
                        if (!proxyUrl) return {};

                        // GAS経由でセル値を取得 (JSONP)
                        return new Promise((resolve) => {
                            const callbackName = 'sheet_cb_' + Math.random().toString(36).substr(2, 9);
                            const timeout = setTimeout(() => {
                                delete window[callbackName];
                                resolve({});
                            }, 10000);

                            window[callbackName] = (res) => {
                                clearTimeout(timeout);
                                delete window[callbackName];
                                const s = document.getElementById(callbackName);
                                if (s) s.remove();

                                if (res.status === 'success' && res.values) {
                                    // マッピングに従ってフィールド値を作成
                                    const result = {};
                                    mappings.forEach(m => {
                                        if (res.values[m.cell] !== undefined) {
                                            result[m.field] = res.values[m.cell];
                                        }
                                    });
                                    resolve(result);
                                } else {
                                    resolve({});
                                }
                            };

                            const cells = mappings.map(m => m.cell).join(',');
                            const params = new URLSearchParams();
                            params.set('callback', callbackName);
                            params.set('action', 'getCellValues');
                            params.set('sheetId', sheetId);
                            params.set('cells', cells);

                            const script = document.createElement('script');
                            script.id = callbackName;
                            script.src = proxyUrl + (proxyUrl.includes('?') ? '&' : '?') + params.toString();
                            document.body.appendChild(script);
                        });
                    };

                    // ローディング表示
                    el.innerHTML = '<div class="p-4 text-gray-400 text-xs italic text-center">データ読み込み中...</div>';

                    // 全記事のシートデータを取得（並列実行）
                    const sheetDataPromises = filtered.map(a => fetchSheetData(a));
                    const sheetDataResults = await Promise.all(sheetDataPromises);

                    // 記事データにシートデータをマージ
                    const enrichedArticles = filtered.map((a, i) => ({
                        ...a,
                        sheetData: sheetDataResults[i]
                    }));

                    const wikiLinkRenderer = (instance, td, col, row, index, val) => {
                        td.innerHTML = parsePukiWikiSyntax ? parsePukiWikiSyntax(val) : val;
                    };

                    // 基本列 + マッピング列を構築
                    const baseColumns = [
                        { type: 'text', title: 'タイトル', width: 200, readOnly: true, renderer: wikiLinkRenderer },
                        { type: 'numeric', title: '年代', width: 80 },
                        { type: 'numeric', title: '重要度', width: 60 },
                    ];

                    // マッピングで定義されたフィールドを列として追加
                    const mappingColumns = mappings.map(m => ({
                        type: 'text',
                        title: m.field,
                        width: 100,
                        readOnly: true
                    }));

                    const allColumns = [...baseColumns, ...mappingColumns];

                    // データ行を構築
                    const data = enrichedArticles.map(a => {
                        const baseRow = [`[[${a.title}|${a.id}]]`, a.year || 0, a.importance || 3];
                        const mappingValues = mappings.map(m => a.sheetData[m.field] ?? '');
                        return [...baseRow, ...mappingValues];
                    });

                    el.innerHTML = ''; // ローディング表示をクリア

                    jspreadsheet(el, {
                        data: data,
                        columns: allColumns,
                        onchange: async (instance, cell, col, row, val) => {
                            // 年代または重要度が変更された場合、Firestoreに保存
                            const articleId = instance.jexcel.getValueFromCoords(0, row).match(/\|([^\]]+)\]\]$/)?.[1];
                            const field = col === 1 ? 'year' : col === 2 ? 'importance' : null;
                            if (field && articleId) {
                                try {
                                    const { doc, updateDoc } = window.firebaseModules;
                                    const db = window.db;
                                    const ctx = window.appContextId;
                                    const w = window.worldId;
                                    await updateDoc(doc(db, 'artifacts', ctx, 'public', 'data', 'worlds', w, 'articles', articleId), {
                                        [field]: Number(val)
                                    });
                                } catch (e) { console.error(e); }
                            }
                        },
                        search: true,
                        pagination: 10,
                    });
                }, 100);

                return `<div class="wiki-datatable my-6 p-2 bg-slate-50 border rounded-lg shadow-inner overflow-hidden">
                    <div class="px-2 py-1 text-[10px] font-bold text-slate-400 uppercase tracking-wider flex items-center gap-1">
                        <i data-lucide="database" class="w-3 h-3"></i> データベース自動集計: ${folder || tag || '全て'}
                    </div>
                    <div id="${id}" class="mt-2 text-sm"></div>
                </div>`;
            }
            return null;
        };

        parsePukiWikiSyntax = (text) => {
            if (!text) return '';

            // 0. Pre-process HTML
            const decodeHtml = (html) => {
                const txt = document.createElement("textarea");
                txt.innerHTML = html;
                return txt.value;
            };

            let cleanText = text
                .replace(/\r/g, '') // Normalize newlines
                .replace(/<br\s*\/?>/gi, '&br;')
                .replace(/<\/p>/gi, '\n')
                .replace(/<\/p>/gi, '\n')
                .replace(/<div>/gi, '\n') // div start -> newline
                .replace(/<\/div>/gi, '\n')
                .replace(/<\/tr>/gi, '\n')
                .replace(/<\/li>/gi, '\n');

            cleanText = decodeHtml(cleanText);

            let res = cleanText;

            // 1. Recursive Layout/Block Plugin Parser
            for (let i = 0; i < 20; i++) {
                const regex = /(?:#|&)([a-zA-Z0-9_]+)(?:\(([^)]*)\))?(\{+)([\s\S]*?)(\}+)(;?)/g;
                let matched = false;
                res = res.replace(regex, (m, name, args, open, content, close, semi) => {
                    if (open.length !== close.length) return m;
                    matched = true;
                    // The recursive call happens inside processPukiWikiPlugin now
                    const p = processPukiWikiPlugin(name, args, content, open.startsWith('#'));
                    return p !== null ? p : m;
                });
                if (!matched) break;
            }

            const splitTableRow = (rowStr) => {
                const cells = [];
                let current = '';
                let depthBracket = 0;
                let depthBrace = 0;
                for (let i = 0; i < rowStr.length; i++) {
                    const char = rowStr[i];
                    if (char === '[' && rowStr[i + 1] === '[') { depthBracket++; i++; current += '[['; continue; }
                    if (char === ']' && rowStr[i + 1] === ']') { depthBracket--; i++; current += ']]'; continue; }
                    if (char === '{') depthBrace++;
                    if (char === '}') depthBrace--;
                    if (char === '|' && depthBracket === 0 && depthBrace === 0) {
                        cells.push(current);
                        current = '';
                    } else {
                        current += char;
                    }
                }
                cells.push(current);
                return cells;
            };

            const processInline = (str) => {
                let s = str;
                for (let i = 0; i < 10; i++) {
                    let replaced = false;
                    s = s.replace(/(&|#)([a-zA-Z0-9_]+)(?:\(([^)]*)\))?(?:\{([^}]*)\})?(;?)/g, (m, type, name, args, blockContent, semi) => {
                        replaced = true;
                        const p = processPukiWikiPlugin(name, args, blockContent || '', type === '#');
                        return p !== null ? p : m;
                    });
                    if (!replaced) break;
                }
                s = s.replace(/\{\{googlesheet:([^}]+)\}\}/g, (match, url) => {
                    return processPukiWikiPlugin('googlesheet', url, '', false);
                });
                s = s.replace(/'''([^']+)'''/g, '<i>$1</i>');
                s = s.replace(/''([^']+)''/g, '<b>$1</b>');
                s = s.replace(/\[\[([^\]|]+)\|([^\]]+)\]\]/g, '<span class="wiki-link" data-article-id="$2">🔗 $1</span>');
                s = s.replace(/\[\[([^\]]+)\]\]/g, '<span class="wiki-link" data-wiki-title="$1">🔗 $1</span>');
                return s;
            };

            const lines = res.split('\n');
            const outLines = [];
            let inTable = false;
            let tableRows = [];

            const flushTable = () => {
                if (!inTable) return;
                let html = '<div class="overflow-x-auto my-2"><table class="wiki-table min-w-full border-collapse border border-gray-400 bg-white text-sm">';
                tableRows.forEach(row => {
                    html += '<tr>';
                    const cells = splitTableRow(row.trim());
                    if (cells.length > 0 && cells[0].trim() === '') cells.shift();
                    if (cells.length > 0 && cells[cells.length - 1].trim() === '') cells.pop();
                    if (cells.length === 0) return;
                    cells.forEach(cell => {
                        let c = cell;
                        let tag = 'td';
                        let style = 'border: 1px solid #cbd5e1; padding: 6px;';
                        while (true) {
                            c = c.trim();
                            if (c.startsWith('~')) { tag = 'th'; c = c.substring(1); style += 'background-color:#f1f5f9; font-weight:bold;'; continue; }
                            if (c.startsWith('BGCOLOR')) {
                                const m = c.match(/^BGCOLOR\(([^)]+)\):/);
                                if (m) { style += `background-color:${m[1]};`; c = c.substring(m[0].length); continue; }
                            }
                            if (c.startsWith('CENTER:')) { style += 'text-align:center;'; c = c.substring(7); continue; }
                            if (c.startsWith('LEFT:')) { style += 'text-align:left;'; c = c.substring(5); continue; }
                            if (c.startsWith('RIGHT:')) { style += 'text-align:right;'; c = c.substring(6); continue; }
                            if (c === '>') { c = '&nbsp;'; }
                            break;
                        }
                        html += `<${tag} style="${style}">${processInline(c)}</${tag}>`;
                    });
                    html += '</tr>';
                });
                html += '</table></div>';
                outLines.push(html);
                tableRows = [];
                inTable = false;
            };

            lines.forEach(line => {
                let l = line.trim();

                // Table
                if (l.startsWith('|')) {
                    inTable = true;
                    tableRows.push(l);
                    return;
                }
                flushTable();

                // Headers
                const parseHeader = (line, level) => {
                    let text = line.substring(level).trim();
                    let id = Math.random().toString(36).substr(2, 9);
                    const anchorMatch = text.match(/\[#([a-zA-Z0-9_-]+)\]$/);
                    if (anchorMatch) {
                        id = anchorMatch[1];
                        text = text.substring(0, text.length - anchorMatch[0].length).trim();
                    }
                    return { text, id };
                };

                if (l.startsWith('***')) { const h = parseHeader(l, 3); outLines.push(`<h4 id="${h.id}" class="text-lg font-bold mt-2 border-b border-gray-200 pb-1 flex items-center gap-2"><span class="w-1 h-4 bg-indigo-300 inline-block"></span>${processInline(h.text)}</h4>`); return; }
                if (l.startsWith('**')) { const h = parseHeader(l, 2); outLines.push(`<h3 id="${h.id}" class="text-xl font-bold mt-3 mb-2 border-b-2 border-indigo-100 flex items-center gap-2"><span class="w-2 h-2 rounded-full bg-indigo-500 inline-block"></span>${processInline(h.text)}</h3>`); return; }
                if (l.startsWith('*')) { const h = parseHeader(l, 1); outLines.push(`<h2 id="${h.id}" class="text-2xl font-bold mt-6 mb-3 border-b-2 border-indigo-600 pb-1 serif text-indigo-900">${processInline(h.text)}</h2>`); return; }

                // HR
                if (l.startsWith('----')) { outLines.push('<hr class="my-4 border-gray-300 border-dashed">'); return; }

                // Alignments
                if (l.startsWith('CENTER:')) { outLines.push(`<div class="text-center">${processInline(l.substring(7))}</div>`); return; }
                if (l.startsWith('LEFT:')) { outLines.push(`<div class="text-left">${processInline(l.substring(5))}</div>`); return; }
                if (l.startsWith('RIGHT:')) { outLines.push(`<div class="text-right">${processInline(l.substring(6))}</div>`); return; }

                if (l === '') { outLines.push('<br class="my-2" />'); return; }
                outLines.push(processInline(l) + '<br>');
            });
            flushTable();
            return outLines.join('\n');
        };

        // Wiki記法をHTMLリンクに変換する関数 (Wrapper)
        const transformContent = (html) => {
            if (!html) return '';

            // Explicit HTML Mode check
            if (html.trim().startsWith('<!-- html-mode -->') || html.trim().startsWith('<!DOCTYPE html>')) {
                // Just do simple link replacement
                let out = html.replace(/\[\[([^\]|]+)\|([^\]]+)\]\]/g, (match, title, id) => {
                    return `<span class="wiki-link" data-article-id="${id}">🔗 ${title}</span>`;
                });
                out = out.replace(/\[\[([^\]|]+)\]\]/g, (match, title) => {
                    const t = title.trim();
                    return `<span class="wiki-link" data-wiki-title="${t}">🔗 ${t}</span>`;
                });
                return out;
            }

            // Detect Wiki Syntax (Heuristic)
            // If it contains plugin syntax #plugin or &plugin or table | |
            // Updated to catch simple plugins ending with ; like &br;
            if (html.match(/(?:#|&)[a-zA-Z0-9_]+(?:[\(\{;])/) || html.match(/^\|.+\|$/m) || html.includes('{{googlesheet:')) {
                // Ensure the function is defined before calling
                if (parsePukiWikiSyntax) return parsePukiWikiSyntax(html);
            }

            // Fallback for Standard HTML with simple Wiki Links
            let out = html.replace(/\[\[([^\]|]+)\|([^\]]+)\]\]/g, (match, title, id) => {
                const exists = window.articles && window.articles.some(a => a.id === id);
                return `<span class="wiki-link ${exists ? '' : 'text-red-500'}" data-article-id="${id}" title="${exists ? '' : 'リンク切れ'}">🔗 ${title}</span>`;
            });
            out = out.replace(/\[\[([^\]|]+)\]\]/g, (match, title) => {
                const t = title.trim();
                const exists = window.articles && window.articles.some(a => (a.title || '').trim() === t);
                return `<span class="wiki-link ${exists ? '' : 'text-red-500'}" data-wiki-title="${t}" title="${exists ? '' : 'リンク切れ'}">🔗 ${t}</span>`;
            });
            return out;
        };

        const extractLinkedKeywords = (html = '') => {
            const keywords = new Set();
            let match;
            // 正規表現リテラルを使って修正
            const bracketRegex = /\[\[([^\]]+)\]\]/g;
            const dataRefRegex = /data-(?:link|ref)=\"([^\"]+)\"/g;
            const wikiLinkRegex = /class=\"wiki-link\"[^>]*>(.*?)<\//g;

            while ((match = bracketRegex.exec(html)) !== null) if (match[1]) keywords.add(match[1].trim());
            while ((match = dataRefRegex.exec(html)) !== null) if (match[1]) keywords.add(match[1].trim());
            while ((match = wikiLinkRegex.exec(html)) !== null) {
                const textValue = stripHtml(match[1] || '').trim();
                if (textValue) keywords.add(textValue);
            }
            return Array.from(keywords).filter(Boolean);
        };

        // ハイライトユーティリティ: HTML文字列中のテキストノードに対してキーワードをマークアップする
        const highlightHtml = (html = '', keyword = '') => {
            if (!keyword) return html || '';
            try {
                const parser = new DOMParser();
                const doc = parser.parseFromString(html || '', 'text/html');
                const esc = (s) => s.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
                const re = new RegExp(esc(keyword), 'ig');
                const walker = doc.createTreeWalker(doc.body, NodeFilter.SHOW_TEXT, null, false);
                const nodes = [];
                while (walker.nextNode()) nodes.push(walker.currentNode);
                nodes.forEach(t => {
                    const parent = t.parentNode;
                    if (!parent) return;
                    const text = t.nodeValue;
                    if (!text) return;
                    if (re.test(text)) {
                        const frag = document.createDocumentFragment();
                        let lastIndex = 0;
                        text.replace(re, (match, offset) => {
                            const idx = arguments[arguments.length - 2];
                            if (idx > lastIndex) frag.appendChild(document.createTextNode(text.substring(lastIndex, idx)));
                            const mark = doc.createElement('mark');
                            mark.textContent = match;
                            frag.appendChild(mark);
                            lastIndex = idx + match.length;
                            return match;
                        });
                        if (lastIndex < text.length) frag.appendChild(document.createTextNode(text.substring(lastIndex)));
                        parent.replaceChild(frag, t);
                    }
                });
                return doc.body.innerHTML;
            } catch (e) { return html; }
        };

        const Icon = ({ name, size = 20, className = "" }) => {
            const ref = React.useRef(null);
            React.useEffect(() => {
                if (window.lucide && ref.current) {
                    const i = document.createElement('i');
                    i.setAttribute('data-lucide', name);
                    i.setAttribute('width', size);
                    i.setAttribute('height', size);
                    if (className) i.className = className;
                    ref.current.innerHTML = '';
                    ref.current.appendChild(i);
                    window.lucide.createIcons({ root: ref.current });
                }
            }, [name, size, className]);
            return <span ref={ref} style={{ display: 'inline-flex', lineHeight: 0, verticalAlign: 'middle' }}></span>;
        };

        // ユーティリティ: テキストコピー
        const copyText = (text) => {
            if (navigator.clipboard && navigator.clipboard.writeText) {
                navigator.clipboard.writeText(text).then(() => alert("コピーしました: " + text)).catch(e => alert("コピー失敗"));
            } else {
                const textArea = document.createElement("textarea");
                textArea.value = text;
                textArea.style.position = "fixed";
                textArea.style.left = "-9999px";
                document.body.appendChild(textArea);
                textArea.focus();
                textArea.select();
                try { document.execCommand('copy'); alert("コピーしました: " + text); } catch (err) { alert("コピー失敗"); }
                document.body.removeChild(textArea);
            }
        };

        // --- Config Editor ---
        const ConfigEditor = ({ currentConfig, currentAppId, onSave, onCancel }) => {
            const [text, setText] = React.useState(`const firebaseConfig = ${JSON.stringify(currentConfig, null, 2)};`);
            const [appIdText, setAppIdText] = React.useState(currentAppId || DEFAULT_APP_CONTEXT_ID);
            const [parseError, setParseError] = React.useState(null);
            const handleSave = () => {
                try {
                    let cleanText = text.replace(/\/\/.*$/gm, '').replace(/\/\*[\s\S]*?\*\//g, '').replace(/^(const|var|let)\s+\w+\s*=\s*/, '').replace(/;+\s*$/, '').trim();
                    let config;
                    try { config = JSON.parse(cleanText); } catch (e) { config = new Function(`return ${cleanText}`)(); }
                    if (!config.apiKey) throw new Error("apiKey が空です。");
                    onSave(config, appIdText);
                } catch (e) { setParseError("設定エラー: " + e.message); }
            };
            return (
                <div className="fixed inset-0 bg-black/50 flex items-center justify-center z-[9999] p-4">
                    <div className="bg-white p-6 rounded-lg shadow-xl w-full max-w-2xl flex flex-col max-h-[90vh] overflow-y-auto">
                        <h3 className="text-lg font-bold mb-4 flex items-center gap-2 text-indigo-900 border-b pb-2"><Icon name="settings" /> システム設定</h3>
                        <div className="mb-6"><label className="block text-sm font-bold text-gray-700 mb-1">データID (App ID)</label><input className="w-full border p-2 rounded text-sm font-mono" value={appIdText} onChange={e => setAppIdText(e.target.value)} /></div>
                        <div className="mb-4"><label className="block text-sm font-bold text-gray-700 mb-1">Firebase接続設定</label><textarea className="w-full border p-4 font-mono text-xs h-32" value={text} onChange={e => setText(e.target.value)} /></div>
                        {parseError && <div className="text-red-600 text-xs mb-4 p-2 bg-red-50">{parseError}</div>}
                        <div className="flex justify-end gap-2"><button onClick={onCancel} className="px-4 py-2 bg-gray-200 rounded">キャンセル</button><button onClick={handleSave} className="px-4 py-2 bg-indigo-600 text-white rounded">保存</button></div>
                    </div>
                </div>
            );
        };

        // --- Member Manager ---
        const MemberManager = ({ db, worldId, appContextId, onClose }) => {
            const [members, setMembers] = React.useState([]);
            const [inviteId, setInviteId] = React.useState('');
            const [loading, setLoading] = React.useState(false);

            React.useEffect(() => {
                const { collection, onSnapshot } = window.firebaseModules;
                return onSnapshot(collection(db, 'artifacts', appContextId, 'public', 'data', 'worlds', worldId, 'members'), s => {
                    setMembers(s.docs.map(d => ({ id: d.id, ...d.data() })));
                });
            }, [db, worldId, appContextId]);

            const addMember = async () => {
                if (!inviteId.trim()) return;
                const name = prompt("メンバーの表示名を入力してください (任意)", "");
                setLoading(true);
                try {
                    const { doc, setDoc, serverTimestamp } = window.firebaseModules;
                    await setDoc(doc(db, 'artifacts', appContextId, 'public', 'data', 'worlds', worldId, 'members', inviteId.trim()), {
                        role: 'editor', username: name || '', addedAt: serverTimestamp()
                    });
                    setInviteId('');
                    alert('メンバーを追加しました');
                } catch (e) { alert('追加エラー: ' + e.message); }
                setLoading(false);
            };

            const updateMemberName = async (member) => {
                const newName = prompt("新しい表示名を入力してください", member.username || "");
                if (newName === null) return;
                try {
                    const { doc, updateDoc } = window.firebaseModules;
                    await updateDoc(doc(db, 'artifacts', appContextId, 'public', 'data', 'worlds', worldId, 'members', member.id), {
                        username: newName
                    });
                } catch (e) { alert('更新エラー: ' + e.message); }
            };

            const removeMember = async (uid) => {
                if (!confirm('このメンバーを削除しますか？')) return;
                try {
                    const { doc, deleteDoc } = window.firebaseModules;
                    await deleteDoc(doc(db, 'artifacts', appContextId, 'public', 'data', 'worlds', worldId, 'members', uid));
                } catch (e) { alert('削除エラー: ' + e.message); }
            };

            const toggleApprovalParams = async (member) => {
                try {
                    const { doc, updateDoc } = window.firebaseModules;
                    await updateDoc(doc(db, 'artifacts', appContextId, 'public', 'data', 'worlds', worldId, 'members', member.id), {
                        canApprove: !member.canApprove
                    });
                } catch (e) { alert('更新エラー: ' + e.message); }
            };

            return (
                <div className="fixed inset-0 bg-black/50 flex items-center justify-center z-[9999] p-4">
                    <div className="bg-white p-6 rounded-lg shadow-xl w-full max-w-md">
                        <h3 className="text-lg font-bold mb-4 text-indigo-900 border-b pb-2 flex justify-between items-center">
                            <span>メンバー管理</span>
                            <button onClick={onClose}><Icon name="x" size={20} /></button>
                        </h3>
                        <div className="flex gap-2 mb-4">
                            <input className="border p-2 rounded flex-1 text-sm" placeholder="ユーザーID (UID) を入力" value={inviteId} onChange={e => setInviteId(e.target.value)} />
                            <button onClick={addMember} disabled={loading} className="bg-indigo-600 text-white px-4 py-2 rounded text-sm font-bold">追加</button>
                        </div>
                        <div className="space-y-2 max-h-60 overflow-y-auto">
                            {members.map(m => (
                                <div key={m.id} className="flex justify-between items-center border-b pb-2">
                                    <div className="flex-1">
                                        <div className="flex items-center gap-2">
                                            <span className="text-sm font-bold text-gray-800">{m.username || 'No Name'}</span>
                                            <button onClick={() => updateMemberName(m)} className="text-gray-400 hover:text-indigo-600"><Icon name="edit-2" size={12} /></button>
                                            <span className="text-[10px] text-gray-400 font-mono">({m.id})</span>
                                        </div>
                                        <div className="flex items-center gap-2 mt-1">
                                            <span className={`text-[10px] px-2 py-0.5 rounded ${m.role === 'owner' ? 'bg-red-100 text-red-800' : 'bg-blue-100 text-blue-800'}`}>{m.role}</span>
                                            {m.role !== 'owner' && (
                                                <label className="flex items-center gap-1 text-[10px] cursor-pointer bg-gray-100 px-2 py-0.5 rounded hover:bg-gray-200">
                                                    <input type="checkbox" checked={!!m.canApprove} onChange={() => toggleApprovalParams(m)} />
                                                    承認権限
                                                </label>
                                            )}
                                        </div>
                                    </div>
                                    {m.role !== 'owner' && <button onClick={() => removeMember(m.id)} className="text-red-500 text-xs border px-2 py-1 rounded hover:bg-red-50 ml-2">削除</button>}
                                </div>
                            ))}
                        </div>
                    </div>
                </div>
            );
        };

        // --- Region Rule Editor (Map-based Interactive) ---
        const RegionRuleEditor = ({ rules = [], onSave, onClose, worldData }) => {
            const [items, setItems] = React.useState(rules);
            const [mode, setMode] = React.useState('view'); // view, drawing_rect, drawing_circle
            const [tempPoints, setTempPoints] = React.useState([]);
            const mapRef = React.useRef(null);
            const leafletMap = React.useRef(null);
            const layerGroupRef = React.useRef(null);

            // Init Map
            React.useEffect(() => {
                if (!mapRef.current || leafletMap.current) return;
                const map = L.map(mapRef.current, { crs: L.CRS.Simple, minZoom: -3, maxZoom: 4, zoomControl: true });
                leafletMap.current = map;
                layerGroupRef.current = L.layerGroup().addTo(map);

                // Load Background Image
                const layers = worldData?.mapLayers || (worldData?.mapImageUrl ? [{ id: 'default', url: worldData.mapImageUrl }] : []);
                if (layers.length > 0) {
                    const img = new Image();
                    img.src = layers[0].url;
                    img.onload = () => {
                        const bounds = [[-img.height / 2, -img.width / 2], [img.height / 2, img.width / 2]];
                        L.imageOverlay(layers[0].url, bounds).addTo(map);
                        map.fitBounds(bounds);
                    };
                } else {
                    const bounds = [[-500, -500], [500, 500]];
                    L.rectangle(bounds, { color: "#9ca3af", weight: 1, fill: false }).addTo(map);
                    map.fitBounds(bounds);
                }

                // Click Handler
                map.on('click', (e) => {
                    handleMapClick(e.latlng);
                });
            }, []);

            // Ref for accessing current mode in event handler (if needed) but state works if defined inside component (closure)
            // Render items on map
            React.useEffect(() => {
                if (!leafletMap.current || !layerGroupRef.current) return;
                layerGroupRef.current.clearLayers();

                items.forEach((item, idx) => {
                    const color = ['#6366f1', '#10b981', '#f59e0b', '#ef4444'][idx % 4];
                    let layer = null;
                    if (item.type === 'rect' && item.bounds) {
                        const b = [[item.bounds.latMin, item.bounds.lngMin], [item.bounds.latMax, item.bounds.lngMax]];
                        layer = L.rectangle(b, { color, weight: 2, fillOpacity: 0.2 });
                    } else if (item.type === 'circle' && item.center) {
                        layer = L.circle([item.center.lat, item.center.lng], { radius: (item.radiusKm || 1) * 1000, color, weight: 2, fillOpacity: 0.2 }); // Leaflet circle radius is meters roughly in CRS.Simple? No, it depends.
                        // In CRS.Simple, radius is map units. If "radiusKm" is treated as map units:
                        layer = L.circle([item.center.lat, item.center.lng], { radius: item.radiusKm, color, weight: 2, fillOpacity: 0.2 });
                    }

                    if (layer) {
                        layer.bindTooltip(`<b>${item.tag}</b>`, { permanent: true, direction: 'center', className: 'bg-transparent border-0 font-bold shadow-none' });
                        layer.addTo(layerGroupRef.current);
                    }
                });
            }, [items]);

            const handleMapClick = (latlng) => {
                setMode(prevMode => {
                    if (prevMode === 'drawing_rect') {
                        setTempPoints(prev => {
                            const newPoints = [...prev, latlng];
                            if (newPoints.length === 2) {
                                // Finish Rect
                                const [p1, p2] = newPoints;
                                const latMin = Math.min(p1.lat, p2.lat);
                                const latMax = Math.max(p1.lat, p2.lat);
                                const lngMin = Math.min(p1.lng, p2.lng);
                                const lngMax = Math.max(p1.lng, p2.lng);
                                const tag = prompt("タグ名を入力してください:");
                                if (tag) {
                                    setItems(current => [...current, { tag, type: 'rect', bounds: { latMin, latMax, lngMin, lngMax } }]);
                                }
                                setTempPoints([]);
                                return []; // Reset in next render by mode change
                            }
                            return newPoints;
                        });
                        if (tempPoints.length === 1) return 'view'; // Will be handled by effect or logic above? No, setState is async.
                        // Logic simplified:
                        // If we just added the 2nd point, we are done.
                        // But we need to check the updated state.
                        // Better to handle logic inside the setTempPoints callback or separate ref.
                        return prevMode; // Stay in mode until 2nd point logic executes
                    } else if (prevMode === 'drawing_circle') {
                        setTempPoints(prev => {
                            if (prev.length === 0) {
                                return [latlng]; // Set Center
                            } else {
                                // Set Radius
                                const center = prev[0];
                                const radius = Math.sqrt(Math.pow(latlng.lat - center.lat, 2) + Math.pow(latlng.lng - center.lng, 2));
                                const tag = prompt("タグ名を入力してください:");
                                if (tag) {
                                    setItems(current => [...current, { tag, type: 'circle', center: { lat: center.lat, lng: center.lng }, radiusKm: radius }]);
                                }
                                return [];
                            }
                        });
                    }
                    return prevMode;
                });
            };

            // Side effect to exit mode after shape completion
            React.useEffect(() => {
                if (mode === 'drawing_rect' && tempPoints.length === 2) setMode('view');
                if (mode === 'drawing_circle' && tempPoints.length === 0 && mode !== 'view') setMode('view'); // slightly buggy logic, fix below
            }, [tempPoints]);

            // Fix circle logic: clearing tempPoints implies done
            const handleModeChange = (m) => {
                setMode(m);
                setTempPoints([]);
            };

            const removeItem = (idx) => setItems(items.filter((_, i) => i !== idx));

            return (
                <div className="fixed inset-0 bg-black/50 flex items-center justify-center z-[9999] p-4">
                    <div className="bg-white w-full h-full max-w-6xl max-h-[90vh] rounded-lg shadow-2xl flex flex-col overflow-hidden">
                        <div className="p-4 border-b flex justify-between items-center bg-gray-50">
                            <div className="flex items-center gap-4">
                                <h3 className="text-lg font-bold flex items-center gap-2"><Icon name="map" /> 地域タグ設定</h3>
                                <div className="flex bg-white border rounded p-1 gap-1">
                                    <button onClick={() => handleModeChange('view')} className={`px-3 py-1 rounded text-sm ${mode === 'view' ? 'bg-indigo-100 text-indigo-700 font-bold' : 'hover:bg-gray-100'}`}><Icon name="mouse-pointer" size={14} /> 操作</button>
                                    <button onClick={() => handleModeChange('drawing_rect')} className={`px-3 py-1 rounded text-sm ${mode === 'drawing_rect' ? 'bg-indigo-600 text-white font-bold' : 'hover:bg-gray-100'}`}><Icon name="square" size={14} /> 矩形追加</button>
                                    <button onClick={() => handleModeChange('drawing_circle')} className={`px-3 py-1 rounded text-sm ${mode === 'drawing_circle' ? 'bg-indigo-600 text-white font-bold' : 'hover:bg-gray-100'}`}><Icon name="circle" size={14} /> 円追加</button>
                                </div>
                                <div className="text-sm text-gray-500">
                                    {mode === 'drawing_rect' && (tempPoints.length === 0 ? '始点をクリック' : '終点をクリック')}
                                    {mode === 'drawing_circle' && (tempPoints.length === 0 ? '中心をクリック' : '半径位置をクリック')}
                                </div>
                            </div>
                            <div className="flex gap-2">
                                <button onClick={onClose} className="px-4 py-2 border rounded hover:bg-gray-50">キャンセル</button>
                                <button onClick={() => onSave(items)} className="px-6 py-2 bg-indigo-600 text-white font-bold rounded hover:bg-indigo-700">保存</button>
                            </div>
                        </div>
                        <div className="flex-1 flex overflow-hidden">
                            <div className="w-64 border-r bg-gray-50 overflow-y-auto p-2 space-y-2">
                                <div className="text-xs font-bold text-gray-500 mb-2">登録済みルール ({items.length})</div>
                                {items.map((item, idx) => (
                                    <div key={idx} className="bg-white p-2 rounded border shadow-sm text-sm group">
                                        <div className="flex justify-between items-center font-bold text-gray-800">
                                            <span>{item.tag}</span>
                                            <button onClick={() => removeItem(idx)} className="text-gray-400 hover:text-red-500"><Icon name="trash-2" size={14} /></button>
                                        </div>
                                        <div className="text-xs text-gray-500 mt-1">
                                            {item.type === 'rect' ? '矩形エリア' : '円形エリア'}
                                        </div>
                                    </div>
                                ))}
                                {items.length === 0 && <div className="text-xs text-gray-400 text-center py-4">ルールはまだありません</div>}
                            </div>
                            <div className="flex-1 relative">
                                <div className="absolute inset-0 bg-slate-200" ref={mapRef}></div>
                            </div>
                        </div>
                    </div>
                </div>
            );
        };

        // --- Rich Editor (Quill.js) ---
        // CSV パーサ（簡易実装、引用符と改行に対応）
        const parseCSV = (text, delimiter = ',') => {
            const rows = [];
            let cur = '';
            let row = [];
            let inQuotes = false;
            for (let i = 0; i < text.length; i++) {
                const ch = text[i];
                if (ch === '"') {
                    if (inQuotes && text[i + 1] === '"') { cur += '"'; i++; }
                    else { inQuotes = !inQuotes; }
                } else if (ch === delimiter && !inQuotes) {
                    row.push(cur); cur = '';
                } else if ((ch === '\n' || ch === '\r') && !inQuotes) {
                    if (ch === '\r' && text[i + 1] === '\n') { i++; }
                    row.push(cur); rows.push(row); row = []; cur = '';
                } else { cur += ch; }
            }
            if (cur !== '' || row.length > 0) { row.push(cur); rows.push(row); }
            return rows.map(r => r.map(c => c.trim()));
        };

        const RichTextEditor = React.forwardRef(({ value, onChange }, ref) => {
            const containerRef = React.useRef(null);
            const quillRef = React.useRef(null);

            React.useImperativeHandle(ref, () => ({
                insertLink: (article) => {
                    if (quillRef.current) {
                        const cursor = quillRef.current.getSelection(true);
                        // 独自記法 [[Title|ID]] を挿入
                        quillRef.current.insertText(cursor ? cursor.index : 0, `[[${article.title}|${article.id}]]`);
                    }
                }
                , insertTable: (rows = 3, cols = 2) => {
                    if (quillRef.current) {
                        const cursor = quillRef.current.getSelection(true);
                        // Build a simple CSV representation instead of inserting raw <table> HTML
                        const rowsArr = [];
                        for (let r = 0; r < rows; r++) {
                            const row = [];
                            for (let c = 0; c < cols; c++) row.push(r === 0 ? ('ヘッダ' + (c + 1)) : '');
                            rowsArr.push(row);
                        }
                        const csvText = rowsArr.map(r => r.map(cell => String(cell).includes(',') ? `"${String(cell).replace(/"/g, '""')}"` : cell).join(',')).join('\n');
                        const encoded = encodeURIComponent(csvText);
                        const placeholder = `<div class="csv-block" data-csv="${encoded}"><div class="csv-placeholder">表 (${rows}行×${cols}列) - クリックで編集</div></div><p></p>`;
                        try { quillRef.current.clipboard.dangerouslyPasteHTML(cursor ? cursor.index : 0, placeholder); } catch (e) {
                            try { const editorRoot = containerRef.current.querySelector('.ql-editor'); if (editorRoot) editorRoot.insertAdjacentHTML('beforeend', placeholder); }
                            catch (err) { console.error(err); }
                        }
                    }
                }
                , insertCSV: (csvText) => {
                    if (!csvText) return;
                    const rows = parseCSV(csvText, ',');
                    if (!rows || rows.length === 0) return;
                    const useHeader = window.confirm('CSVの1行目をヘッダとして使いますか？ (はい=ヘッダ)');
                    // wrap CSV data into a csv-block div so the raw CSV is preserved in data-csv
                    const encoded = encodeURIComponent(csvText);
                    let tableHtml = '<table class="inserted-table" border="1" style="border-collapse:collapse;width:100%"><tbody>';
                    rows.forEach((r, ri) => {
                        tableHtml += '<tr>';
                        r.forEach((cell, ci) => {
                            const tag = (useHeader && ri === 0) ? 'th' : 'td';
                            tableHtml += `<${tag} style="padding:6px">${cell || '&nbsp;'}</${tag}>`;
                        });
                        tableHtml += '</tr>';
                    });
                    tableHtml += '</tbody></table>';
                    const wrapper = `<div class="csv-block" data-csv="${encoded}">${tableHtml}</div><p></p>`;
                    try {
                        // Try to paste at cursor (may be sanitized by Quill in some configs)
                        const cursor = quillRef.current.getSelection(true);
                        quillRef.current.clipboard.dangerouslyPasteHTML(cursor ? cursor.index : 0, wrapper);
                        // verify insertion: if no csv-block present after paste, fallback to append
                        const editorRoot = containerRef.current.querySelector('.ql-editor');
                        if (editorRoot && !editorRoot.querySelector('.csv-block')) {
                            // fallback: append to end
                            editorRoot.insertAdjacentHTML('beforeend', wrapper);
                        }
                    } catch (e) {
                        try {
                            const editorRoot = containerRef.current.querySelector('.ql-editor');
                            if (editorRoot) editorRoot.insertAdjacentHTML('beforeend', wrapper);
                        } catch (err) { console.error(err); }
                    }
                }
            }));

            React.useEffect(() => {
                if (containerRef.current && !quillRef.current) {
                    if (typeof Quill === 'undefined') {
                        console.error('Quill is not defined');
                        return;
                    }
                    const quill = new Quill(containerRef.current, {
                        theme: 'snow',
                        modules: {
                            toolbar: [
                                [{ 'header': [1, 2, 3, false] }],
                                ['bold', 'italic', 'underline', 'strike'],
                                [{ 'color': [] }, { 'background': [] }],
                                [{ 'list': 'ordered' }, { 'list': 'bullet' }],
                                [{ 'align': [] }],
                                ['link', 'image', 'blockquote', 'code-block'],
                                ['clean']
                            ]
                        }
                    });

                    quill.on('text-change', () => {
                        const html = containerRef.current.querySelector('.ql-editor').innerHTML;
                        onChange(html);
                    });

                    quillRef.current = quill;
                    // クリックで csv-block を編集するハンドラ
                    const editorRoot = containerRef.current;
                    const onClick = (e) => {
                        const csvEl = e.target.closest && e.target.closest('.csv-block');
                        if (csvEl) {
                            e.preventDefault();
                            const raw = csvEl.getAttribute('data-csv') || '';
                            const decoded = raw ? decodeURIComponent(raw) : '';
                            const newCsv = window.prompt('CSV を編集してください（カンマ区切り）。\nヘッダを含める場合は1行目にヘッダを入れてください。', decoded);
                            if (newCsv !== null) {
                                const rows = parseCSV(newCsv, ',');
                                // update data-csv but keep placeholder-only inner content (no raw table HTML)
                                csvEl.setAttribute('data-csv', encodeURIComponent(newCsv));
                                const rCount = rows.length; const cCount = rows[0] ? rows[0].length : 0;
                                csvEl.innerHTML = `<div class="csv-placeholder">表 (${rCount}行×${cCount}列) - クリックで編集</div>`;
                                // notify change to parent via onChange
                                try { const html = containerRef.current.querySelector('.ql-editor').innerHTML; onChange && onChange(html); } catch (e) { console.error(e); }
                            }
                        }
                    };
                    editorRoot.addEventListener('click', onClick);
                    // cleanup on unmount
                    const cleanup = () => editorRoot.removeEventListener('click', onClick);
                    // attach cleanup to quillRef for potential future removal
                    quillRef.current.__cleanupCsvHandler = cleanup;
                }
            }, []);

            React.useEffect(() => {
                return () => {
                    if (quillRef.current && quillRef.current.__cleanupCsvHandler) {
                        try { quillRef.current.__cleanupCsvHandler(); } catch (e) { }
                    }
                };
            }, []);

            // 初期値設定
            React.useEffect(() => {
                if (quillRef.current && value !== quillRef.current.root.innerHTML) {
                    if (!quillRef.current.hasFocus()) {
                        quillRef.current.root.innerHTML = value || '';
                    }
                }
            }, [value]);

            return (
                <div className="h-full flex flex-col bg-white rounded">
                    <div ref={containerRef} className="flex-1 overflow-hidden min-h-[280px]" style={{ height: '100%' }}></div>
                </div>
            );
        });

        // --- Stats Editor ---
        const StatsEditor = ({ stats = [], onChange }) => {
            const updateStat = (idx, field, val) => { const newStats = [...stats]; newStats[idx][field] = val; onChange(newStats); };
            return (
                <div className="space-y-2">
                    {stats.map((stat, idx) => (
                        <div key={idx} className="flex gap-2 items-center">
                            <input className="border p-1 rounded text-sm w-1/3" value={stat.label} onChange={e => updateStat(idx, 'label', e.target.value)} />
                            <input className="border p-1 rounded text-sm w-1/3" value={stat.value} onChange={e => updateStat(idx, 'value', e.target.value)} />
                            <select className="border p-1 rounded text-sm" value={stat.color} onChange={e => updateStat(idx, 'color', e.target.value)}>
                                <option value="gray">灰</option><option value="red">赤</option><option value="blue">青</option><option value="green">緑</option><option value="yellow">金</option>
                            </select>
                            <button onClick={() => onChange(stats.filter((_, i) => i !== idx))}><Icon name="x" size={16} /></button>
                        </div>
                    ))}
                    <button onClick={() => onChange([...stats, { label: '', value: '', color: 'gray' }])} className="text-xs flex items-center gap-1"><Icon name="plus" size={12} /> 追加</button>
                </div>
            );
        };

        // --- Locations Editor ---
        const LocationsEditor = ({ locations = [], onChange }) => {
            const updateLoc = (idx, field, val) => { const newLocs = [...locations]; newLocs[idx][field] = val; onChange(newLocs); };
            return (
                <div className="space-y-2 bg-gray-50 p-2 rounded border">
                    <label className="text-xs font-bold text-gray-500 block">地点リスト (複数登録可)</label>
                    {locations.map((loc, idx) => (
                        <div key={idx} className="flex gap-2 items-center text-sm">
                            <input placeholder="緯度" type="number" step="0.0001" className="border p-1 rounded w-20" value={loc.lat} onChange={e => updateLoc(idx, 'lat', e.target.value)} />
                            <input placeholder="経度" type="number" step="0.0001" className="border p-1 rounded w-20" value={loc.lng} onChange={e => updateLoc(idx, 'lng', e.target.value)} />
                            <input placeholder="ラベル" className="border p-1 rounded flex-1" value={loc.label} onChange={e => updateLoc(idx, 'label', e.target.value)} />
                            <button onClick={() => onChange(locations.filter((_, i) => i !== idx))} className="text-red-500"><Icon name="x" size={14} /></button>
                        </div>
                    ))}
                    <button onClick={() => onChange([...locations, { lat: 0, lng: 0, label: '' }])} className="text-xs text-indigo-600 flex items-center gap-1"><Icon name="plus" size={12} /> 地点追加</button>
                </div>
            );
        };

        // --- Article Link Inserter ---
        const ArticleLinkInserter = ({ articles, onInsert }) => {
            const [query, setQuery] = React.useState('');
            const [searchMode, setSearchMode] = React.useState('title'); // 'title' or 'tag'

            const filtered = React.useMemo(() => {
                if (!query) return [];
                const lowerQuery = query.toLowerCase();

                if (searchMode === 'tag') {
                    // タグ検索: 記事のタグ配列に部分一致するタグが含まれているかチェック
                    return articles.filter(a =>
                        a.tags && a.tags.some(tag => tag && tag.toLowerCase().includes(lowerQuery))
                    );
                } else {
                    // 記事名検索
                    return articles.filter(a =>
                        (a.title || '').toLowerCase().includes(lowerQuery)
                    );
                }
            }, [articles, query, searchMode]);

            return (
                <div className="space-y-2 bg-white border p-2 rounded">
                    <div className="flex items-center justify-between">
                        <label className="text-xs font-bold text-gray-500">
                            {searchMode === 'title' ? '記事名検索' : 'タグ検索'}
                        </label>
                        <div className="flex gap-1">
                            <button
                                onClick={() => setSearchMode('title')}
                                className={`px-2 py-0.5 text-xs rounded ${searchMode === 'title' ? 'bg-indigo-600 text-white' : 'bg-gray-100 text-gray-600'}`}
                            >
                                記事名
                            </button>
                            <button
                                onClick={() => setSearchMode('tag')}
                                className={`px-2 py-0.5 text-xs rounded ${searchMode === 'tag' ? 'bg-indigo-600 text-white' : 'bg-gray-100 text-gray-600'}`}
                            >
                                タグ
                            </button>
                        </div>
                    </div>
                    <input
                        className="w-full border p-1 text-sm rounded"
                        placeholder={searchMode === 'title' ? '記事名を検索...' : 'タグを検索...'}
                        value={query}
                        onChange={e => setQuery(e.target.value)}
                    />
                    <div className="max-h-48 overflow-y-auto space-y-1 custom-scrollbar">
                        {filtered.map(a => (
                            <div key={a.id} className="w-full text-left text-xs px-2 py-1 hover:bg-indigo-50 rounded group">
                                <div className="flex justify-between items-center gap-2">
                                    <div className="flex-1 pr-2 min-w-0">
                                        <div className="overflow-x-auto whitespace-nowrap text-sm font-medium" style={{ maxWidth: '100%' }} title={a.title}>
                                            {a.title}
                                        </div>
                                        {searchMode === 'tag' && a.tags && safeArray(a.tags).length > 0 && (
                                            <div className="flex flex-wrap gap-1 mt-1">
                                                {safeArray(a.tags).map(tag => (
                                                    <span key={tag} className="text-[10px] bg-gray-100 text-gray-600 px-1 rounded">
                                                        #{tag}
                                                    </span>
                                                ))}
                                            </div>
                                        )}
                                    </div>
                                    <div className="flex gap-2 shrink-0">
                                        <button onClick={() => { copyText(a.id); }} className="text-gray-400 hover:text-indigo-600 text-xs">IDコピー</button>
                                        <button onClick={() => { onInsert(a); setQuery(''); }} className="text-indigo-600 font-bold text-xs">挿入</button>
                                    </div>
                                </div>
                            </div>
                        ))}
                        {query && filtered.length === 0 && <div className="text-xs text-gray-400">見つかりません</div>}
                    </div>
                </div>
            );
        };

        // --- Image Uploader ---
        const ImageUploader = ({ onUploadComplete, label = "画像アップロード", storage, appContextId }) => {
            const [uploading, setUploading] = React.useState(false);
            const handleFileChange = async (e) => {
                const file = e.target.files[0];
                if (!file) return;
                if (!storage) { alert("Firebase Storage未設定"); return; }
                setUploading(true);
                const { ref, uploadBytes, getDownloadURL } = window.firebaseModules;
                try {
                    const path = `artifacts/${appContextId || 'default'}/uploads/${Date.now()}_${file.name}`;
                    const storageRef = ref(storage, path);
                    await uploadBytes(storageRef, file);
                    const url = await getDownloadURL(storageRef);
                    onUploadComplete(url);
                } catch (err) { alert("アップロード失敗: " + err.message); } finally { setUploading(false); }
            };
            return (
                <label className={`cursor-pointer inline-flex items-center gap-2 px-3 py-1.5 bg-gray-100 hover:bg-gray-200 rounded text-xs ${uploading ? 'opacity-50' : ''}`}>
                    {uploading ? "..." : <Icon name="image" size={14} />} {label}
                    <input type="file" className="hidden" onChange={handleFileChange} disabled={uploading} />
                </label>
            );
        };

        // --- Attachment Uploader ---
        const AttachmentUploader = ({ onAddAttachment, storage, appContextId }) => {
            const [uploading, setUploading] = React.useState(false);
            const handleFile = async (file) => {
                if (!file) return;
                setUploading(true);
                // If Firebase storage available, upload and use downloadable URL
                if (storage && window.firebaseModules && window.firebaseModules.ref) {
                    try {
                        const { ref, uploadBytes, getDownloadURL } = window.firebaseModules;
                        const path = `artifacts/${appContextId || 'default'}/attachments/${Date.now()}_${file.name}`;
                        const storageRef = ref(storage, path);
                        await uploadBytes(storageRef, file);
                        const url = await getDownloadURL(storageRef);
                        onAddAttachment({ name: file.name, url });
                    } catch (err) {
                        console.error(err);
                        alert('アップロード失敗: ' + err.message);
                    } finally { setUploading(false); }
                } else {
                    // Fallback: embed as data URL (base64)
                    const reader = new FileReader();
                    reader.onload = () => {
                        const url = reader.result;
                        onAddAttachment({ name: file.name, url });
                        setUploading(false);
                    };
                    reader.onerror = () => { alert('ファイル読み込み失敗'); setUploading(false); };
                    reader.readAsDataURL(file);
                }
            };
            return (
                <div className="space-y-2">
                    <label className={`cursor-pointer inline-flex items-center gap-2 px-3 py-1.5 bg-gray-100 hover:bg-gray-200 rounded text-xs ${uploading ? 'opacity-50' : ''}`}>
                        <svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4" /><polyline points="17 8 12 3 7 8" /><line x1="12" y1="3" x2="12" y2="15" /></svg>
                        添付ファイル
                        <input type="file" className="hidden" onChange={e => handleFile(e.target.files[0])} />
                    </label>
                </div>
            );
        };

        // --- Firebase Hooks ---
        const useFirebase = () => {
            const [db, setDb] = React.useState(null);
            const [auth, setAuth] = React.useState(null);
            const [storage, setStorage] = React.useState(null);
            const [user, setUser] = React.useState(null);
            const [loading, setLoading] = React.useState(true);
            const [error, setError] = React.useState(null);
            const [activeConfig, setActiveConfig] = React.useState(null);
            const [appContextId, setAppContextId] = React.useState(DEFAULT_APP_CONTEXT_ID);

            React.useEffect(() => {
                let retry = 0;
                const timer = setInterval(() => {
                    if (window.firebaseModules) { clearInterval(timer); init(window.firebaseModules); }
                    else if (retry++ > 50) { clearInterval(timer); setError("SDK Load Timeout"); setLoading(false); }
                }, 100);
                const init = (modules) => {
                    try {
                        let config = DEFAULT_CONFIG;
                        let appId = DEFAULT_APP_CONTEXT_ID;
                        try { const s = localStorage.getItem('worldweaver_firebase_config'); if (s) config = JSON.parse(s); } catch (e) { }
                        setActiveConfig(config);
                        setAppContextId(appId);
                        const { initializeApp, getAuth, getFirestore, getStorage, onAuthStateChanged, getApps, setPersistence, browserLocalPersistence } = modules;
                        let app = getApps().length > 0 ? getApps()[0] : initializeApp(config);
                        const authInstance = getAuth(app);
                        setAuth(authInstance);
                        setDb(getFirestore(app));
                        try { setStorage(getStorage(app)); } catch (e) { }
                        // ログイン情報を永続化（ブラウザを閉じても保持）
                        setPersistence(authInstance, browserLocalPersistence).catch(e => console.warn('Persistence setup failed:', e));
                        onAuthStateChanged(authInstance, u => { setUser(u); setLoading(false); });
                    } catch (e) { setError(e.message); setLoading(false); }
                };
                return () => clearInterval(timer);
            }, []);
            return { db, auth, storage, user, loading, error, activeConfig, appContextId };
        };

        // --- Views ---
        const WorldList = ({ db, appContextId, onSelect }) => {
            const [worlds, setWorlds] = React.useState([]);
            React.useEffect(() => {
                if (!db || !appContextId) return;
                const { collection, query, onSnapshot } = window.firebaseModules;
                const q = query(collection(db, 'artifacts', appContextId, 'public', 'data', 'worlds'));
                return onSnapshot(q, s => setWorlds(s.docs.map(d => ({ id: d.id, ...d.data() }))));
            }, [db, appContextId]);
            return (<div className="space-y-2 max-h-64 overflow-y-auto custom-scrollbar">{worlds.map(w => (<div key={w.id} onClick={() => onSelect(w.id)} className="p-3 border rounded hover:bg-indigo-50 cursor-pointer flex justify-between items-center transition group"><div><div className="font-bold text-indigo-900 group-hover:text-indigo-700">{w.name}</div><div className="text-xs text-gray-500 truncate w-64">{w.description}</div></div><Icon name="chevron-right" size={16} className="text-gray-300 group-hover:text-indigo-500" /></div>))}{worlds.length === 0 && <div className="text-gray-400 text-sm text-center py-4">世界はまだありません</div>}</div>);
        };

        const FolderTreeItem = ({ name, node, depth = 0, onSelect, selectedFolder }) => {
            const [isOpen, setIsOpen] = React.useState(true);
            const hasChildren = Object.keys(node.children).length > 0;
            const isSelected = selectedFolder === node.fullPath;
            return (
                <div className="select-none">
                    <div className={`flex items-center gap-2 py-1.5 px-2 rounded cursor-pointer transition ${isSelected ? 'bg-indigo-600 text-white font-bold' : 'hover:bg-slate-700 text-slate-300'}`} style={{ paddingLeft: `${depth * 16 + 8}px` }} onClick={() => { if (node.articles.length > 0) onSelect(node); else setIsOpen(!isOpen); }}>
                        {hasChildren ? (<span onClick={(e) => { e.stopPropagation(); setIsOpen(!isOpen); }} className="p-0.5 hover:bg-slate-600 rounded text-slate-400"><Icon name={isOpen ? "chevron-down" : "chevron-right"} size={14} /></span>) : (<span className="w-4"></span>)}
                        <Icon name={hasChildren ? (isOpen ? "folder-open" : "folder") : "folder"} size={14} className={hasChildren ? "text-indigo-400" : "text-slate-500"} />
                        <span className="truncate text-sm flex-1">{name}</span>
                        {node.articles.length > 0 && <span className="text-[10px] bg-slate-700 px-1.5 rounded-full text-slate-300">{node.articles.length}</span>}
                    </div>
                    {isOpen && hasChildren && <div>{Object.entries(node.children).sort((a, b) => a[0].localeCompare(b[0])).map(([childName, childNode]) => (<FolderTreeItem key={childName} name={childName} node={childNode} depth={depth + 1} onSelect={onSelect} selectedFolder={selectedFolder} />))}</div>}
                </div>
            );
        };

        const RecentUpdatesSidebar = ({ articles, onSelectArticle }) => {
            const sortedArticles = React.useMemo(() => {
                return [...articles].sort((a, b) => {
                    const tA = a.updatedAt ? (a.updatedAt.seconds || 0) : (a.createdAt ? (a.createdAt.seconds || 0) : 0);
                    const tB = b.updatedAt ? (b.updatedAt.seconds || 0) : (b.createdAt ? (b.createdAt.seconds || 0) : 0);
                    return tB - tA;
                }).slice(0, 20);
            }, [articles]);

            const formatDate = (timestamp) => {
                if (!timestamp) return 'No Date';
                const date = timestamp.toDate ? timestamp.toDate() : new Date(timestamp.seconds * 1000);
                const now = new Date();
                const diff = now - date;
                const days = Math.floor(diff / (1000 * 60 * 60 * 24));

                if (days === 0) return '今日';
                if (days === 1) return '昨日';
                if (days < 7) return `${days}日前`;
                return `${date.getFullYear()}/${String(date.getMonth() + 1).padStart(2, '0')}/${String(date.getDate()).padStart(2, '0')}`;
            };

            return (
                <div className="hidden lg:flex flex-col w-64 bg-slate-800 border-l border-slate-700 h-full shrink-0">
                    <div className="p-3 border-b border-slate-700 bg-slate-800/50">
                        <h3 className="text-sm font-bold text-white flex items-center gap-2">
                            <Icon name="clock" size={14} className="text-indigo-400" /> 最近の更新
                        </h3>
                    </div>
                    <div className="flex-1 overflow-y-auto p-2 custom-scrollbar space-y-1">
                        {sortedArticles.map(article => {
                            const isNew = !article.updatedAt && article.createdAt; // 簡易判定(更新日時がない＝新規作成)
                            return (
                                <div key={article.id} onClick={() => onSelectArticle(article)} className="p-2 rounded hover:bg-slate-700 cursor-pointer group transition">
                                    <div className="flex justify-between items-start mb-0.5">
                                        <div className="text-[10px] text-slate-400 font-mono">
                                            {formatDate(article.updatedAt || article.createdAt)}
                                        </div>
                                        {isNew && <span className="text-[9px] bg-emerald-900/50 text-emerald-400 px-1 rounded">NEW</span>}
                                        {!isNew && <span className="text-[9px] bg-indigo-900/50 text-indigo-400 px-1 rounded">UPD</span>}
                                    </div>
                                    <div className="text-xs text-slate-200 group-hover:text-white font-medium line-clamp-2">
                                        {article.title}
                                    </div>
                                    <div className="flex items-center gap-1 mt-1">
                                        <span className={`text-[9px] px-1 rounded ${ARTICLE_TYPES[article.type]?.color || 'bg-gray-700 text-gray-300'}`}>
                                            {ARTICLE_TYPES[article.type]?.label || article.type}
                                        </span>
                                    </div>
                                </div>
                            );
                        })}
                    </div>
                </div>
            );
        };

        const FolderIntegratedList = ({ articles, onSelectArticle, onTagClick, onOpenNoYear, onSearchChange, onlyApproved = false }) => {
            const [selectedFolderNode, setSelectedFolderNode] = React.useState(null);
            const [query, setQuery] = React.useState('');
            const [showSidebar, setShowSidebar] = React.useState(false);
            const [isGridView, setIsGridView] = React.useState(false); // New: Grid View State

            const handleContentClick = (e) => {
                const link = e.target.closest && e.target.closest('.wiki-link');
                if (!link) return;
                e.preventDefault(); e.stopPropagation();
                const id = link.getAttribute('data-article-id');
                const wikiTitle = link.getAttribute('data-wiki-title');
                if (id) {
                    const target = articles.find(a => a.id === id);
                    if (target) {
                        const y = getArticleYear(target);
                        const hasYear = y && y !== 0 && !target.noYear;
                        if (typeof onSearchChange === 'function') {
                            try { onSearchChange({ excludeNoYear: hasYear }); } catch (e) { console.warn(e); }
                        }
                        if (onSelectArticle) onSelectArticle(target);
                    } else alert('リンク先の記事が見つかりません');
                } else if (wikiTitle) {
                    if (wikiTitle === '年代なし' && onOpenNoYear) {
                        onOpenNoYear();
                        return;
                    }
                    const target = articles.find(a => (a.title || '').trim() === wikiTitle.trim());
                    if (target) {
                        const y = getArticleYear(target);
                        const hasYear = y && y !== 0 && !target.noYear;
                        if (typeof onSearchChange === 'function') {
                            try { onSearchChange({ excludeNoYear: hasYear }); } catch (e) { console.warn(e); }
                        }
                        if (onSelectArticle) onSelectArticle(target);
                    } else alert('リンク先の記事が見つかりません');
                }
            };
            const folderTree = React.useMemo(() => {
                const root = { name: 'root', fullPath: '', children: {}, articles: [], parent: null }; // Added parent support logic conceptually (though direct link is hard in deep copy, we rely on paths)
                const allArticlesNode = { name: 'すべての記事', fullPath: 'ALL', children: {}, articles: articles };
                const uncategorizedNode = { name: '未分類', fullPath: '未分類', children: {}, articles: [] };
                articles.forEach(article => {
                    const folderPath = article.folder || '未分類';
                    if (folderPath === '未分類') uncategorizedNode.articles.push(article);
                    else {
                        const parts = folderPath.split('/').filter(Boolean);
                        let current = root;
                        let currentPath = '';
                        parts.forEach((part) => {
                            currentPath = currentPath ? `${currentPath}/${part}` : part;
                            if (!current.children[part]) current.children[part] = { name: part, fullPath: currentPath, children: {}, articles: [] };
                            current = current.children[part];
                        });
                        current.articles.push(article);
                    }
                });
                if (uncategorizedNode.articles.length > 0) root.children['未分類'] = uncategorizedNode;
                return { root, allNode: allArticlesNode };
            }, [articles]);

            React.useEffect(() => { if (!selectedFolderNode && articles.length > 0) setSelectedFolderNode(folderTree.allNode); }, [articles, selectedFolderNode, folderTree]);

            const displayArticles = React.useMemo(() => {
                let target = selectedFolderNode ? selectedFolderNode.articles : [];
                if (onlyApproved) target = target.filter(a => a.isApproved);
                if (query) { const lower = query.toLowerCase(); target = articles.filter(a => [a.title, a.folder, stripHtml(a.contentHtml)].join(' ').toLowerCase().includes(lower)); }
                return sortByChronology(target);
            }, [selectedFolderNode, query, articles, onlyApproved]);

            // Helper for parent navigation
            const goToParentFolder = () => {
                if (!selectedFolderNode || selectedFolderNode.fullPath === 'ALL' || !selectedFolderNode.fullPath) return; // Already at root or all
                const parts = selectedFolderNode.fullPath.split('/');
                if (parts.length <= 1) {
                    setSelectedFolderNode(folderTree.allNode);
                } else {
                    parts.pop();
                    const parentPath = parts.join('/');
                    // Find node by path traversal
                    let current = folderTree.root;
                    let found = null;
                    // Re-traverse to find node object
                    let currPathBuild = '';
                    parts.forEach((part, i) => {
                        currPathBuild = currPathBuild ? `${currPathBuild}/${part}` : part;
                        if (current.children[part]) {
                            current = current.children[part];
                            if (i === parts.length - 1) found = current;
                        }
                    });
                    if (found) setSelectedFolderNode(found);
                    else setSelectedFolderNode(folderTree.allNode); // Fallback
                }
            };

            return (
                <div className="flex h-full bg-slate-900 relative">
                    <div className={`fixed inset-y-0 left-0 z-30 w-64 bg-slate-800 transition-transform transform ${showSidebar ? 'translate-x-0' : '-translate-x-full'} md:translate-x-0 md:static md:flex-shrink-0 border-r border-slate-700 flex flex-col h-full`}>
                        <div className="md:hidden absolute top-2 right-2">
                            <button onClick={() => setShowSidebar(false)} className="text-slate-400 hover:text-white"><Icon name="x" size={20} /></button>
                        </div>
                        <div className="p-3 border-b border-slate-700 bg-slate-800/50 space-y-2">
                            {/* Back Button for Folder History */}
                            {selectedFolderNode && selectedFolderNode.fullPath !== 'ALL' && (
                                <button onClick={goToParentFolder} className="w-full text-indigo-300 text-xs flex items-center gap-1 hover:text-white mb-1 px-1">
                                    <Icon name="arrow-left" size={12} /> 親フォルダへ戻る
                                </button>
                            )}
                            <input className="w-full border border-slate-600 bg-slate-700 text-white placeholder-slate-400 rounded px-2 py-1 text-sm focus:border-indigo-500 focus:outline-none" placeholder="記事を検索..." value={query} onChange={e => setQuery(e.target.value)} />
                        </div>
                        <div className="flex-1 overflow-y-auto p-2 custom-scrollbar">
                            {!query && <><div className={`flex items-center gap-2 py-1.5 px-2 rounded cursor-pointer transition mb-1 ${selectedFolderNode?.fullPath === 'ALL' ? 'bg-indigo-600 text-white font-bold' : 'hover:bg-slate-700 text-slate-300'}`} onClick={() => { setSelectedFolderNode(folderTree.allNode); if (window.innerWidth < 768) setShowSidebar(false); }}><Icon name="layers" size={14} className="text-indigo-400" /><span className="text-sm">すべての記事</span><span className="text-[10px] bg-slate-700 text-slate-300 px-1.5 rounded-full ml-auto">{articles.length}</span></div><hr className="my-2 border-slate-700" />{Object.entries(folderTree.root.children).sort((a, b) => a[0].localeCompare(b[0])).map(([name, node]) => (<FolderTreeItem key={name} name={name} node={node} onSelect={(n) => { setSelectedFolderNode(n); if (window.innerWidth < 768) setShowSidebar(false); }} selectedFolder={selectedFolderNode?.fullPath} />))}</>}
                        </div>
                    </div>
                    {showSidebar && <div className="fixed inset-0 bg-black/50 z-20 md:hidden" onClick={() => setShowSidebar(false)}></div>}
                    <button className="md:hidden absolute bottom-6 right-6 z-40 p-3 bg-indigo-600 rounded-full text-white shadow-lg flex items-center justify-center animate-bounce" onClick={() => setShowSidebar(!showSidebar)}><Icon name="menu" size={24} /></button>
                    <div className="flex-1 overflow-y-auto p-4 bg-slate-900 custom-scrollbar">
                        {/* View Toggle Header */}
                        <div className="max-w-6xl mx-auto mb-4 flex justify-between items-center">
                            <h2 className="text-white text-lg font-bold flex items-center gap-2">
                                <Icon name="folder" size={20} className="text-gray-400" />
                                {selectedFolderNode ? (selectedFolderNode.name === 'root' ? 'ルート' : selectedFolderNode.name) : '読み込み中...'}
                            </h2>
                            <div className="flex bg-slate-800 rounded p-1 gap-1">
                                <button onClick={() => setIsGridView(false)} className={`p-1.5 rounded ${!isGridView ? 'bg-indigo-600 text-white' : 'text-slate-400 hover:text-white'}`} title="リスト表示"><Icon name="list" size={16} /></button>
                                <button onClick={() => setIsGridView(true)} className={`p-1.5 rounded ${isGridView ? 'bg-indigo-600 text-white' : 'text-slate-400 hover:text-white'}`} title="グリッド表示"><Icon name="grid" size={16} /></button>
                            </div>
                        </div>

                        <div className={`max-w-6xl mx-auto ${isGridView ? 'grid grid-cols-2 md:grid-cols-4 lg:grid-cols-5 gap-4' : 'space-y-4'}`}>
                            {displayArticles.map(article => (
                                isGridView ? (
                                    // Grid Item
                                    <div key={article.id} onClick={() => onSelectArticle && onSelectArticle(article)} className="bg-slate-800/50 border border-slate-700 rounded-xl overflow-hidden cursor-pointer hover:border-indigo-500 hover:bg-slate-800 transition group flex flex-col h-48 relative">
                                        <div className="p-3 flex-1 flex flex-col">
                                            <div className="flex justify-between items-center mb-2">
                                                <span className={`px-1.5 py-0.5 text-[10px] rounded ${ARTICLE_TYPES[article.type]?.color}`}>{ARTICLE_TYPES[article.type]?.icon && <Icon name={ARTICLE_TYPES[article.type].icon} size={10} className="inline mr-1" />}{ARTICLE_TYPES[article.type]?.label}</span>
                                                {article.isApproved && <Icon name="check-circle" size={12} className="text-emerald-400" />}
                                            </div>
                                            <h3 className="text-sm font-bold text-white group-hover:text-indigo-400 line-clamp-2 leading-snug mb-1">{article.title}</h3>
                                            <div className="text-[10px] text-slate-400 font-mono mt-auto">{article.dateStr || article.year || 'No Date'}</div>
                                        </div>
                                        {/* Simple visual decoration or thumbnail placeholder if available */}
                                        <div className="h-1 bg-gradient-to-r from-transparent via-indigo-500/20 to-transparent"></div>
                                    </div>
                                ) : (
                                    // List Item (Existing Design)
                                    <div key={article.id} onClick={() => onSelectArticle && onSelectArticle(article)} className="bg-slate-800/50 border border-slate-700 rounded-xl p-6 cursor-pointer hover:border-indigo-500 hover:bg-slate-800 transition group">
                                        <div className="flex items-center justify-between text-xs text-slate-400 mb-3"><span className={`px-2 py-0.5 rounded ${ARTICLE_TYPES[article.type]?.color}`}>{ARTICLE_TYPES[article.type]?.label}</span><span className="font-mono bg-slate-700 text-slate-300 px-1 rounded">{article.dateStr || article.year}</span></div>
                                        <h3 className="text-xl font-bold text-white group-hover:text-indigo-400 mb-3 flex items-center gap-2">
                                            {article.isApproved && <Icon name="check-circle" size={16} className="text-emerald-400" />}
                                            {article.title}
                                        </h3>
                                        <div className="text-sm text-slate-300 mb-4 leading-relaxed line-clamp-3" onClick={handleContentClick} dangerouslySetInnerHTML={{ __html: transformContent(article.contentHtml || '') }}></div>
                                        <div className="flex flex-wrap gap-1 pt-3 border-t border-slate-700">{safeArray(article.tags).map(tag => <span key={tag} className="text-xs bg-slate-700 text-slate-300 px-2 py-1 rounded">#{tag}</span>)}</div>
                                    </div>
                                )
                            ))}
                        </div>
                    </div>
                    {/* Right Sidebar: Recent Updates */}
                    <RecentUpdatesSidebar articles={articles} onSelectArticle={onSelectArticle} />
                </div>
            );
        };

        // MapLayerManager: 地図レイヤー管理
        const MapLayerManager = ({ layers = [], onUpdate, storage, appContextId }) => {
            const [name, setName] = React.useState('');
            const handleAdd = (url) => {
                const newLayer = { id: Math.random().toString(36).substr(2, 9), name: name || '新規レイヤー', url };
                onUpdate([...layers, newLayer]);
                setName('');
            };
            const handleRemove = (id) => {
                if (confirm('このレイヤーを削除しますか？')) {
                    onUpdate(layers.filter(l => l.id !== id));
                }
            };
            return (
                <div className="space-y-4">
                    {layers.map((l, i) => (
                        <div key={l.id} className="flex justify-between items-center border p-2 rounded bg-white">
                            <span className="font-bold text-sm">{l.name}</span>
                            <div className="flex items-center gap-2">
                                <a href={l.url} target="_blank" className="text-blue-500 text-xs underline">確認</a>
                                <button onClick={() => handleRemove(l.id)} className="text-red-500 text-xs hover:underline">削除</button>
                            </div>
                        </div>
                    ))}
                    <div className="border border-dashed p-3 rounded bg-gray-50">
                        <div className="text-xs font-bold mb-2 text-gray-500">新規レイヤー追加</div>
                        <input className="w-full border p-1.5 rounded mb-2 text-sm" placeholder="レイヤー名 (例: 1000年, 地下)" value={name} onChange={e => setName(e.target.value)} />
                        <ImageUploader storage={storage} appContextId={appContextId} onUploadComplete={handleAdd} label="画像を追加" />
                    </div>
                </div>
            );
        };

        // MapView: 年代バー付き・複数地点対応・レイヤー切り替え対応
        const MapView = ({ articles = [], worldData, onSelectArticle, onLocationSelect, isEditing = false, storage, highlightArticleId, appContextId, showControls = true, myRole = 'guest', externalQuery, onExternalQueryChange, restrictToHighlightOnEdit = true, minImportance = 0 }) => {
            const mapRef = React.useRef(null);
            const leafletMap = React.useRef(null);
            const markersRef = React.useRef([]);
            const [mapQuery, setMapQuery] = React.useState('');
            const [yearRange, setYearRange] = React.useState({ years: [], min: -1000, max: 3000, index: 0, currentCenter: 1000, range: 2000, manualRange: false });

            // Layer Management
            const [activeLayerId, setActiveLayerId] = React.useState(null);
            const layers = React.useMemo(() => {
                if (Array.isArray(worldData?.mapLayers) && worldData.mapLayers.length > 0) return worldData.mapLayers;
                // fallback legacy
                if (worldData?.mapImageUrl) return [{ id: 'default', name: '標準マップ', url: worldData.mapImageUrl }];
                return [];
            }, [worldData]);

            const activeLayer = React.useMemo(() => {
                if (activeLayerId) {
                    const found = layers.find(l => l.id === activeLayerId);
                    if (found) return found;
                }
                return layers.length > 0 ? layers[0] : null;
            }, [layers, activeLayerId]);

            // Sync active layer ID if needed (initially)
            React.useEffect(() => {
                if (!activeLayerId && layers.length > 0) setActiveLayerId(layers[0].id);
            }, [layers]);


            // 記事全体の年代範囲計算
            React.useEffect(() => {
                if (articles.length > 0) {
                    // build sorted unique integer years from articles
                    const yrs = Array.from(new Set(articles.map(getArticleYear).map(y => Math.floor(y)).filter(y => !isNaN(y)))).sort((a, b) => a - b);
                    if (yrs.length > 0) {
                        const idx = Math.floor(yrs.length / 2);
                        const computeRangeForIndex = (i) => {
                            if (yrs.length === 1) return 50;
                            if (i === 0) return Math.max(50, Math.floor((yrs[1] - yrs[0]) / 2));
                            if (i === yrs.length - 1) return Math.max(50, Math.floor((yrs[i] - yrs[i - 1]) / 2));
                            return Math.max(30, Math.floor(Math.min((yrs[i] - yrs[i - 1]) / 2, (yrs[i + 1] - yrs[i]) / 2)));
                        };
                        const initialRange = computeRangeForIndex(idx);
                        setYearRange({ years: yrs, min: yrs[0], max: yrs[yrs.length - 1], index: idx, currentCenter: yrs[idx], range: initialRange, manualRange: false });
                    }
                }
            }, [articles]);

            const filteredArticles = React.useMemo(() => {
                // Determine effective query (external overrides internal)
                const q = (externalQuery !== undefined ? externalQuery : mapQuery || '').trim().toLowerCase();

                // base set depending on editing mode and restriction flag
                let base = articles;
                if (isEditing && restrictToHighlightOnEdit) {
                    // only show the highlighted/draft article while editing
                    if (highlightArticleId) base = articles.filter(a => a.id === highlightArticleId);
                    else base = articles.filter(a => a.id === '__draft__');
                } else if (!(isEditing || !showControls)) {
                    base = articles.filter(a => {
                        const y = getArticleYear(a);
                        return Math.abs(y - yearRange.currentCenter) <= yearRange.range;
                    });
                }

                if (!q && !minImportance) return base;
                const matches = (a) => {
                    if (minImportance > 0 && (a.importance || 3) < minImportance) return false;
                    const hay = [a.title || '', stripHtml(a.contentHtml || ''), safeArray(a.tags).join(' '), a.representedTag || ''].join(' ').toLowerCase();
                    return hay.includes(q);
                };
                return base.filter(matches);
            }, [articles, yearRange, isEditing, showControls, mapQuery, externalQuery, highlightArticleId, restrictToHighlightOnEdit, minImportance]);

            React.useEffect(() => {
                if (!mapRef.current || leafletMap.current) return;
                const map = L.map(mapRef.current, { crs: L.CRS.Simple, minZoom: -3, maxZoom: 4, zoomControl: false });
                leafletMap.current = map;
                map.on('click', (e) => isEditing && onLocationSelect && onLocationSelect({ lat: e.latlng.lat, lng: e.latlng.lng }));
            }, []); // Initialize map once

            // Update Image Layer
            React.useEffect(() => {
                const map = leafletMap.current;
                if (!map) return;

                // Remove existing image layers
                map.eachLayer(layer => {
                    if (layer instanceof L.ImageOverlay || layer instanceof L.Rectangle) {
                        map.removeLayer(layer);
                    }
                });

                if (activeLayer) {
                    const img = new Image();
                    img.src = activeLayer.url;
                    img.onload = () => {
                        const bounds = [[-img.height / 2, -img.width / 2], [img.height / 2, img.width / 2]];
                        const overlay = L.imageOverlay(activeLayer.url, bounds).addTo(map);
                        overlay.bringToBack();
                        map.fitBounds(bounds);
                    };
                } else {
                    const bounds = [[-500, -500], [500, 500]];
                    const rect = L.rectangle(bounds, { color: "#9ca3af", weight: 1, fill: false }).addTo(map);
                    rect.bringToBack();
                    map.fitBounds(bounds);
                }
            }, [activeLayer]);

            React.useEffect(() => {
                if (!leafletMap.current) return;
                markersRef.current.forEach(m => m.remove());
                markersRef.current = [];
                filteredArticles.forEach(article => {
                    const locs = getArticleLocations(article);
                    locs.forEach((loc) => {
                        const highlighted = highlightArticleId && highlightArticleId === article.id;
                        const color = highlighted ? '#10b981' : '#3b82f6';
                        const marker = L.circleMarker([loc.lat, loc.lng], { color, fillColor: color, fillOpacity: highlighted ? 0.9 : 0.6, radius: highlighted ? 14 : 8, weight: 2 })
                            .addTo(leafletMap.current)
                            .bindTooltip(loc.label && loc.label !== article.title ? `${loc.label} (${article.title})` : (loc.label || article.title), { permanent: true, direction: 'top', className: 'map-label' });

                        if (onSelectArticle) {
                            marker.on('click', () => onSelectArticle(article));
                        }
                        markersRef.current.push(marker);

                        if (highlighted && showControls && leafletMap.current) {
                            leafletMap.current.panTo([loc.lat, loc.lng], { animate: true });
                        }
                    });
                });
            }, [filteredArticles, highlightArticleId, showControls]);


            React.useEffect(() => {
                const updateMapSize = () => { if (leafletMap.current) leafletMap.current.invalidateSize(); };
                const resizeObserver = new ResizeObserver(updateMapSize);
                if (mapRef.current) resizeObserver.observe(mapRef.current);
                const timers = [100, 300, 500, 1000].map(delay => setTimeout(updateMapSize, delay));
                return () => { resizeObserver.disconnect(); timers.forEach(clearTimeout); };
            }, []);

            React.useEffect(() => { if (leafletMap.current) setTimeout(() => leafletMap.current.invalidateSize(), 200); }, [highlightArticleId]);

            return (
                <div className="relative w-full h-full group">
                    <div ref={mapRef} className="w-full h-full bg-slate-200 rounded-lg overflow-hidden" />

                    {/* Layer Switcher */}
                    {layers.length > 1 && (
                        <div className="absolute top-4 right-4 z-[1000] bg-white/90 p-2 rounded shadow-sm flex items-center gap-2">
                            <Icon name="layers" size={14} className="text-gray-500" />
                            <select
                                value={activeLayerId || ''}
                                onChange={e => setActiveLayerId(e.target.value)}
                                className="text-sm bg-transparent outline-none font-bold text-gray-700"
                            >
                                {layers.map(l => <option key={l.id} value={l.id}>{l.name}</option>)}
                            </select>
                        </div>
                    )}

                    {/* Map search input (visible when controls shown and not editing, and no external query) */}
                    {!isEditing && showControls && externalQuery === undefined && (
                        <div className="absolute top-4 left-4 z-[1000]">
                            <input
                                value={mapQuery}
                                onChange={e => {
                                    setMapQuery(e.target.value);
                                }}
                                placeholder="地図検索 (タイトル/本文/タグ)..."
                                className="p-2 rounded bg-white/90 text-sm border w-64 shadow-sm"
                            />
                        </div>
                    )}

                    {!isEditing && showControls && (
                        <div className="absolute bottom-4 left-4 right-4 z-[1000] bg-white/90 p-3 rounded-lg shadow-lg backdrop-blur flex flex-col gap-2 opacity-90 hover:opacity-100 transition-opacity duration-300">
                            <div className="flex justify-between text-xs font-bold text-gray-600">
                                <span>中心年代: {Math.floor(yearRange.currentCenter)}年</span>
                                <span>範囲: ±{Math.floor(yearRange.range)}年</span>
                            </div>
                            <div className="flex flex-col gap-1">
                                <label className="text-[10px] text-gray-500">
                                    選択年代 {yearRange.years && yearRange.years.length > 0 ? `(${yearRange.years[0]} ~ ${yearRange.years[yearRange.years.length - 1]})` : ''}
                                </label>
                                <input
                                    type="range"
                                    min={0}
                                    max={Math.max(0, (yearRange.years ? yearRange.years.length - 1 : 0))}
                                    value={yearRange.index || 0}
                                    onChange={e => {
                                        const idx = Number(e.target.value);
                                        const yrs = yearRange.years || [];
                                        if (yrs.length === 0) return;
                                        const newCenter = yrs[idx];
                                        const computeRange = (i) => {
                                            if (yrs.length === 1) return 50;
                                            if (i === 0) return Math.max(50, Math.floor((yrs[1] - yrs[0]) / 2));
                                            if (i === yrs.length - 1) return Math.max(50, Math.floor((yrs[i] - yrs[i - 1]) / 2));
                                            return Math.max(30, Math.floor(Math.min((yrs[i] - yrs[i - 1]) / 2, (yrs[i + 1] - yrs[i]) / 2)));
                                        };
                                        setYearRange(prev => {
                                            const newState = { ...prev, index: idx, currentCenter: newCenter };
                                            // only auto-compute range if user didn't override it
                                            if (!prev.manualRange) newState.range = computeRange(idx);
                                            return newState;
                                        });
                                    }}
                                    className="w-full h-1 bg-indigo-200 rounded-lg appearance-none cursor-pointer"
                                />
                                <div className="flex items-center gap-2">
                                    <div className="text-[10px] text-gray-500">表示範囲: ±{Math.floor(yearRange.range)}年</div>
                                    <div className="flex-1">
                                        {/* range slider: allow manual adjustment of ± years */}
                                        <input type="range" min={0} max={Math.max(1, Math.ceil((yearRange.max - yearRange.min) || 100))} value={yearRange.range || 0} onChange={e => setYearRange(prev => ({ ...prev, range: Number(e.target.value), manualRange: true }))} className="w-full h-1 bg-gray-300 rounded-lg appearance-none cursor-pointer" />
                                    </div>
                                </div>
                            </div>
                        </div>
                    )}
                </div>
            );
        };

        const SearchFilterBar = ({ searchState, onSearchChange, onResetFilters, count, variant = 'light' }) => {
            const handleChange = (field, value) => onSearchChange && onSearchChange({ [field]: value });
            const isDark = variant === 'dark';
            const bgClass = isDark ? 'bg-slate-800 border-slate-700 text-white' : 'bg-white border-gray-100 text-gray-800';
            const inputClass = isDark ? 'bg-slate-700 border-slate-600 text-white placeholder-slate-400' : 'bg-white border-gray-200 text-gray-800';
            return (
                <div className={`${bgClass} rounded-xl shadow-sm border p-4 space-y-3`}>
                    <div className="grid grid-cols-3 gap-3">
                        <input className={`w-full border rounded px-2 py-1.5 text-sm ${inputClass}`} value={searchState.keyword || ''} onChange={e => handleChange('keyword', e.target.value)} placeholder="名称" />
                        <input className={`w-full border rounded px-2 py-1.5 text-sm ${inputClass}`} value={searchState.tag || ''} onChange={e => handleChange('tag', e.target.value)} placeholder="#タグ" />
                        <select className={`w-full border rounded px-2 py-1.5 text-sm ${inputClass}`} value={searchState.type || 'all'} onChange={e => handleChange('type', e.target.value)}>{['all', ...Object.keys(ARTICLE_TYPES)].map(k => <option key={k} value={k}>{ARTICLE_TYPES[k]?.label || 'すべて'}</option>)}</select>
                    </div>
                    <div className="flex items-center gap-2 mt-2">
                        <label className="text-xs font-bold opacity-70">重要度:</label>
                        <div className="flex bg-gray-100 rounded p-0.5">
                            {[1, 2, 3, 4, 5].map(v => (
                                <button key={v} onClick={() => handleChange('minImportance', searchState.minImportance === v ? 0 : v)} className={`px-2 py-0.5 text-xs rounded ${searchState.minImportance === v ? 'bg-indigo-600 text-white font-bold' : searchState.minImportance > v ? 'text-indigo-600' : 'text-gray-400'}`}>
                                    {v}
                                </button>
                            ))}
                            <span className="text-[10px] items-center flex px-1 text-gray-400">{searchState.minImportance ? '以上' : '指定なし'}</span>
                        </div>
                    </div>
                    <div className="flex justify-between items-center text-xs opacity-80 mt-2">
                        <div className="flex items-center gap-2">
                            <span>{count}件</span>
                            <label className="flex items-center gap-1 cursor-pointer bg-black/10 px-2 py-0.5 rounded">
                                <input type="checkbox" checked={!!searchState.onlyApproved} onChange={e => handleChange('onlyApproved', e.target.checked)} />
                                承認済みのみ
                            </label>
                        </div>
                        <button onClick={onResetFilters}>クリア</button>
                    </div>
                </div>
            );
        };

        const TagMiniTimeline = ({ tag, articles = [], onSelectArticle, isTreeMode = false, selectedArticleId, onTagClick }) => {
            if (!tag) return null;
            const items = React.useMemo(() => sortByChronology(articles.filter(a => safeArray(a.tags).includes(tag))), [articles, tag]);

            const displayItems = React.useMemo(() => {
                if (!selectedArticleId || items.length === 0) return items.slice(0, 3);
                const currentIndex = items.findIndex(item => item.id === selectedArticleId);
                if (currentIndex === -1) return items.slice(0, 3);
                const start = Math.max(0, currentIndex - 1);
                const end = Math.min(items.length, currentIndex + 2);
                return items.slice(start, end);
            }, [items, selectedArticleId]);

            if (isTreeMode) {
                return (
                    <div className="min-w-[200px] bg-white/5 rounded-lg p-3 border border-white/10 snap-start shrink-0 relative">
                        <div className="absolute top-4 -left-4 w-4 h-px bg-white/30"></div>
                        <div onClick={() => onTagClick && onTagClick(tag)} className="text-xs font-bold text-white/80 mb-4 flex items-center gap-2 border-b border-white/10 pb-2 cursor-pointer hover:text-indigo-300 transition-colors"><Icon name="hash" size={12} /> {tag}<span className="ml-auto text-[10px] bg-white/10 px-1.5 rounded-full">{items.length}</span></div>
                        <div className="relative pl-4 space-y-0">
                            <div className="absolute left-0 top-2 bottom-2 w-px bg-white/20"></div>
                            {displayItems.map(item => {
                                const isCurrent = item.id === selectedArticleId;
                                return (
                                    <div key={item.id} className="relative py-1">
                                        <div className="mindmap-branch"></div>
                                        <button onClick={() => onSelectArticle && onSelectArticle(item)} className={`text-left w-full pl-2 py-1.5 rounded transition flex flex-col relative z-10 ${isCurrent ? 'bg-white/20 shadow' : 'hover:bg-white/10'}`}>
                                            <span className={`text-xs font-bold truncate w-full ${isCurrent ? 'text-white' : 'text-white/70'}`}>{item.title}</span>
                                            <span className="text-[10px] text-white/40 font-mono">{item.year}</span>
                                        </button>
                                    </div>
                                );
                            })}
                            {items.length > displayItems.length && <div className="text-[10px] text-white/40 italic pl-2 pt-1">他 {items.length - displayItems.length} 件</div>}
                            {items.length === 0 && <div className="text-[10px] text-white/30 italic">記事なし</div>}
                        </div>
                    </div>
                );
            }
            return null;
        };

        const TagTimelineColumns = ({ tags = [], articles = [], onSelectArticle, selectedArticleId, onTagClick }) => (
            <div className="flex gap-8 overflow-x-auto pb-4 snap-x-mandatory w-full custom-scrollbar pl-4">
                {tags.map(tag => <TagMiniTimeline key={tag} tag={tag} articles={articles} onSelectArticle={onSelectArticle} selectedArticleId={selectedArticleId} isTreeMode={true} onTagClick={onTagClick} />)}
            </div>
        );

        // --- LargeTimelineView (構造年表: 統合版) ---
        const LargeTimelineView = ({ articles = [], onSelectArticle, onEditArticle, onDeleteArticle, onDuplicateArticle, focusedArticle, onFocusChange, allArticles = [], searchState, onSearchChange, onResetFilters, worldData, appContextId, myRole, isMember, onOpenNoYear, onOpenTagArticle, tagArticleValue, onTagArticleValueChange }) => {
            const [showSearch, setShowSearch] = React.useState(false);
            const [centeredArticleId, setCenteredArticleId] = React.useState(null);
            const [viewMode, setViewMode] = React.useState('broad'); // 'broad' (title only) or 'detailed'
            const containerRef = React.useRef(null);
            const articleRefs = React.useRef(new Map());
            const noYearRefs = React.useRef(new Map());
            const sortedArticles = React.useMemo(() => sortByChronology(articles), [articles]);
            const isJumpingRef = React.useRef(false);


            const noYearArticles = React.useMemo(() => sortedArticles.filter(a => {
                // noYearフラグが立っている、または年代が0/nullの記事
                if (a.noYear === true) return true;
                const y = Math.floor(getArticleYear(a));
                return !y || Number(y) === 0;
            }).sort((a, b) => String(a.title || '').localeCompare(String(b.title || ''))), [sortedArticles]);

            const datedArticles = React.useMemo(() => sortedArticles.filter(a => {
                // noYearフラグが立っている記事は除外
                if (a.noYear === true) return false;
                const y = Math.floor(getArticleYear(a));
                return y && Number(y) !== 0;
            }), [sortedArticles]);

            const displayArticles = React.useMemo(() => {
                // 詳細モードで年代あり記事を表示する場合のロジック
                // 年代なし記事は年表に表示しない（datedArticlesにはすでに含まれていない）
                // if (viewMode === 'detailed' && focusedArticle) {
                //     if (focusedArticle.noYear === true) return [focusedArticle];
                //     const y = Math.floor(getArticleYear(focusedArticle));
                //     if (!y || y === 0) return [focusedArticle];
                // }
                return datedArticles;
            }, [datedArticles]);

            const scrollToArticle = (id) => {
                // wait for render if switching modes
                setTimeout(() => {
                    const el = articleRefs.current.get(id);
                    if (el) el.scrollIntoView({ behavior: 'smooth', block: 'center' });
                }, 100);
            };

            const scrollToNoYearArticle = (id) => {
                const el = noYearRefs.current.get(id);
                if (el) el.scrollIntoView({ behavior: 'smooth', block: 'center' });
            };

            const handleJump = (item) => {
                isJumpingRef.current = true;
                const inList = sortedArticles.some(a => a.id === item.id);
                if (onResetFilters) onResetFilters();

                // Always switch to detailed view when jumping to a specific item
                if (viewMode === 'broad') setViewMode('detailed');

                if (!inList) {
                    if (onSelectArticle) onSelectArticle(item);
                    setTimeout(() => { scrollToArticle(item.id); isJumpingRef.current = false; }, 200);
                } else {
                    if (onSelectArticle) onSelectArticle(item);
                    setTimeout(() => { scrollToArticle(item.id); isJumpingRef.current = false; }, 100);
                }
            };

            const handleContentClick = (e) => {
                const link = e.target.closest('.wiki-link');
                if (link) {
                    e.preventDefault(); e.stopPropagation();
                    const id = link.getAttribute('data-article-id');
                    const wikiTitle = link.getAttribute('data-wiki-title');

                    const openTarget = (target) => {
                        if (onSelectArticle) onSelectArticle(target);

                        const y = getArticleYear(target);
                        const hasYear = y && Number(y) !== 0 && !target.noYear;

                        // 記事の年代状態に応じてフィルタを調整
                        if (typeof onSearchChange === 'function') {
                            onSearchChange({ excludeNoYear: hasYear });
                        }

                        if (hasYear) {
                            if (window.setAppViewMode) window.setAppViewMode('timeline_large');
                        } else {
                            if (window.setAppViewMode) window.setAppViewMode('single_article');
                        }

                        if (typeof onResetFilters !== 'undefined' && onResetFilters) onResetFilters();
                    };

                    if (id) {
                        const target = allArticles.find(a => a.id === id);
                        if (target) {
                            openTarget(target);
                        } else alert("リンク先の記事が見つかりません");
                    } else if (wikiTitle) {
                        if (wikiTitle === '年代なし') {
                            if (onOpenNoYear) onOpenNoYear();
                        } else {
                            const target = allArticles.find(a => (a.title || '').trim() === wikiTitle.trim());
                            if (target) openTarget(target); else alert("リンク先の記事が見つかりません");
                        }
                    }
                }
            };

            const handleScroll = () => {
                if (isJumpingRef.current || !containerRef.current || viewMode === 'broad') return;
                const container = containerRef.current;
                const center = container.scrollTop + container.clientHeight / 2;
                let closest = null, minDst = Infinity;
                sortedArticles.forEach(a => {
                    const el = articleRefs.current.get(a.id);
                    if (el) {
                        const dst = Math.abs((el.offsetTop + el.offsetHeight / 2) - center);
                        if (dst < minDst) { minDst = dst; closest = a; }
                    }
                });
                if (closest && closest.id !== centeredArticleId) {
                    setCenteredArticleId(closest.id);
                    if (onFocusChange) onFocusChange(closest);
                }
            };

            React.useEffect(() => { if (focusedArticle) { const t = setTimeout(() => scrollToArticle(focusedArticle.id), 500); return () => clearTimeout(t); } }, [focusedArticle]);
            const activeArticle = focusedArticle && focusedArticle.id === centeredArticleId ? focusedArticle : sortedArticles.find(a => a.id === centeredArticleId) || focusedArticle;


            // 外部から記事が選択されたとき（地図モードなどから遷移してきたとき）は詳細モードに切り替える
            React.useEffect(() => {
                if (focusedArticle && viewMode === 'broad') {
                    setViewMode('detailed');
                }
            }, [focusedArticle]);

            return (
                <div className="h-full w-full overflow-hidden bg-slate-900 text-white relative flex flex-col">
                    <div className="shrink-0 bg-slate-900/90 backdrop-blur px-4 md:px-6 py-4 border-b border-white/10 z-20 relative flex justify-between items-center">
                        <div className="flex flex-col">
                            <div className="text-[11px] uppercase tracking-widest text-white/60">LARGE TIMELINE</div>
                            <div className="flex items-center gap-3 flex-wrap">
                                <div className="text-sm text-white mt-1 flex-1">{searchState.keyword || searchState.tag || "全記事"}</div>
                                <input className="text-sm p-1 rounded bg-white/90 text-gray-800 w-full sm:w-64" placeholder="本文検索..." value={searchState.keyword || ''} onChange={e => onSearchChange({ keyword: e.target.value })} />
                                <label className="ml-3 text-xs text-white/70 flex items-center gap-2"><input type="checkbox" checked={!!searchState.excludeNoYear} onChange={e => onSearchChange({ excludeNoYear: e.target.checked })} /> 年代設定記事モード</label>

                                {onOpenTagArticle && (
                                    <div className="flex items-center gap-1 ml-0 sm:ml-4 w-full sm:w-auto">
                                        <input className="text-sm p-1 rounded bg-white/90 text-gray-800 w-full sm:w-40" placeholder="#タグ/キーワード" value={tagArticleValue || ''} onChange={e => onTagArticleValueChange && onTagArticleValueChange(e.target.value)} />
                                        <button onClick={() => { if (tagArticleValue) onOpenTagArticle(tagArticleValue); }} className="px-2 py-1 bg-emerald-500 text-white text-xs rounded">タグ記録</button>
                                    </div>
                                )}
                            </div>
                        </div>
                        <div className="flex items-center gap-2">
                            <div className="flex bg-white/10 rounded p-1">
                                <button onClick={() => setViewMode('broad')} className={`px-3 py-1 text-xs rounded transition ${viewMode === 'broad' ? 'bg-indigo-600 text-white font-bold' : 'text-white/60 hover:text-white'}`}>年表 (全体)</button>
                                <button onClick={() => setViewMode('detailed')} className={`px-3 py-1 text-xs rounded transition ${viewMode === 'detailed' ? 'bg-indigo-600 text-white font-bold' : 'text-white/60 hover:text-white'}`}>詳細</button>
                            </div>
                            <button onClick={() => setShowSearch(!showSearch)} className="p-2 bg-white/10 rounded"><Icon name="search" size={18} /></button>
                        </div>
                        {showSearch && <div className="absolute top-full left-0 right-0 z-30 mt-2 px-4"><SearchFilterBar searchState={searchState} onSearchChange={onSearchChange} onResetFilters={onResetFilters} count={articles.length} variant="dark" /></div>}
                    </div>
                    <div className="flex-1 flex relative overflow-hidden">
                        {/* 年代未設定記事のセクション（スクロール内の最上部に表示） */}
                        {noYearArticles.length > 0 && (
                            <div className="w-full p-6 border-b border-white/10 z-10 bg-transparent">
                                <div className="flex items-center justify-between mb-3">
                                    <div className="text-sm font-bold text-white">年代未設定の記事</div>
                                    <div className="text-xs text-white/60">編集で「年代なし」を設定した記事</div>
                                </div>
                                <div className="grid gap-3 sm:grid-cols-2 md:grid-cols-3 lg:grid-cols-4 max-h-60 overflow-y-auto">
                                    {noYearArticles.map(a => (
                                        <div key={a.id} ref={el => el ? noYearRefs.current.set(a.id, el) : noYearRefs.current.delete(a.id)} data-noyear-id={a.id} className="bg-white/5 p-3 rounded-lg border border-white/5 flex flex-col">
                                            <div className="flex justify-between items-start gap-2">
                                                <div className="text-sm font-bold text-white truncate">{a.title}</div>
                                                <div className="text-[10px] text-white/60">{a.dateStr || ''}</div>
                                            </div>
                                            <div className="text-xs text-white/60 mt-2 line-clamp-2" onClick={handleContentClick} dangerouslySetInnerHTML={{ __html: highlightHtml(transformContent(a.contentHtml || ''), searchState.keyword) }}></div>
                                            <div className="mt-3 flex gap-2 justify-end">
                                                <button type="button" style={{ position: 'relative', zIndex: 1000, pointerEvents: 'auto' }} onClick={(e) => {
                                                    e.stopPropagation();
                                                    if (typeof onSearchChange === 'function') {
                                                        try { onSearchChange({ type: 'all', keyword: '', tag: '', excludeNoYear: false }); }
                                                        catch (err) { console.warn('onSearchChange failed', err); }
                                                    }
                                                    if (typeof onOpenNoYear === 'function') {
                                                        onOpenNoYear(a.id);
                                                        return;
                                                    }
                                                    setTimeout(() => {
                                                        if (onSelectArticle) onSelectArticle(a);
                                                        // Switch to dedicated single article view for complex layouts
                                                        if (window.setAppViewMode) window.setAppViewMode('single_article');
                                                    }, 150);
                                                }} className="px-2 py-1 text-xs bg-white/10 rounded">表示</button>
                                                {isMember && <button type="button" style={{ position: 'relative', zIndex: 1000, pointerEvents: 'auto' }} onClick={(e) => { e.stopPropagation(); onEditArticle && onEditArticle(a); }} className="px-2 py-1 text-xs bg-indigo-600 text-white rounded">編集</button>}
                                                {isMember && <button type="button" style={{ position: 'relative', zIndex: 1000, pointerEvents: 'auto' }} onClick={(e) => { e.stopPropagation(); onDuplicateArticle && onDuplicateArticle(a); }} className="px-2 py-1 text-xs bg-emerald-600 text-white rounded">複製</button>}
                                                {(myRole === 'owner' || myRole === 'admin') && <button type="button" style={{ position: 'relative', zIndex: 1000, pointerEvents: 'auto' }} onClick={(e) => { e.stopPropagation(); onDeleteArticle && onDeleteArticle(a); }} className="px-2 py-1 text-xs bg-red-600 text-white rounded">削除</button>}
                                            </div>
                                        </div>
                                    ))}
                                </div>
                            </div>
                        )}

                        {viewMode === 'detailed' && (
                            <div className="w-12 bg-slate-950 border-r border-white/10 hidden md:block timeline-ruler z-10 sticky top-0 h-full"><div className="absolute top-1/2 w-full text-center text-[10px] text-indigo-400 font-bold bg-slate-900 py-1 border-y border-indigo-500/30 transform -translate-y-1/2">{activeArticle ? getArticleYear(activeArticle) : '???'}</div></div>
                        )}

                        <div ref={containerRef} className={`flex-1 overflow-y-auto scroll-smooth relative ${viewMode === 'detailed' ? 'p-4 md:p-10' : 'p-6'}`} onScroll={handleScroll}>
                            {viewMode === 'detailed' && <div className="absolute left-8 top-0 bottom-0 w-px bg-white/10 z-0 md:left-20"></div>}

                            {viewMode === 'broad' ? (
                                <div className="relative pb-16">
                                    <div className="absolute left-6 top-0 bottom-0 w-px bg-white/10"></div>
                                    <div className="flex flex-col gap-5">
                                        {datedArticles.map((article) => (
                                            <div
                                                key={article.id}
                                                ref={el => el ? articleRefs.current.set(article.id, el) : articleRefs.current.delete(article.id)}
                                                onClick={() => {
                                                    if (onSelectArticle) onSelectArticle(article);
                                                    setCenteredArticleId(article.id);
                                                    setViewMode('detailed');
                                                    setTimeout(() => scrollToArticle(article.id), 100);
                                                }}
                                                className="relative pl-12"
                                            >
                                                <div className="absolute left-3 top-4 w-3 h-3 rounded-full bg-indigo-400 shadow-[0_0_0_4px_rgba(99,102,241,0.25)]"></div>
                                                <div className="bg-white/5 border border-white/10 rounded-lg p-4 cursor-pointer hover:bg-white/10 hover:border-indigo-500/50 transition group flex flex-col">
                                                    <div className="flex justify-between items-start mb-1">
                                                        <span className={`text-[10px] px-1.5 py-0.5 rounded ${ARTICLE_TYPES[article.type]?.color || 'bg-gray-700 text-gray-300'}`}>{ARTICLE_TYPES[article.type]?.label}</span>
                                                        <span className="text-[10px] text-yellow-500">{'★'.repeat(article.importance || 3)}</span>
                                                        <span className="font-mono text-indigo-300 text-xs font-bold">{getArticleYear(article)}</span>
                                                    </div>
                                                    <h3 className="text-sm font-bold text-white group-hover:text-indigo-300 line-clamp-2">{article.title}</h3>
                                                    <div className="text-[11px] text-white/50 mt-2 line-clamp-2" onClick={handleContentClick} dangerouslySetInnerHTML={{ __html: highlightHtml(transformContent(article.contentHtml || ''), searchState.keyword) }}></div>
                                                    <div className="text-[10px] text-white/40 mt-2 truncate">{article.dateStr}</div>
                                                </div>
                                            </div>
                                        ))}
                                    </div>
                                </div>
                            ) : (
                                <div className="flex flex-col gap-12 py-10">
                                    {displayArticles.map((article) => {
                                        const isActive = (focusedArticle?.id === article.id) || (centeredArticleId === article.id);
                                        return (
                                            <div key={article.id} data-article-id={article.id} ref={el => el ? articleRefs.current.set(article.id, el) : articleRefs.current.delete(article.id)} className="w-full flex flex-col relative box-border">
                                                <div className="w-full flex flex-col md:flex-row items-center md:items-center gap-0 z-10 relative">
                                                    <div className={`flex-1 w-full transition-all duration-500 ${isActive ? 'opacity-100 scale-100' : 'opacity-30 scale-95 grayscale'}`}>
                                                        <div className="text-left text-gray-800 rounded-2xl shadow-2xl overflow-hidden border-4 relative w-full bg-white border-white/10">
                                                            <div className="h-32 bg-gradient-to-r from-indigo-900 to-slate-800 p-6 flex items-end relative" onClick={() => { isJumpingRef.current = true; if (onSelectArticle) onSelectArticle(article); scrollToArticle(article.id); setTimeout(() => isJumpingRef.current = false, 500); }}>
                                                                <h1 className="text-2xl md:text-3xl font-bold text-white z-10 serif flex items-center gap-2">
                                                                    {article.title}
                                                                    {article.isApproved && <Icon name="check-circle" size={24} className="text-emerald-400" title="承認済み" />}
                                                                </h1>
                                                                <div className="absolute right-4 bottom-4 text-white/20"><Icon name={ARTICLE_TYPES[article.type]?.icon} size={80} /></div>
                                                                <button onClick={(e) => { e.stopPropagation(); copyText(article.id); }} className="absolute top-2 right-2 text-white/50 hover:text-white bg-black/20 px-2 py-1 rounded text-xs">ID: {article.id.slice(0, 4)}...</button>
                                                            </div>
                                                            <div className="p-6">
                                                                <div className="flex gap-2 text-xs text-gray-500 mb-4">
                                                                    <span className="bg-gray-100 px-2 py-1 rounded">{ARTICLE_TYPES[article.type]?.label}</span>
                                                                    <span className="font-mono text-indigo-600 font-bold bg-indigo-50 px-2 py-1 rounded">{article.dateStr || `Year: ${article.year}`}</span>
                                                                </div>
                                                                <div className="prose prose-sm max-w-none text-gray-800 mb-4" dangerouslySetInnerHTML={{ __html: highlightHtml(transformContent(article.contentHtml), searchState.keyword) }} onClick={handleContentClick}></div>
                                                                {article.mainImageUrl && <img src={article.mainImageUrl} className="w-full rounded-lg object-cover max-h-48 border" alt={article.title} />}
                                                                <div className="mt-4 pt-4 border-t flex justify-end gap-2">
                                                                    {isMember && <button onClick={(e) => { e.stopPropagation(); onEditArticle(article); }} className="flex items-center gap-1 text-xs text-gray-400 hover:text-indigo-600 border px-2 py-1 rounded hover:bg-gray-50"><Icon name="edit-2" size={12} /> 編集</button>}
                                                                    {isMember && <button onClick={(e) => { e.stopPropagation(); onDuplicateArticle && onDuplicateArticle(article); }} className="flex items-center gap-1 text-xs text-emerald-600 hover:text-emerald-800 border border-emerald-200 px-2 py-1 rounded hover:bg-emerald-50"><Icon name="copy" size={12} /> 複製</button>}
                                                                    {(myRole === 'owner' || myRole === 'admin') && <button onClick={(e) => { e.stopPropagation(); onDeleteArticle && onDeleteArticle(article); }} className="flex items-center gap-1 text-xs text-red-500 hover:text-red-700 border border-red-200 px-2 py-1 rounded hover:bg-red-50"><Icon name="trash-2" size={12} /> 削除</button>}
                                                                </div>
                                                            </div>
                                                        </div>
                                                        {isActive && (
                                                            <div className="mt-4 h-64 w-full rounded-xl overflow-hidden border border-white/20 relative bg-slate-800 shadow-lg animate-[fadeIn_0.3s_ease-out]">
                                                                <div className="absolute top-2 left-2 z-[500] text-[10px] font-bold text-black bg-white/80 px-2 py-0.5 rounded shadow backdrop-blur">LOCATION</div>
                                                                <MapView articles={[article]} worldData={worldData} highlightArticleId={article.id} appContextId={appContextId} showControls={false} />
                                                            </div>
                                                        )}
                                                    </div>
                                                    {isActive && (
                                                        <div className="flex flex-row items-center animate-[fadeIn_0.5s_ease-out] self-stretch md:self-auto w-full md:w-auto mt-8 md:mt-0">
                                                            <div className="hidden md:block w-12 h-px bg-white/30 shrink-0"></div>
                                                            <div className="w-full md:w-[320px] shrink-0 pl-0 md:pl-0 border-l-0 md:border-l border-white/30 py-4 relative">
                                                                <div className="hidden md:block absolute left-[-1px] top-1/2 w-2 h-2 bg-white rounded-full -translate-y-1/2 -translate-x-1/2 shadow-[0_0_10px_white]"></div>
                                                                <div className="mb-2 flex items-center gap-2 text-white/60 text-xs font-bold uppercase tracking-widest pl-8">関連マインドマップ</div>
                                                                <TagTimelineColumns tags={safeArray(article.tags)} articles={allArticles} onSelectArticle={(item) => handleJump(item)} onTagClick={(t) => { isJumpingRef.current = true; if (onSearchChange) onSearchChange({ tag: t }); }} selectedArticleId={article.id} isTreeMode={true} variant="light" />
                                                                {article.stats && article.stats.length > 0 && (
                                                                    <div className="bg-white/5 rounded-xl p-4 border border-white/10 ml-8 mt-4"><div className="text-xs font-bold text-white/50 mb-2 border-b border-white/10 pb-1">STATS</div>{article.stats.map((s, i) => (<div key={i} className="flex justify-between text-sm text-white/80 py-1"><span>{s.label}</span><span className="font-bold font-mono text-indigo-300">{s.value}</span></div>))}</div>
                                                                )}
                                                            </div>
                                                        </div>
                                                    )}
                                                </div>
                                            </div>
                                        );
                                    })}
                                </div>
                            )}
                        </div>
                    </div>
                </div>
            );
        };

        // --- SimpleLineChart & GraphView: 年表からの統計表示機能 (年表(1)から移植・簡易化)
        // 記事本文中の <table> を解析して「ステータス名 -> 数値」マップを返す（年は記事の年を使う）
        const parseTablesFromHtml = (html) => {
            if (!html) return {};
            try {
                const parser = new DOMParser();
                const doc = parser.parseFromString(html, 'text/html');
                const map = {}; // label -> summed value within article

                // 1) csv-block があれば優先して読み取る
                const csvBlocks = Array.from(doc.querySelectorAll('.csv-block'));
                if (csvBlocks.length > 0) {
                    csvBlocks.forEach(cb => {
                        const raw = cb.getAttribute('data-csv') || '';
                        const decoded = raw ? decodeURIComponent(raw) : '';
                        if (!decoded) return;
                        const rows = parseCSV(decoded, ',');
                        rows.forEach(r => {
                            if (r.length >= 2) {
                                const label = r[0];
                                const val = parseFloat((r[1] || '').replace(/[,\s]/g, ''));
                                if (label && !isNaN(val)) map[label] = (map[label] || 0) + Number(val);
                            }
                        });
                    });
                    return map;
                }

                // 2) 通常の <table> 要素をパース
                const tables = Array.from(doc.querySelectorAll('table'));
                tables.forEach((table) => {
                    const rows = Array.from(table.querySelectorAll('tr'));
                    rows.forEach((row) => {
                        const cells = Array.from(row.querySelectorAll('td,th')).map(c => c.textContent.trim());
                        if (cells.length >= 2) {
                            const label = cells[0];
                            const val = parseFloat(cells[1].replace(/[,\s]/g, ''));
                            if (label && !isNaN(val)) {
                                map[label] = (map[label] || 0) + Number(val);
                            }
                        }
                    });
                });
                return map;
            } catch (e) { return {}; }
        };





        const collectAllTags = (articles = []) => {
            const set = new Set();
            articles.forEach(a => safeArray(a.tags).forEach(t => t && set.add(t)));
            return Array.from(set).sort((a, b) => a.localeCompare(b));
        };

        // 記事内のスプレッドシートから指定されたセル値を取得するヘルパー関数
        // Helper to convert "A1" style cell coordinates to row/col indices (0-based)
        const cellToIndices = (cell) => {
            const match = cell.match(/([A-Z]+)([0-9]+)/);
            if (!match) return null;
            const colStr = match[1];
            const row = parseInt(match[2]) - 1;
            let col = 0;
            for (let i = 0; i < colStr.length; i++) {
                col = col * 26 + (colStr.charCodeAt(i) - 64);
            }
            return { row, col: col - 1 };
        };

        const fetchSheetDataForArticle = async (article, statusFieldMap, proxyUrl) => {
            const result = {};
            const content = article.contentHtml || '';
            const sheetMatch = content.match(/(?:\{\{googlesheet:|#googlesheet\().*?docs\.google\.com\/spreadsheets\/d\/([^\/,\}\)]+)/);
            if (!sheetMatch) return result;
            const spreadsheetId = sheetMatch[1];

            // 1. Try Proxy if available
            if (proxyUrl) {
                const cells = Object.values(statusFieldMap).join(',');
                return new Promise((resolve) => {
                    const callbackName = 'sheet_cb_' + Math.random().toString(36).substr(2, 9);
                    const timeout = setTimeout(() => { delete window[callbackName]; resolve({}); }, 10000); // 10s fallback
                    window[callbackName] = (res) => {
                        clearTimeout(timeout); delete window[callbackName];
                        const scriptEl = document.getElementById(callbackName);
                        if (scriptEl) scriptEl.remove();
                        if (res.status === 'success' && res.values) {
                            Object.entries(statusFieldMap).forEach(([statusName, cell]) => {
                                if (res.values[cell] !== undefined) {
                                    const numVal = parseFloat(res.values[cell]);
                                    if (!isNaN(numVal)) result[statusName] = numVal;
                                }
                            });
                        }
                        resolve(result);
                    };
                    const script = document.createElement('script');
                    script.id = callbackName;
                    const params = new URLSearchParams();
                    params.set('callback', callbackName);
                    params.set('action', 'getCellValues');
                    params.set('sheetId', spreadsheetId);
                    params.set('cells', cells);
                    script.src = `${proxyUrl}?${params.toString()}`;
                    document.body.appendChild(script);
                });
            }

            // 2. Fallback: Direct CSV Fetch (requires Public "Anyone with link" access)
            try {
                // Fetch CSV for GID 0 (first sheet) - default behavior
                const url = `https://docs.google.com/spreadsheets/d/${spreadsheetId}/gviz/tq?tqx=out:csv&gid=0`;
                const response = await fetch(url);
                if (!response.ok) throw new Error('Direct fetch failed');
                const csvText = await response.text();
                const rows = parseCSV(csvText, ',');

                Object.entries(statusFieldMap).forEach(([statusName, cell]) => {
                    const idx = cellToIndices(cell);
                    if (idx && rows[idx.row] && rows[idx.row][idx.col]) {
                        // Remove commas/spaces for number parsing
                        const raw = rows[idx.row][idx.col].replace(/[,\s]/g, '');
                        const numVal = parseFloat(raw);
                        if (!isNaN(numVal)) result[statusName] = numVal;
                    }
                });
            } catch (e) {
                console.warn(`Failed to fetch/parse sheet ${spreadsheetId} directly:`, e);
            }
            return result;
        };

        // articles: list, selectedTags: 条件タグ(複数), groupTag: 要素タグ（同一要素扱い）
        // statusA/statusB: 統計ステータス名（ラベル）
        // op: '+','-','*','/'
        const collectAllStatusLabels = (articles = [], worldData = null) => {
            const set = new Set();
            articles.forEach(a => {
                // from article.stats
                if (Array.isArray(a.stats)) a.stats.forEach(s => { if (s && s.label) set.add(String(s.label)); });
                // from tables
                const tableMap = parseTablesFromHtml(a.contentHtml || '');
                Object.keys(tableMap).forEach(k => set.add(k));
            });

            // 新規: tagToSheetMappings からステータスラベルを収集
            if (worldData?.tagToSheetMappings) {
                worldData.tagToSheetMappings.forEach(mapping => {
                    Object.keys(mapping.statusFieldMap || {}).forEach(statusName => {
                        set.add(statusName);
                    });
                });
            }

            return Array.from(set).sort((a, b) => a.localeCompare(b));
        };

        const aggregateSeriesByGroup = async (articles = [], selectedTags = [], groupTags = [], statusA = '', statusB = '', op = '+', worldData = null, useSpreadsheet = false) => {
            // filter by condition tags: if none selected include all, otherwise include articles that have ANY of the selectedTags
            const selected = articles.filter(a => {
                if (!selectedTags || selectedTags.length === 0) return true;
                const tags = safeArray(a.tags).map(t => String(t));
                return selectedTags.some(st => tags.includes(st));
            });

            // prepare per-article status map: label -> numeric value
            const perArticle = await Promise.all(selected.map(async (a) => {
                const year = Math.floor(getArticleYear(a));
                const map = {};
                // stats array
                if (Array.isArray(a.stats)) {
                    a.stats.forEach(s => {
                        const lbl = s.label || s.name || '';
                        const v = parseFloat(s.value || s.v || s.gdp || s.population || NaN);
                        if (lbl && !isNaN(v)) map[String(lbl)] = (map[String(lbl)] || 0) + Number(v);
                    });
                }
                // tables
                const tableMap = parseTablesFromHtml(a.contentHtml || '');
                Object.keys(tableMap).forEach(k => { map[k] = (map[k] || 0) + Number(tableMap[k]); });

                // 新規: タグベースのスプレッドシート連携
                const articleTags = safeArray(a.tags);
                if (useSpreadsheet && worldData?.tagToSheetMappings) {
                    for (const tagMapping of worldData.tagToSheetMappings) {
                        if (articleTags.includes(tagMapping.tag)) {
                            // この記事がマッピング対象タグを持っている
                            try {
                                const sheetData = await fetchSheetDataForArticle(a, tagMapping.statusFieldMap, worldData.spreadsheetProxyUrl);
                                Object.assign(map, sheetData);
                            } catch (e) {
                                console.error(`Failed to fetch sheet data for article ${a.id}:`, e);
                            }
                            break; // 最初にマッチしたマッピングのみ適用
                        }
                    }
                }

                return { article: a, year, map };
            }));

            // grouping: support multiple groupTags (element tags). If groupTags provided, only create groups for those tags
            const groups = new Map();
            const useGroupTags = Array.isArray(groupTags) && groupTags.length > 0;
            perArticle.forEach(({ article, year, map }) => {
                const tags = safeArray(article.tags).map(t => String(t));
                if (useGroupTags) {
                    groupTags.forEach(gt => {
                        if (tags.includes(gt)) {
                            const key = gt;
                            if (!groups.has(key)) groups.set(key, new Map());
                            const yearMap = groups.get(key);
                            if (!yearMap.has(year)) yearMap.set(year, { A: 0, B: 0 });
                            const entry = yearMap.get(year);
                            if (statusA) entry.A += Number(map[statusA] || 0);
                            if (statusB) entry.B += Number(map[statusB] || 0);
                        }
                    });
                } else {
                    const key = (article.representedTag || article.title || article.id);
                    if (!groups.has(key)) groups.set(key, new Map());
                    const yearMap = groups.get(key);
                    if (!yearMap.has(year)) yearMap.set(year, { A: 0, B: 0 });
                    const entry = yearMap.get(year);
                    if (statusA) entry.A += Number(map[statusA] || 0);
                    if (statusB) entry.B += Number(map[statusB] || 0);
                }
            });

            // build series per group applying operator
            const series = [];
            groups.forEach((yearMap, key) => {
                const points = [];
                Array.from(yearMap.entries()).sort((a, b) => a[0] - b[0]).forEach(([year, vals]) => {
                    let value = null;
                    const A = vals.A || 0; const B = vals.B || 0;
                    if (statusA && statusB) {
                        switch (op) {
                            case '+': value = A + B; break;
                            case '-': value = A - B; break;
                            case '*': value = A * B; break;
                            case '/': value = B === 0 ? null : A / B; break;
                            default: value = A + B;
                        }
                    } else if (statusA) { value = A; }
                    else if (statusB) { value = B; }
                    if (value !== null) points.push({ year: Number(year), value: Number(value) });
                });
                series.push({ key, points });
            });
            return series;
        };

        const SimpleChart = ({ width = "100%", height = 300, series = [], type = 'line', formatValue = (v) => String(v) }) => {
            if (!series || series.length === 0) return <div className="bg-white p-6 rounded shadow text-center text-gray-400">データがありません</div>;
            // collect years
            const yearsSet = new Set();
            let maxVal = 0;
            series.forEach(s => s.points.forEach(p => { yearsSet.add(p.year); if (p.value > maxVal) maxVal = p.value; }));
            const years = Array.from(yearsSet).sort((a, b) => a - b);
            if (years.length === 0) return <div className="bg-white p-6 rounded shadow text-center text-gray-400">データ不足</div>;

            // Layout constants
            const padding = { l: 60, r: 20, t: 20, b: 40 };
            const svgWidth = 800; // internal coordinate system width
            const gw = svgWidth - padding.l - padding.r;
            const gh = height - padding.t - padding.b;

            const getX = (y) => padding.l + (years.indexOf(y) / (years.length - 1 || 1)) * gw;
            const getY = (v) => padding.t + gh - ((v / (maxVal || 1)) * gh);
            const colors = ['#3b82f6', '#ef4444', '#10b981', '#f59e0b', '#8b5cf6', '#06b6d4', '#ec4899', '#6366f1'];

            // Y-axis ticks
            const yTicksCount = 5;
            const yTicks = Array.from({ length: yTicksCount }).map((_, i) => {
                const val = maxVal * (1 - i / (yTicksCount - 1));
                if (Math.abs(val) >= 1000) return Math.round(val);
                return Math.round(val * 100) / 100;
            });

            return (
                <div className="flex flex-col w-full">
                    {/* LEGEND - Moved to Top for better visibility */}
                    <div className="flex flex-wrap gap-4 mb-4 justify-center">
                        {series.map((s, si) => (
                            <div key={s.key} className="flex items-center gap-1.5 text-xs font-bold text-gray-600">
                                <span className="w-3 h-3 rounded-full" style={{ backgroundColor: colors[si % colors.length] }}></span>
                                {s.key}
                            </div>
                        ))}
                    </div>

                    <div className="w-full overflow-x-auto">
                        <svg viewBox={`0 0 ${svgWidth} ${height}`} className="w-full min-w-[600px] h-auto bg-white rounded-lg" style={{ maxHeight: '400px' }}>
                            <rect x="0" y="0" width={svgWidth} height={height} fill="transparent" />
                            {/* grid & Y-axis */}
                            {Array.from({ length: yTicksCount }).map((_, i) => {
                                const y = padding.t + (gh / (yTicksCount - 1)) * i;
                                const tickVal = yTicks[i];
                                return (
                                    <g key={`yg_${i}`}>
                                        <line x1={padding.l} x2={svgWidth - padding.r} y1={y} y2={y} stroke="#eee" />
                                        <text x={padding.l - 8} y={y + 4} fontSize="11" textAnchor="end" fill="#9ca3af">{formatValue(tickVal)}</text>
                                    </g>
                                );
                            })}

                            {/* X-axis labels (render fewer if many years) */}
                            {years.map((y, i) => {
                                // show all if few, or every Nth if many
                                const skip = years.length > 20 ? Math.ceil(years.length / 10) : 1;
                                if (i % skip !== 0 && i !== years.length - 1) return null;
                                return <text key={y} x={getX(y)} y={height - 10} fontSize="11" textAnchor="middle" fill="#6b7280">{y}</text>;
                            })}

                            {/* Data */}
                            {type === 'line' ? (
                                series.map((s, si) => {
                                    const d = s.points.map((p, idx) => `${idx === 0 ? 'M' : 'L'} ${getX(p.year)} ${getY(p.value)}`).join(' ');
                                    const color = colors[si % colors.length];
                                    return <path key={s.key} d={d} fill="none" stroke={color} strokeWidth={3} strokeLinejoin="round" strokeLinecap="round" />;
                                })
                            ) : (
                                series.map((s, si) => {
                                    const color = colors[si % colors.length];
                                    const totalBars = series.length;
                                    const availableWidth = (gw / (years.length - 1 || 1)) * 0.7; // 70% of gap
                                    const barWidth = Math.max(2, Math.min(20, availableWidth / totalBars));
                                    const offset = (si - (totalBars - 1) / 2) * barWidth;

                                    return (
                                        <g key={s.key}>
                                            {s.points.map((p) => {
                                                const x = getX(p.year) + offset - barWidth / 2;
                                                const y = getY(p.value);
                                                const h = Math.max(0, padding.t + gh - y);
                                                return <rect key={p.year} x={x} y={y} width={barWidth} height={h} fill={color} opacity={0.85} rx={1} />;
                                            })}
                                        </g>
                                    );
                                })
                            )}
                        </svg>
                    </div>
                </div>
            );
        };


        const fetchSpreadsheetData = async (spreadsheetId, gid, range) => {
            if (!spreadsheetId) return null;
            const sheetId = gid || '0';
            const rangeParam = range ? `&range=${encodeURIComponent(range)}` : '';
            const url = `https://docs.google.com/spreadsheets/d/${spreadsheetId}/gviz/tq?tqx=out:csv&gid=${sheetId}${rangeParam}`;

            try {
                const response = await fetch(url);
                if (!response.ok) throw new Error(`Fetch failed: ${response.statusText}`);
                const csvText = await response.text();
                return parseCSV(csvText, ',');
            } catch (err) {
                console.error("Spreadsheet Fetch Error:", err);
                const fallbackUrl = `https://docs.google.com/spreadsheets/d/${spreadsheetId}/export?format=csv&gid=${sheetId}${rangeParam}`;
                try {
                    const res2 = await fetch(fallbackUrl);
                    if (res2.ok) return parseCSV(await res2.text(), ',');
                } catch (e) { }
                alert("スプレッドシートの取得に失敗しました。公開設定（リンクを知っている全員）を確認してください。");
                return null;
            }
        };

        const parseSpreadsheetCSVToSeries = (rows) => {
            if (!rows || rows.length < 1) return [];
            let yearCol = -1;
            let headerRowIndex = -1;
            const yearRegex = /記録年|年代|年份|Year|Time|Date/i;
            for (let i = 0; i < Math.min(rows.length, 20); i++) {
                const row = rows[i];
                const idx = row.findIndex(c => yearRegex.test(c));
                if (idx >= 0) { yearCol = idx; headerRowIndex = i; break; }
            }
            if (yearCol === -1) {
                yearCol = 0;
                if (rows.length > 0 && isNaN(parseFloat(rows[0][0]))) headerRowIndex = 0;
            }
            const seriesMap = {};
            const headers = (headerRowIndex >= 0) ? rows[headerRowIndex] : [];
            const startRow = (headerRowIndex >= 0) ? headerRowIndex + 1 : 0;
            for (let i = startRow; i < rows.length; i++) {
                const row = rows[i];
                if (!row || row.length <= yearCol) continue;
                const yVal = parseFloat((row[yearCol] || '').replace(/[,\s]/g, ''));
                if (isNaN(yVal)) continue;
                row.forEach((cell, colIdx) => {
                    if (colIdx === yearCol) return;
                    const val = parseFloat((cell || '').replace(/[,\s]/g, ''));
                    if (!isNaN(val)) {
                        const key = headers[colIdx] || `Column ${colIdx + 1}`;
                        if (!seriesMap[key]) seriesMap[key] = [];
                        seriesMap[key].push({ year: yVal, value: val });
                    }
                });
            }
            return Object.keys(seriesMap).map(k => ({ key: k, points: seriesMap[k].sort((a, b) => a.year - b.year) }));
        };

        const GraphView = ({ setView, articles = [], worldData, worldId, appContextId, db, canIApprove }) => {
            const [conditionTags, setConditionTags] = React.useState([]);
            const [elementTags, setElementTags] = React.useState([]);
            const [statusA, setStatusA] = React.useState('');
            const [statusB, setStatusB] = React.useState('');
            const [op, setOp] = React.useState('+');
            const [series, setSeries] = React.useState([]);
            const [loading, setLoading] = React.useState(false);

            // Spreadsheet Integration
            const [useSpreadsheet, setUseSpreadsheet] = React.useState(false);
            const [tagMappings, setTagMappings] = React.useState(worldData?.tagToSheetMappings || []);
            const [showTagMappings, setShowTagMappings] = React.useState(false);

            // Graph Type
            const [graphType, setGraphType] = React.useState('line'); // 'line' | 'bar'

            const tags = collectAllTags(articles);
            const statuses = collectAllStatusLabels(articles, worldData);

            const [tagSearchQuery, setTagSearchQuery] = React.useState('');
            const filteredTags = tags.filter(t => t.toLowerCase().includes(tagSearchQuery.toLowerCase()));

            const toggleConditionTag = (t) => setConditionTags(prev => prev.includes(t) ? prev.filter(x => x !== t) : [...prev, t]);
            const toggleElementTag = (t) => setElementTags(prev => prev.includes(t) ? prev.filter(x => x !== t) : [...prev, t]);

            const runAggregate = async () => {
                if (!statusA && !statusB) { alert('少なくとも1つの統計ステータスを選択してください'); return; }
                setLoading(true);
                try {
                    const s = await aggregateSeriesByGroup(articles, conditionTags, elementTags, statusA, statusB, op, worldData, useSpreadsheet);
                    setSeries(s);
                } catch (e) {
                    console.error("Aggregation Error:", e);
                    alert("解析中にエラーが発生しました");
                } finally {
                    setLoading(false);
                }
            };

            const addNewTagMapping = () => {
                setTagMappings([...tagMappings, { tag: '', statusFieldMap: {} }]);
            };

            const removeTagMapping = (index) => {
                setTagMappings(tagMappings.filter((_, i) => i !== index));
            };

            const updateTagMappingTag = (index, newTag) => {
                const updated = [...tagMappings];
                updated[index] = { ...updated[index], tag: newTag };
                setTagMappings(updated);
            };

            const addStatusMapping = (mappingIndex) => {
                const updated = [...tagMappings];
                const statusMap = updated[mappingIndex].statusFieldMap || {};
                const newKey = `ステータス${Object.keys(statusMap).length + 1}`;
                updated[mappingIndex] = {
                    ...updated[mappingIndex],
                    statusFieldMap: { ...statusMap, [newKey]: 'A1' }
                };
                setTagMappings(updated);
            };

            const removeStatusMapping = (mappingIndex, statusName) => {
                const updated = [...tagMappings];
                const statusMap = { ...updated[mappingIndex].statusFieldMap };
                delete statusMap[statusName];
                updated[mappingIndex] = {
                    ...updated[mappingIndex],
                    statusFieldMap: statusMap
                };
                setTagMappings(updated);
            };

            const updateStatusMapping = (mappingIndex, oldStatusName, newStatusName, newCell) => {
                const updated = [...tagMappings];
                const statusMap = { ...updated[mappingIndex].statusFieldMap };
                if (newStatusName !== oldStatusName) {
                    delete statusMap[oldStatusName];
                }
                statusMap[newStatusName] = newCell;
                updated[mappingIndex] = {
                    ...updated[mappingIndex],
                    statusFieldMap: statusMap
                };
                setTagMappings(updated);
            };

            const handleSaveTagMappings = async () => {
                if (!canIApprove) return;
                const { updateDoc, doc } = window.firebaseModules;
                try {
                    await updateDoc(doc(db, 'artifacts', appContextId, 'public', 'data', 'worlds', worldId), {
                        tagToSheetMappings: tagMappings
                    });
                    alert('タグマッピング設定を保存しました');
                    setShowTagMappings(false);
                } catch (e) { alert("保存失敗: " + e.message); }
            };

            return (
                <div className="space-y-6 p-6 animate-[fadeIn_0.2s_ease-out]">
                    <div className="flex items-center justify-between">
                        <div className="flex items-center gap-4">
                            <button onClick={() => setView('timeline_large')} className="flex items-center gap-2 px-3 py-2 bg-white text-gray-700 rounded border shadow-sm hover:bg-gray-50 transition-colors">
                                <Icon name="arrow-left" size={16} /> 年表へ戻る
                            </button>
                            <h2 className="text-xl font-bold flex items-center gap-2">
                                <Icon name="bar-chart-2" className="text-indigo-600" /> 統計ビュー
                            </h2>
                        </div>


                        <div className="bg-white p-4 rounded shadow grid grid-cols-1 md:grid-cols-3 gap-4 border border-gray-100">
                            <div className="col-span-1 md:col-span-3 mb-2">
                                <input
                                    type="text"
                                    placeholder="タグを検索..."
                                    value={tagSearchQuery}
                                    onChange={e => setTagSearchQuery(e.target.value)}
                                    className="w-full border px-3 py-1.5 rounded text-sm bg-gray-50 focus:bg-white focus:outline-none focus:ring-2 focus:ring-indigo-500"
                                />
                            </div>

                            <div className="col-span-1 md:col-span-3">
                                <div className="text-sm font-bold mb-2 flex items-center gap-2 text-gray-700">
                                    <Icon name="tag" size={14} className="text-indigo-500" /> 条件タグ
                                    <span className="text-[10px] font-normal text-gray-400">（これらのタグを持つ記事が集計対象になります。複数選択可）</span>
                                </div>
                                <div className="flex flex-wrap gap-1.5 max-h-40 overflow-y-auto custom-scrollbar p-1 border rounded bg-gray-50/50">
                                    {filteredTags.map(t => (
                                        <button
                                            key={t}
                                            onClick={() => toggleConditionTag(t)}
                                            className={`px-2.5 py-1 text-xs rounded-full font-bold transition-all ${conditionTags.includes(t) ? 'bg-indigo-600 text-white shadow-sm' : 'bg-indigo-50 text-indigo-600 hover:bg-indigo-100'}`}
                                        >
                                            #{t}
                                        </button>
                                    ))}
                                    {filteredTags.length === 0 && <span className="text-xs text-gray-400 p-2">タグが見つかりません</span>}
                                </div>
                            </div>

                            <div className="col-span-1 md:col-span-3">
                                <div className="text-sm font-bold mb-2 flex items-center gap-2 text-gray-700">
                                    <Icon name="tags" size={14} className="text-indigo-500" /> 要素タグ
                                    <span className="text-[10px] font-normal text-gray-400">（これらを同一要素として扱い比較します。複数選択可）</span>
                                </div>
                                <div className="flex flex-wrap gap-1.5 max-h-40 overflow-y-auto custom-scrollbar p-1 border rounded bg-gray-50/50">
                                    {filteredTags.map(t => (
                                        <button
                                            key={t}
                                            onClick={() => toggleElementTag(t)}
                                            className={`px-2.5 py-1 text-xs rounded-full font-bold transition-all ${elementTags.includes(t) ? 'bg-indigo-600 text-white shadow-sm' : 'bg-indigo-50 text-indigo-600 hover:bg-indigo-100'}`}
                                        >
                                            #{t}
                                        </button>
                                    ))}
                                    {filteredTags.length === 0 && <span className="text-xs text-gray-400">タグが見つかりません</span>}
                                </div>
                            </div>

                            <div className="space-y-1">
                                <div className="text-xs font-bold text-gray-500">統計ステータス A</div>
                                <select className="w-full border p-2 rounded text-sm bg-gray-50 bg-white" value={statusA} onChange={e => setStatusA(e.target.value)}>
                                    <option value="">-- 未選択 --</option>
                                    {statuses.map(s => <option key={s} value={s}>{s}</option>)}
                                </select>
                            </div>
                            <div className="space-y-1">
                                <div className="text-xs font-bold text-gray-500">統計ステータス B</div>
                                <select className="w-full border p-2 rounded text-sm bg-gray-50 bg-white" value={statusB} onChange={e => setStatusB(e.target.value)}>
                                    <option value="">-- 未選択 --</option>
                                    {statuses.map(s => <option key={s} value={s}>{s}</option>)}
                                </select>
                            </div>

                            <div className="space-y-1">
                                <div className="text-xs font-bold text-gray-500">演算子 (A op B)</div>
                                <select className="w-full border p-2 rounded text-sm bg-gray-50 bg-white" value={op} onChange={e => setOp(e.target.value)}>
                                    <option value="+">A + B</option>
                                    <option value="-">A - B</option>
                                    <option value="*">A × B</option>
                                    <option value="/">A ÷ B</option>
                                </select>
                            </div>
                        </div>

                        <div className="flex flex-wrap gap-3 items-center">
                            <button
                                onClick={runAggregate}
                                disabled={loading}
                                className={`px-6 py-2 rounded font-bold text-white shadow-md transition-all flex items-center gap-2 whitespace-nowrap ${loading ? 'bg-gray-400' : 'bg-indigo-600 hover:bg-indigo-700 hover:-translate-y-0.5'}`}
                            >
                                {loading ? <Icon name="loader" size={18} className="animate-spin" /> : <Icon name="play" size={18} />}
                                解析を実行
                            </button>

                            {/* Graph Type Toggle */}
                            <div className="flex items-center bg-gray-100 rounded p-1 border border-gray-200">
                                <button
                                    onClick={() => setGraphType('line')}
                                    className={`p-1.5 rounded transition-all ${graphType === 'line' ? 'bg-white text-indigo-600 shadow-sm' : 'text-gray-400 hover:text-gray-600'}`}
                                    title="折れ線グラフ"
                                >
                                    <Icon name="trending-up" size={16} />
                                </button>
                                <button
                                    onClick={() => setGraphType('bar')}
                                    className={`p-1.5 rounded transition-all ${graphType === 'bar' ? 'bg-white text-indigo-600 shadow-sm' : 'text-gray-400 hover:text-gray-600'}`}
                                    title="棒グラフ"
                                >
                                    <Icon name="bar-chart-2" size={16} />
                                </button>
                            </div>

                            <label className="flex items-center gap-2 text-sm text-gray-700 select-none bg-white px-3 py-2 rounded border border-gray-200 shadow-sm cursor-pointer hover:bg-gray-50 whitespace-nowrap">
                                <input type="checkbox" checked={useSpreadsheet} onChange={e => setUseSpreadsheet(e.target.checked)} className="rounded text-indigo-600 focus:ring-indigo-500" />
                                <Icon name="table" size={16} className={useSpreadsheet ? "text-indigo-600" : "text-gray-400"} />
                                スプレッドシート連携
                            </label>

                            {canIApprove && useSpreadsheet && (
                                <button onClick={() => setShowTagMappings(true)} className="p-2 text-gray-500 rounded hover:bg-gray-100 hover:text-indigo-600 transition-colors" title="連携設定">
                                    <Icon name="settings" size={20} />
                                </button>
                            )}

                            <button
                                onClick={() => { setConditionTags([]); setElementTags([]); setStatusA(''); setStatusB(''); setOp('+'); setSeries([]); }}
                                className="ml-auto px-4 py-2 border rounded font-bold text-gray-500 hover:bg-gray-50 transition-colors whitespace-nowrap"
                            >
                                リセット
                            </button>
                        </div>

                        {series.length === 0 && (
                            <div className="text-sm text-gray-500 mt-4 p-8 border-2 border-dashed border-gray-100 rounded-lg text-center bg-gray-50/50">
                                {series.length === 0 && "条件を選択して「解析を実行」ボタンを押すと、各記事の年代を X 軸としてステータスを集計したグラフが表示されます。"}
                            </div>
                        )}

                        <div className="bg-white p-4 rounded-xl shadow-inner border border-gray-100">
                            <SimpleChart series={series} type={graphType} />
                        </div>
                        {/* Tag Mapping Config Modal */}
                        {showTagMappings && (
                            <div className="fixed inset-0 bg-black/50 z-50 flex items-center justify-center p-4" onClick={() => setShowTagMappings(false)}>
                                <div className="bg-white rounded-lg p-6 max-w-2xl w-full max-h-[80vh] overflow-y-auto" onClick={e => e.stopPropagation()}>
                                    <h3 className="text-lg font-bold mb-4">タグ連携設定 (スプレッドシート自動取得)</h3>
                                    <p className="text-sm text-gray-500 mb-4">
                                        指定したタグを持つ記事に対して、埋め込まれたスプレッドシートから自動的にセル値を取得し、統計ステータスとして利用できるようにします。
                                    </p>

                                    <div className="space-y-4 mb-6">
                                        {tagMappings.map((tm, idx) => (
                                            <div key={idx} className="border rounded p-4 bg-gray-50 relative">
                                                <button onClick={() => removeTagMapping(idx)} className="absolute top-2 right-2 text-gray-400 hover:text-red-500">
                                                    <Icon name="x" size={16} />
                                                </button>

                                                <div className="flex items-center gap-2 mb-3">
                                                    <label className="text-sm font-bold w-20">タグ名:</label>
                                                    <input
                                                        type="text"
                                                        value={tm.tag}
                                                        onChange={e => updateTagMappingTag(idx, e.target.value)}
                                                        placeholder="例: 国家"
                                                        className="border px-2 py-1 rounded text-sm flex-1"
                                                    />
                                                </div>

                                                <div className="pl-4 border-l-2 border-indigo-200">
                                                    <div className="text-xs font-bold text-gray-500 mb-2">ステータスとセルの対応</div>
                                                    {Object.entries(tm.statusFieldMap || {}).map(([status, cell], sIdx) => (
                                                        <div key={sIdx} className="flex items-center gap-2 mb-2">
                                                            <input
                                                                value={status}
                                                                onChange={e => updateStatusMapping(idx, status, e.target.value, cell)}
                                                                placeholder="ステータス名"
                                                                className="border px-2 py-1 rounded text-xs w-1/3"
                                                            />
                                                            <span className="text-gray-400">→</span>
                                                            <input
                                                                value={cell}
                                                                onChange={e => updateStatusMapping(idx, status, status, e.target.value)}
                                                                placeholder="セル (例: B2)"
                                                                className="border px-2 py-1 rounded text-xs w-20 font-mono"
                                                            />
                                                            <button onClick={() => removeStatusMapping(idx, status)} className="text-red-400 hover:text-red-600">
                                                                <Icon name="trash-2" size={12} />
                                                            </button>
                                                        </div>
                                                    ))}
                                                    <button onClick={() => addStatusMapping(idx)} className="text-xs text-indigo-600 hover:text-indigo-800 flex items-center gap-1 mt-1">
                                                        <Icon name="plus" size={12} /> ステータス追加
                                                    </button>
                                                </div>
                                            </div>
                                        ))}

                                        <button onClick={addNewTagMapping} className="w-full py-2 border-2 border-dashed border-gray-300 text-gray-500 rounded hover:bg-gray-50 hover:border-gray-400 transition-colors flex items-center justify-center gap-2">
                                            <Icon name="plus" size={16} /> 新しいタグ設定を追加
                                        </button>
                                    </div>

                                    <div className="flex justify-end gap-2 pt-4 border-t">
                                        <button onClick={() => setShowTagMappings(false)} className="px-4 py-2 text-gray-600 hover:bg-gray-100 rounded">キャンセル</button>
                                        <button onClick={handleSaveTagMappings} className="px-4 py-2 bg-indigo-600 text-white rounded font-bold hover:bg-indigo-700">設定を保存</button>
                                    </div>
                                </div>
                            </div>
                        )}
                    </div>
                </div>
            );
        };

        // --- AdjacentArticlePreview (Not used but kept for compatibility) ---
        const AdjacentArticlePreview = () => null;

        // --- ArticleDetailPanel (Not used in new integrated view but kept for compatibility) ---
        const ArticleDetailPanel = () => null;

        const App = () => {
            const { db, auth, storage, user, loading, error, activeConfig, appContextId } = useFirebase();
            const [viewMode, setViewMode] = React.useState('world_select');
            const [worldId, setWorldId] = React.useState(null);
            const [worldData, setWorldData] = React.useState(null);
            const [articles, setArticles] = React.useState([]);
            const [selectedArticle, setSelectedArticle] = React.useState(null);
            const [formData, setFormData] = React.useState(createEmptyArticle());
            const [mapTabQuery, setMapTabQuery] = React.useState('');
            const [stats, setStats] = React.useState([]);
            const [tagInput, setTagInput] = React.useState('');
            const [mapTabImportance, setMapTabImportance] = React.useState(0);
            const [authMode, setAuthMode] = React.useState('login');
            const [authForm, setAuthForm] = React.useState({ username: '', password: '', worldName: '', worldDesc: '' });
            const [showConfigEditor, setShowConfigEditor] = React.useState(false);
            const [showMemberManager, setShowMemberManager] = React.useState(false);
            const [showAdminPanel, setShowAdminPanel] = React.useState(false);
            const [showRegionRuleEditor, setShowRegionRuleEditor] = React.useState(false);
            const [myMemberData, setMyMemberData] = React.useState(null);
            const [authError, setAuthError] = React.useState(null);
            const [timelineFilters, setTimelineFilters] = React.useState({ type: 'all', keyword: '', tag: '', excludeNoYear: true, onlyApproved: false });

            const [tagArticleInput, setTagArticleInput] = React.useState('');
            const [previousViewMode, setPreviousViewMode] = React.useState('timeline_large'); // 編集前のビューモードを記憶
            const isRestoringFromURL = React.useRef(false);
            const hasCheckedWorldURL = React.useRef(false); // URL復元中のフラグ
            const hasRedirectedToMain = React.useRef(false); // メインページへの自動遷移フラグ

            const hasRestoredFromURL = React.useRef(false); // URLからの復元完了フラグ (articles更新による再実行防止)

            // メインページへの自動遷移（世界選択時のみ）
            React.useEffect(() => {
                if (worldId) {
                    hasRedirectedToMain.current = false;
                    hasRestoredFromURL.current = false;
                }
            }, [worldId]);

            React.useEffect(() => {
                if (!hasRedirectedToMain.current && worldData?.mainPageId && articles.length > 0 && viewMode === 'timeline_large') {
                    // URL復元中や、すでに特定の場所が指定されている場合は行わない
                    const params = new URLSearchParams(window.location.search);
                    if (!params.get('view') && !params.get('article') && !params.get('tag') && !params.get('keyword')) {
                        const mainArt = articles.find(a => a.id === worldData.mainPageId);
                        if (mainArt) {
                            hasRedirectedToMain.current = true;
                            setSelectedArticle(mainArt);
                            setViewMode('single_article');
                            console.log('Redirecting to main page:', mainArt.title);
                        }
                    } else {
                        hasRedirectedToMain.current = true;
                    }
                }
            }, [worldData, articles, viewMode]);


            // Expose setViewMode to window for deep component access (hacky but effective for current structure)
            React.useEffect(() => { window.setAppViewMode = setViewMode; return () => delete window.setAppViewMode; }, []);

            // これにより、エディタの参照を保持
            const editorRef = React.useRef(null);
            const htmlTextareaRef = React.useRef(null);

            React.useEffect(() => {
                if (!user || !db || hasCheckedWorldURL.current) return;
                const params = new URLSearchParams(window.location.search);
                const urlWorldId = params.get('world');
                if (urlWorldId) {
                    hasCheckedWorldURL.current = true;
                    isRestoringFromURL.current = true;
                    setWorldId(urlWorldId);
                    setViewMode('timeline_large');
                    console.log('URL復元: 世界選択', urlWorldId);
                } else {
                    hasCheckedWorldURL.current = true;
                }
            }, [user, db]);

            // URLから状態を復元（初回読み込み時）
            React.useEffect(() => {
                // hasRestoredFromURL.current が true なら、articlesが更新されても再実行しない
                if (!user || !worldId || articles.length === 0 || isRestoringFromURL.current || hasRestoredFromURL.current) return;

                const params = new URLSearchParams(window.location.search);
                const urlView = params.get('view');
                const urlArticleId = params.get('article');
                const urlKeyword = params.get('keyword');
                const urlTag = params.get('tag');
                const urlMapQuery = params.get('mapQuery');
                const urlMapImportance = params.get('mapImportance');

                let updated = false;

                if (urlArticleId) {
                    // 記事IDが指定されている場合、その記事を表示
                    const article = articles.find(a => a.id === urlArticleId);
                    if (article) {
                        isRestoringFromURL.current = true;
                        setSelectedArticle(article);
                        if (urlView) setViewMode(urlView);
                        else setViewMode('single_article');
                        console.log('URL復元: 記事表示', article.title, urlView);
                        updated = true;
                    }
                } else if (urlView && urlView !== viewMode) {
                    // ビューモードのみ指定されている場合
                    isRestoringFromURL.current = true;
                    setViewMode(urlView);
                    console.log('URL復元: ビューモード', urlView);
                    updated = true;
                }

                if (urlKeyword || urlTag) {
                    setTimelineFilters(prev => ({ ...prev, keyword: urlKeyword || '', tag: urlTag || '' }));
                    console.log('URL復元: 検索条件', { keyword: urlKeyword, tag: urlTag });
                    updated = true;
                }

                // 年代なしフィルタ状態を復元
                if (params.has('excludeNoYear')) {
                    const excludeNoYear = params.get('excludeNoYear') === 'true';
                    setTimelineFilters(prev => ({ ...prev, excludeNoYear }));
                    console.log('URL復元: 年代なしフィルタ', excludeNoYear);
                    updated = true;
                }

                if (urlMapQuery) {
                    setMapTabQuery(urlMapQuery);
                    console.log('URL復元: マップクエリ', urlMapQuery);
                    updated = true;
                }

                if (urlMapImportance) {
                    setMapTabImportance(Number(urlMapImportance));
                    console.log('URL復元: マップ重要度', urlMapImportance);
                    updated = true;
                }

                // 復元処理完了としてマーク
                hasRestoredFromURL.current = true;

                // もしURLパラメータが何もなく、updated=falseだった場合でも、
                // これ以上このeffectを走らせないために hasRestoredFromURL は true にする
            }, [user, worldId, articles]);

            // 状態が変更されたらURLを更新（ブラウザの履歴に追加）
            React.useEffect(() => {
                if (!worldId || !user || isRestoringFromURL.current) {
                    isRestoringFromURL.current = false;
                    return;
                }

                const timeoutId = setTimeout(() => {
                    const params = new URLSearchParams();
                    params.set('world', worldId);
                    params.set('view', viewMode);

                    if (selectedArticle) {
                        params.set('article', selectedArticle.id);
                    }

                    if (timelineFilters.keyword) {
                        params.set('keyword', timelineFilters.keyword);
                    }
                    if (timelineFilters.tag) {
                        params.set('tag', timelineFilters.tag);
                    }

                    // 年代なしフィルタ状態もURLに含める
                    if (timelineFilters.excludeNoYear !== undefined) {
                        params.set('excludeNoYear', timelineFilters.excludeNoYear.toString());
                    }

                    if (viewMode === 'map' && mapTabQuery) {
                        params.set('mapQuery', mapTabQuery);
                    }
                    if (viewMode === 'map' && mapTabImportance > 0) {
                        params.set('mapImportance', mapTabImportance.toString());
                    }

                    const newUrl = `${window.location.pathname}?${params.toString()}`;
                    const currentUrl = `${window.location.pathname}${window.location.search}`;

                    if (newUrl !== currentUrl) {
                        window.history.pushState({ viewMode, worldId, articleId: selectedArticle?.id }, '', newUrl);
                        console.log('URL更新:', newUrl);
                    }
                }, 1000);

                return () => clearTimeout(timeoutId);
            }, [viewMode, selectedArticle, worldId, user]);

            // Global Wiki Link Click Handler
            React.useEffect(() => {
                const handleGlobalClick = (e) => {
                    const link = e.target.closest('.wiki-link');
                    if (link) {
                        e.preventDefault();
                        e.stopPropagation();
                        const id = link.getAttribute('data-article-id');
                        const wikiTitle = link.getAttribute('data-wiki-title');

                        if (id) {
                            const target = articles.find(a => a.id === id);
                            if (target) openDetailView(target);
                            else alert('記事が見つかりません');
                        } else if (wikiTitle) {
                            if (wikiTitle === '年代なし') {
                                setViewMode('timeline_noyear');
                            } else {
                                const target = articles.find(a => (a.title || '').trim() === wikiTitle.trim());
                                if (target) openDetailView(target);
                                else alert('記事が見つかりません');
                            }
                        }
                    }
                };
                document.addEventListener('click', handleGlobalClick);
                return () => document.removeEventListener('click', handleGlobalClick);
            }, [articles]);

            // Expose openArticleById globally
            React.useEffect(() => {
                window.openArticleById = (idOrTitle) => {
                    if (!idOrTitle) return;
                    const target = articles.find(a => a.id === idOrTitle) || articles.find(a => (a.title || '').trim() === idOrTitle.trim());
                    if (target) {
                        openDetailView(target);
                    } else if (idOrTitle === '年代なし') {
                        setViewMode('timeline_noyear');
                    } else {
                        alert('記事が見つかりません: ' + idOrTitle);
                    }
                };
            }, [articles]);

            // ブラウザの戻る/進むボタンに対応
            React.useEffect(() => {
                const handlePopState = (event) => {
                    if (event.state) {
                        console.log('履歴から復元:', event.state);
                        isRestoringFromURL.current = true;

                        if (event.state.viewMode) {
                            setViewMode(event.state.viewMode);
                        }

                        if (event.state.articleId && articles.length > 0) {
                            const article = articles.find(a => a.id === event.state.articleId);
                            if (article) {
                                setSelectedArticle(article);
                            }
                        } else if (!event.state.articleId) {
                            setSelectedArticle(null);
                        }
                    }
                };

                window.addEventListener('popstate', handlePopState);
                return () => window.removeEventListener('popstate', handlePopState);
            }, [articles]);

            React.useEffect(() => {
                if (!db || !worldId || !appContextId) return;
                const { onSnapshot, doc, collection } = window.firebaseModules;
                const unsubWorld = onSnapshot(doc(db, 'artifacts', appContextId, 'public', 'data', 'worlds', worldId), s => setWorldData(s.data()));
                const unsubArticles = onSnapshot(collection(db, 'artifacts', appContextId, 'public', 'data', 'worlds', worldId, 'articles'), s => {
                    setArticles(s.docs.map(d => ({ ...d.data(), id: d.id })).sort((a, b) => getArticleYear(a) - getArticleYear(b)));
                });
                return () => { unsubWorld(); unsubArticles(); };
            }, [db, worldId, appContextId]);

            React.useEffect(() => {
                if (!db || !worldId || !user || !appContextId) return;
                const { onSnapshot, doc, updateDoc } = window.firebaseModules;
                return onSnapshot(doc(db, 'artifacts', appContextId, 'public', 'data', 'worlds', worldId, 'members', user.uid), async s => {
                    if (s.exists()) {
                        const data = s.data();
                        setMyMemberData(data);
                        // 名前が未登録または変更されている場合は更新 (自分の情報のみ)
                        if (user.displayName && data.username !== user.displayName) {
                            try {
                                await updateDoc(doc(db, 'artifacts', appContextId, 'public', 'data', 'worlds', worldId, 'members', user.uid), {
                                    username: user.displayName
                                });
                            } catch (e) { console.error("Name sync failed", e); }
                        }
                    }
                    else setMyMemberData(null);
                });
            }, [db, worldId, user, appContextId]);

            const myRole = myMemberData?.role || 'guest';
            const canIApprove = myRole === 'owner' || myMemberData?.canApprove === true;
            const isMember = !!myMemberData;

            const articleIndex = React.useMemo(() => { const map = new Map(); articles.forEach(a => map.set(a.id, a)); return map; }, [articles]);
            // previewArticles: merge current formData into articles for instant preview in edit mode
            const previewArticles = React.useMemo(() => {
                try {
                    if (!formData) return articles;
                    const merged = articles.map(a => (formData.id && a.id === formData.id ? { ...a, ...formData } : a));
                    if (!formData.id) {
                        // append draft preview for new article
                        const draft = { ...(formData || {}), id: '__draft__' };
                        merged.push(draft);
                    }
                    return merged;
                } catch (e) { return articles; }
            }, [articles, formData]);
            const filteredTimelineArticles = React.useMemo(() => filterTimelineArticles(articles, timelineFilters), [articles, timelineFilters]);
            const timelineSummary = React.useMemo(() => {
                const summary = [];
                if (timelineFilters.keyword) summary.push(`KW:${timelineFilters.keyword}`);
                if (timelineFilters.tag) summary.push(`#${timelineFilters.tag}`);
                if (timelineFilters.type && timelineFilters.type !== 'all') summary.push(ARTICLE_TYPES[timelineFilters.type]?.label || timelineFilters.type);
                return summary.join(' / ') || '全記事';
            }, [timelineFilters]);

            // Remove localStorage region rules hooks
            const regionRules = worldData?.regionRules || REGION_TAG_RULES_DEFAULT;

            const handleConfigSave = (newConfig, newAppId) => {
                localStorage.setItem('worldweaver_firebase_config', JSON.stringify(newConfig));
                localStorage.setItem('worldweaver_app_id', newAppId);
                setShowConfigEditor(false);
                window.location.reload();
            };

            const handleAuth = async () => {
                setAuthError(null);
                const { signInWithEmailAndPassword, createUserWithEmailAndPassword, updateProfile } = window.firebaseModules;
                const email = `${authForm.username}@worldweaver.local`;
                try {
                    if (authMode === 'login') await signInWithEmailAndPassword(auth, email, authForm.password);
                    else {
                        const cred = await createUserWithEmailAndPassword(auth, email, authForm.password);
                        await updateProfile(cred.user, { displayName: authForm.username });
                    }
                    setViewMode('world_select');
                } catch (e) { setAuthError(e.message); }
            };

            const handleCreateWorld = async () => {
                if (!authForm.worldName) return alert("名前を入力してください");
                const { addDoc, collection, doc, setDoc, serverTimestamp } = window.firebaseModules;
                try {
                    const ref = await addDoc(collection(db, 'artifacts', appContextId, 'public', 'data', 'worlds'), {
                        name: authForm.worldName, description: authForm.worldDesc, ownerId: user.uid, createdAt: serverTimestamp()
                    });
                    await setDoc(doc(db, 'artifacts', appContextId, 'public', 'data', 'worlds', ref.id, 'members', user.uid), {
                        username: user.displayName, role: 'owner', joinedAt: serverTimestamp()
                    });
                    setWorldId(ref.id); setViewMode('timeline_large');
                } catch (e) { alert(e.message); }
            };

            const handleSaveArticle = async () => {
                if (!formData.title) return alert("タイトルを入力してください");
                const { addDoc, collection, doc, updateDoc, serverTimestamp } = window.firebaseModules;
                const tagsFromInput = tagInput.split(',').map(t => t.trim()).filter(t => t);
                const locationCandidates = [];
                if (Array.isArray(formData.locations)) {
                    formData.locations.forEach(l => {
                        const lat = Number(l.lat);
                        const lng = Number(l.lng);
                        if (Number.isFinite(lat) && Number.isFinite(lng)) locationCandidates.push({ lat, lng });
                    });
                }
                if (formData.lat !== undefined && formData.lng !== undefined && formData.lat !== '' && formData.lng !== '') {
                    const lat = Number(formData.lat);
                    const lng = Number(formData.lng);
                    if (Number.isFinite(lat) && Number.isFinite(lng)) locationCandidates.push({ lat, lng });
                }
                const regionTags = computeRegionTags(locationCandidates, regionRules);
                const tags = Array.from(new Set([...tagsFromInput, ...regionTags]));
                // 年代の計算
                let yearVal = parseInt(formData.year) || 0;
                if (!formData.noYear) {
                    if (formData.dateStr) {
                        const m = formData.dateStr.match(/^(\-?\d+)/);
                        if (m) yearVal = parseInt(m[1], 10);
                    } else if (formData.period?.start) {
                        const m = formData.period.start.match(/^(\-?\d+)/);
                        if (m) yearVal = parseInt(m[1], 10);
                    }
                } else {
                    yearVal = 0;
                }

                // Approval Status Logic
                let isApproved = !!formData.isApproved;
                // If not authorized to approve, keep it as is if existing, or false if new (unless default changes)
                // However, if unauthorized user edits an approved article, does it stay approved?
                // For now, adhere to formData state but verify permission if changing to true from false
                // But simplified: Only approvers see the checkbox. Editors just submit.
                // If I am NOT an approver, force preserving original state (if exists) or false (if new)
                if (!canIApprove) {
                    // 非承認者が編集した場合は、承認を取り下げる (または新規作成時は未承認)
                    isApproved = false;
                }

                const data = {
                    ...formData,
                    contentHtml: formData.contentHtml || '',
                    stats,
                    tags,
                    attachments: formData.attachments || [],
                    dateStr: formData.noYear ? '' : (formData.dateStr || ''),
                    period: formData.noYear ? { start: '', end: '' } : (formData.period || { start: '', end: '' }),
                    year: yearVal,
                    noYear: !!formData.noYear,
                    lat: Number.isFinite(formData.lat) ? formData.lat : null,
                    lng: Number.isFinite(formData.lng) ? formData.lng : null,
                    locationArticleId: formData.locationArticleId || '',
                    mainImageUrl: formData.mainImageUrl || '',
                    importance: Number(formData.importance) || 3,
                    isApproved: isApproved, // Save approval status
                    isApproved: isApproved, // Save approval status
                    updatedAt: serverTimestamp(), updatedBy: user.uid
                };
                // IDは保存データに含めない（ドキュメントIDとして管理されるため）
                delete data.id;

                try {
                    let artId = formData.id;
                    if (formData.id) {
                        await updateDoc(doc(db, 'artifacts', appContextId, 'public', 'data', 'worlds', worldId, 'articles', formData.id), data);
                    } else {
                        data.createdAt = serverTimestamp(); data.createdBy = user.uid;
                        const ref = await addDoc(collection(db, 'artifacts', appContextId, 'public', 'data', 'worlds', worldId, 'articles'), data);
                        artId = ref.id;
                        data.id = artId;
                    }

                    // Discord Webhook Notification
                    if (worldData?.discordWebhookUrl) {
                        const webhookUrl = worldData.discordWebhookUrl;
                        const isNew = !formData.id;
                        const editorName = user.displayName || 'Anonymous';
                        const title = data.title;
                        const checkStatus = isApproved ? 'Approved' : 'Unapproved';

                        // HTMLタグ除去 + Wikiリンク構文([[Title]]や[[Title|ID]])の除去(テキストは残す) + 空白整理
                        const rawText = stripHtml(data.contentHtml || '')
                            // [[Title|ID]] -> Title, [[Title]] -> Title
                            .replace(/\[\[([^|\]]+)(?:\|[^\]]+)?\]\]/g, '$1')
                            .replace(/\s+/g, ' ').trim();
                        const summary = rawText.length > 200 ? rawText.slice(0, 200) + '...' : (rawText || 'No Content');

                        const content = isNew
                            ? `🆕 **New Article Created** in ${worldData.name}\n**Title**: ${title}\n**Editor**: ${editorName}\n**Status**: ${checkStatus}\n**Summary**: ${summary}`
                            : `📝 **Article Updated** in ${worldData.name}\n**Title**: ${title}\n**Editor**: ${editorName}\n**Status**: ${checkStatus}\n**Summary**: ${summary}`;

                        // Fire and forget
                        fetch(webhookUrl, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ content })
                        }).catch(err => console.error("Discord Webhook Error:", err));
                    }

                    setSelectedArticle({ ...data, id: artId });

                    // 年代なし判定: noYearフラグが立っている、または年代が0/nullの場合
                    const hasYear = !data.noYear && data.year && Number(data.year) !== 0;

                    // 編集前のビューモードを考慮しつつ、適切なビューに遷移
                    if (previousViewMode === 'timeline_noyear' && !hasYear) {
                        // 年代なしビューから編集し、年代なしのまま → 年代なしビューに戻る
                        setViewMode('timeline_noyear');
                    } else if (previousViewMode === 'single_article') {
                        // 単独記事表示から編集 → 単独記事表示に戻る
                        setViewMode('single_article');
                    } else if (previousViewMode === 'list') {
                        // 一覧から編集 → 一覧に戻る
                        setViewMode('list');
                    } else {
                        // その他の場合は年代に基づいて判定
                        if (hasYear) {
                            setViewMode('timeline_large');
                        } else {
                            setViewMode('timeline_noyear');
                        }
                    }
                    // Success Message
                    alert(isApproved ? "保存しました" : "編集リクエストを送信しました (承認待ち)");

                } catch (e) { alert(e.message); }
            };

            const handleMapLayersUpdate = async (newLayers) => {
                const { updateDoc, doc } = window.firebaseModules;
                try {
                    await updateDoc(doc(db, 'artifacts', appContextId, 'public', 'data', 'worlds', worldId), { mapLayers: newLayers });
                    // compatibility with old field if needed, defaulting to first layer's url
                    if (newLayers.length > 0) {
                        await updateDoc(doc(db, 'artifacts', appContextId, 'public', 'data', 'worlds', worldId), { mapImageUrl: newLayers[0].url });
                    }
                } catch (e) { alert(e.message); }
            };

            const handleSaveRegionRules = async (newRules) => {
                const { updateDoc, doc } = window.firebaseModules;
                try {
                    await updateDoc(doc(db, 'artifacts', appContextId, 'public', 'data', 'worlds', worldId), { regionRules: newRules });
                } catch (e) { alert("ルール保存失敗: " + e.message); }
            };

            const handleSetMainPage = async (articleId) => {
                if (!['owner', 'admin'].includes(myRole)) return;
                const { updateDoc, doc } = window.firebaseModules;
                const isCurrentlyMain = worldData?.mainPageId === articleId;
                const targetId = isCurrentlyMain ? '' : articleId;
                try {
                    await updateDoc(doc(db, 'artifacts', appContextId, 'public', 'data', 'worlds', worldId), {
                        mainPageId: targetId
                    });
                    alert(targetId ? "メインページに設定しました" : "メインページ設定を解除しました");
                } catch (e) { alert("設定失敗: " + e.message); }
            };

            const handleReapplyRegionTags = async () => {
                if (!confirm('現在の全記事に対して、地域タグ・ルールを再適用しますか？\n\n・ルールに合致するタグが自動追加されます\n・場所が範囲外になった地域タグは自動削除されます\n・手動タグは維持されます')) return;
                const { updateDoc, doc } = window.firebaseModules;
                try {
                    const updates = [];
                    const managedTags = new Set(regionRules.map(r => r.tag));

                    for (const article of articles) {
                        const locationCandidates = [];
                        if (Array.isArray(article.locations)) {
                            article.locations.forEach(l => {
                                const lat = Number(l.lat);
                                const lng = Number(l.lng);
                                if (Number.isFinite(lat) && Number.isFinite(lng)) locationCandidates.push({ lat, lng });
                            });
                        }
                        if (article.lat !== undefined && article.lat !== null && article.lat !== '') {
                            const lat = Number(article.lat);
                            const lng = Number(article.lng);
                            if (Number.isFinite(lat) && Number.isFinite(lng)) locationCandidates.push({ lat, lng });
                        }

                        const validRegionTags = new Set(computeRegionTags(locationCandidates, regionRules));
                        const currentTags = article.tags || [];
                        const finalTags = new Set();
                        let changed = false;

                        currentTags.forEach(t => {
                            if (managedTags.has(t)) {
                                if (validRegionTags.has(t)) finalTags.add(t);
                                else changed = true;
                            } else {
                                finalTags.add(t);
                            }
                        });

                        validRegionTags.forEach(t => {
                            if (!finalTags.has(t)) {
                                finalTags.add(t);
                                changed = true;
                            }
                        });

                        if (changed) {
                            updates.push(updateDoc(doc(db, 'artifacts', appContextId, 'public', 'data', 'worlds', worldId, 'articles', article.id), {
                                tags: Array.from(finalTags)
                            }));
                        }
                    }
                    if (updates.length > 0) {
                        await Promise.all(updates);
                        alert(`${updates.length} 件の記事のタグを更新しました。`);
                    } else {
                        alert("更新が必要な記事はありませんでした。");
                    }
                } catch (e) { console.error(e); alert("エラーが発生しました: " + e.message); }
            };

            // When switching to the no-year view, if a selectedArticle is set then scroll to it inside that view
            React.useEffect(() => {
                try {
                    if (viewMode === 'timeline_noyear' && selectedArticle && selectedArticle.id) {
                        const id = selectedArticle.id;
                        // wait for render
                        setTimeout(() => {
                            const el = document.querySelector(`[data-noyear-id="${id}"]`);
                            if (el) {
                                try { el.scrollIntoView({ behavior: 'smooth', block: 'center' }); console.log('App: scrolled to no-year element', id); }
                                catch (err) { console.warn('scrollIntoView failed', err); }
                            } else {
                                console.log('App: no-year element not found for', id);
                            }
                        }, 200);
                    }
                } catch (e) { console.warn(e); }
            }, [viewMode, selectedArticle]);

            const openDetailView = (article, origin = viewMode) => {
                setSelectedArticle(article);

                // 記事の年代状態に応じてフィルタを調整
                const y = getArticleYear(article);
                const hasYear = y && y !== 0 && !article.noYear;

                // 年代なし記事を開く場合はexcludeNoYearをfalseに、年代あり記事はtrueに
                setTimelineFilters(prev => ({ ...prev, excludeNoYear: hasYear }));

                // 一覧、マップ、その他どこからでも詳細ビュー（全画面）へ遷移
                setViewMode('single_article');
            };

            const startEditingArticle = (article) => {
                if (!isMember) return;
                if (!article) return;
                setPreviousViewMode(viewMode); // 編集前のビューモードを保存
                setFormData({
                    ...createEmptyArticle(),
                    ...article,
                    locations: article.locations || [],
                    period: article.period || { start: '', end: '' },
                    lat: article.lat || null,
                    lng: article.lng || null
                });
                setStats(article.stats || []);
                setTagInput(safeArray(article.tags).join(', '));
                setViewMode('edit');
            };

            const handleTagClick = (tagName) => {
                setTimelineFilters(prev => ({ ...prev, tag: tagName }));
                const motherArticle = articles.find(a => a.representedTag === tagName);
                if (motherArticle) {
                    openDetailView(motherArticle);
                } else if (confirm(`タグ ${tagName} の記事はまだありません。作成しますか?`)) {
                    openTagArticle(tagName);
                }
            };

            const openTagArticle = (tagNameRaw) => {
                const tagName = (tagNameRaw || '').trim();
                if (!tagName) return;
                setTagArticleInput(tagName);
                const existing = articles.find(a => (a.representedTag || '').toLowerCase() === tagName.toLowerCase());
                if (existing) { startEditingArticle(existing); return; }
                const byTitle = articles.find(a => (a.title || '').toLowerCase() === tagName.toLowerCase());
                if (byTitle) { startEditingArticle(byTitle); return; }
                const draft = {
                    ...createEmptyArticle(),
                    title: tagName,
                    representedTag: tagName,
                    type: 'other',
                    folder: 'Keywords',
                    contentHtml: `<p>#${tagName} の説明を書いてください。</p>`,
                    noYear: true,
                    dateStr: '',
                    period: { start: '', end: '' },
                    tags: [tagName]
                };
                setFormData(draft);
                setStats([]);
                setTagInput(tagName);
                setViewMode('edit');
            };


            const copyMyId = () => {
                if (!user) return;
                const text = user.uid;
                const fallbackCopy = (text) => { const textArea = document.createElement("textarea"); textArea.value = text; textArea.style.position = "fixed"; textArea.style.left = "-9999px"; document.body.appendChild(textArea); textArea.focus(); textArea.select(); try { document.execCommand('copy'); alert("IDコピー: " + text); } catch (err) { console.error(err); alert("失敗"); } document.body.removeChild(textArea); };
                if (navigator.clipboard && navigator.clipboard.writeText) { navigator.clipboard.writeText(text).then(() => alert("IDコピー: " + text)).catch(() => fallbackCopy(text)); } else { fallbackCopy(text); }
            };

            const handleDeleteArticle = async (article) => {
                if (!article) return;
                const canDelete = myRole === 'owner' || myRole === 'admin';
                if (!canDelete) { alert("削除権限がありません（管理者のみ）"); return; }
                if (!confirm(`本当に「${article.title}」を削除しますか？\nこの操作は取り消せません。`)) return;

                const { deleteDoc, doc } = window.firebaseModules;
                try {
                    await deleteDoc(doc(db, 'artifacts', appContextId, 'public', 'data', 'worlds', worldId, 'articles', article.id));
                    // If we are currently viewing this article, close it or go back
                    if (selectedArticle && selectedArticle.id === article.id) {
                        setSelectedArticle(null);
                        setViewMode('timeline_large');
                    }
                } catch (e) { alert("削除失敗: " + e.message); }
            };

            // Expose state to window for plugins (like #datatable)
            React.useEffect(() => {
                window.articles = articles;
                window.db = db;
                window.appContextId = appContextId;
                window.worldId = worldId;
                window.worldData = worldData;
            }, [articles, db, appContextId, worldId, worldData]);

            const handleDuplicateArticle = (article) => {
                if (!article) return;
                if (!['owner', 'editor', 'admin'].includes(myRole)) { alert("作成権限がありません"); return; }

                const newTitle = article.title + " (複製)";
                const duplicated = {
                    ...article,
                    title: newTitle,
                    id: null,
                    isApproved: false,
                    createdAt: null,
                    updatedAt: null,
                    createdBy: null,
                    updatedBy: null
                };

                // Use existing startEditingArticle logic but override state with duplicated data
                setFormData({
                    ...createEmptyArticle(),
                    ...duplicated,
                    locations: duplicated.locations || [],
                    period: duplicated.period || { start: '', end: '' },
                    lat: duplicated.lat || null,
                    lng: duplicated.lng || null
                });
                setStats(duplicated.stats || []);
                setTagInput(safeArray(duplicated.tags).join(','));
                setViewMode('edit');
            };

            // 匿名ログインを自動実行（閲覧のみ可能）
            React.useEffect(() => {
                if (!user && !loading && auth) {
                    const { signInAnonymously } = window.firebaseModules;
                    signInAnonymously(auth).catch(err => {
                        console.error('匿名ログイン失敗:', err);
                        setAuthError('自動ログインに失敗しました: ' + err.message);
                    });
                }
            }, [user, loading, auth]);

            if (loading) return <div className="h-screen flex items-center justify-center text-indigo-600 font-bold animate-pulse">Loading...</div>;
            if (!user) return <div className="h-screen flex items-center justify-center text-indigo-600 font-bold">接続中...</div>;

            if (viewMode === 'world_select') return (
                <div className="min-h-screen bg-gray-100 p-6">
                    <div className="max-w-4xl mx-auto">
                        <div className="flex justify-between items-center mb-6">
                            <h1 className="text-2xl font-bold serif text-gray-800">世界の選択</h1>
                            <div className="flex gap-2 items-center">
                                <span className="text-xs text-gray-400 font-mono">{appContextId}</span>
                                <button onClick={() => setShowConfigEditor(true)} className="text-xs text-gray-500 hover:text-indigo-600"><Icon name="settings" size={14} /></button>
                                <button onClick={() => window.firebaseModules.signOut(auth)} className="text-sm text-red-500 hover:underline ml-2">ログアウト</button>
                            </div>
                        </div>
                        {showConfigEditor && <ConfigEditor currentConfig={activeConfig} currentAppId={appContextId} onSave={handleConfigSave} onCancel={() => setShowConfigEditor(false)} />}
                        <div className="grid md:grid-cols-3 gap-6">
                            <div className="bg-white p-6 rounded-lg shadow">
                                <h2 className="text-lg font-bold mb-4"><Icon name="user" /> {authMode === 'login' ? 'ログイン' : '新規登録'}</h2>
                                <div className="space-y-3">
                                    <input className="w-full border p-2 rounded" placeholder="ユーザー名" value={authForm.username} onChange={e => setAuthForm({ ...authForm, username: e.target.value })} />
                                    <input className="w-full border p-2 rounded" type="password" placeholder="パスワード" value={authForm.password} onChange={e => setAuthForm({ ...authForm, password: e.target.value })} />
                                    <div className="flex gap-2">
                                        <button onClick={handleAuth} className="flex-1 bg-indigo-600 text-white py-2 rounded font-bold">{authMode === 'login' ? 'ログイン' : '登録'}</button>
                                        <button onClick={() => setAuthMode(authMode === 'login' ? 'register' : 'login')} className="px-3 py-2 text-sm text-indigo-600 border rounded">{authMode === 'login' ? '登録へ' : 'ログインへ'}</button>
                                    </div>
                                    {authError && <div className="text-red-500 text-sm">{authError}</div>}
                                </div>
                            </div>
                            <div className="bg-white p-6 rounded-lg shadow"><h2 className="text-lg font-bold mb-4"><Icon name="search" /> 世界を探す</h2><WorldList db={db} appContextId={appContextId} onSelect={(id) => { setWorldId(id); setViewMode('timeline_large'); }} /></div>
                            <div className="bg-white p-6 rounded-lg shadow"><h2 className="text-lg font-bold mb-4"><Icon name="plus-circle" /> 新世界創造</h2>
                                <div className="space-y-3"><input className="w-full border p-2 rounded" placeholder="名前" value={authForm.worldName} onChange={e => setAuthForm({ ...authForm, worldName: e.target.value })} /><button onClick={handleCreateWorld} className="w-full bg-emerald-600 text-white py-2 rounded font-bold">創造</button></div>
                            </div>
                        </div>
                    </div>
                </div>
            );

            return (
                <div className="flex h-screen overflow-hidden bg-gray-100">
                    <div className="flex-1 flex flex-col relative h-full overflow-hidden">
                        <header className="bg-white shadow-sm px-4 py-2 flex items-center justify-between z-10 border-b">
                            <div className="flex items-center gap-4">
                                {worldData?.mainPageId && (
                                    <button onClick={() => {
                                        const mainArt = articles.find(a => a.id === worldData.mainPageId);
                                        if (mainArt) { setSelectedArticle(mainArt); setViewMode('single_article'); }
                                    }} className="p-2 -ml-2 text-indigo-600 hover:text-indigo-800 rounded-full hover:bg-indigo-50 transition-colors" title="メインページ">
                                        <Icon name="landmark" size={20} />
                                    </button>
                                )}
                                <div className="hidden md:flex flex-col text-xs text-gray-500">
                                    <span className="text-sm font-bold text-gray-800">{worldData?.name}</span>
                                    <span className="text-[11px] cursor-pointer hover:text-indigo-600" onClick={copyMyId} title="IDコピー">{user?.displayName} (ID)</span>
                                </div>
                                <div className="flex bg-gray-100 p-1 rounded-lg overflow-x-auto no-scrollbar max-w-[200px] md:max-w-none">{VIEW_TABS.map(tab => (<button key={tab.key} onClick={() => setViewMode(tab.key)} className={`px-3 py-1.5 rounded text-sm flex items-center gap-1 whitespace-nowrap ${viewMode === tab.key ? 'bg-white shadow text-indigo-600 font-bold' : 'text-gray-500'}`}><Icon name={tab.icon} size={16} /> {tab.label}</button>))}</div>
                            </div>
                            <div className="flex items-center gap-2 md:gap-4">
                                {(viewMode === 'timeline_large' || viewMode === 'list' || viewMode === 'map') && (
                                    <button onClick={() => setTimelineFilters(prev => ({ ...prev, onlyApproved: !prev.onlyApproved }))} className={`flex items-center gap-1 text-xs px-2 py-1 rounded transition-colors ${timelineFilters.onlyApproved ? 'bg-emerald-600 text-white font-bold' : 'bg-gray-200 text-gray-500 hover:bg-gray-300'}`} title="承認済み記事のみ表示">
                                        <Icon name="check-circle" size={14} />
                                        <span className="hidden sm:inline">承認済のみ</span>
                                    </button>
                                )}
                                <div className="hidden lg:flex items-center text-[11px] text-gray-400"><Icon name="filter" size={12} className="mr-1" /> {timelineSummary} {timelineFilters.onlyApproved && <span className="text-emerald-600 font-bold ml-1">(ON)</span>}</div>{(myRole === 'owner' || myRole === 'admin') && <button onClick={() => setShowAdminPanel(true)} title="管理パネル" className="text-gray-500 hover:text-indigo-600 p-2 rounded-full bg-gray-100"><Icon name="settings" size={18} /></button>}{isMember && <button onClick={() => { setFormData(createEmptyArticle()); setStats([]); setTagInput(''); setViewMode('edit'); }} className="bg-indigo-600 text-white px-4 py-1.5 rounded text-sm font-bold shadow-sm flex items-center gap-1"><Icon name="plus" size={16} /> {canIApprove ? '作成' : '作成申請'}</button>}</div>
                        </header>
                        <div className="flex-1 overflow-y-auto relative bg-slate-50">
                            {viewMode === 'list' && <FolderIntegratedList articles={articles} onSelectArticle={(article) => openDetailView(article, 'list')} onTagClick={handleTagClick} onlyApproved={timelineFilters.onlyApproved} onOpenNoYear={(id) => { if (id) { const art = articles.find(x => x.id === id); if (art) setSelectedArticle(art); } setViewMode('timeline_noyear'); }} onSearchChange={p => setTimelineFilters(prev => ({ ...prev, ...p }))} />}
                            {viewMode === 'map' && <div className="absolute inset-0 flex flex-col">
                                <div className="p-3 z-10 bg-white/90 border-b flex items-center gap-4">
                                    <input className="flex-1 p-2 rounded border text-sm max-w-sm" placeholder="地図検索 (タイトル/本文/タグ)..." value={mapTabQuery || ''} onChange={e => setMapTabQuery(e.target.value)} />
                                    <div className="flex items-center gap-2 border-l pl-4">
                                        <span className="text-xs font-bold text-gray-500">重要度:</span>
                                        <div className="flex bg-gray-100 rounded p-0.5">
                                            {[1, 2, 3, 4, 5].map(v => (
                                                <button key={v} onClick={() => setMapTabImportance(mapTabImportance === v ? 0 : v)} className={`px-2 py-0.5 text-xs rounded ${mapTabImportance === v ? 'bg-indigo-600 text-white font-bold' : mapTabImportance > v ? 'text-indigo-600' : 'text-gray-400'}`}>
                                                    {v}
                                                </button>
                                            ))}
                                            <span className="text-[10px] items-center flex px-1 text-gray-400">{mapTabImportance ? '以上' : '指定なし'}</span>
                                        </div>
                                    </div>
                                </div>
                                <div className="flex-1 relative"><MapView articles={articles} worldData={worldData} isEditing={false} externalQuery={mapTabQuery} onExternalQueryChange={v => setMapTabQuery(v)} highlightArticleId={selectedArticle?.id} minImportance={mapTabImportance} onSelectArticle={a => {
                                    // 年代がある記事は年表ビューで拡大表示、年代なしは単独の拡大記事表示
                                    const y = getArticleYear(a);
                                    const hasYear = y && y !== 0 && !a.noYear;

                                    // 記事の年代状態に応じてフィルタを調整
                                    setTimelineFilters(prev => ({ ...prev, excludeNoYear: hasYear }));

                                    if (hasYear) {
                                        setSelectedArticle(a);
                                        setViewMode('timeline_large');
                                    } else {
                                        openDetailView(a, 'map');
                                    }
                                }} appContextId={appContextId} /></div>
                            </div>}
                            {viewMode === 'timeline_large' && <LargeTimelineView articles={filteredTimelineArticles} onSelectArticle={setSelectedArticle} onEditArticle={startEditingArticle} onDeleteArticle={handleDeleteArticle} onDuplicateArticle={handleDuplicateArticle} focusedArticle={selectedArticle} onFocusChange={setSelectedArticle} allArticles={articles} searchState={timelineFilters} onSearchChange={p => setTimelineFilters(prev => ({ ...prev, ...p }))} onResetFilters={() => setTimelineFilters({ type: 'all', keyword: '', tag: '', excludeNoYear: true })} worldData={worldData} appContextId={appContextId} myRole={myRole} isMember={isMember} onOpenNoYear={(id) => { if (id) { const art = articles.find(x => x.id === id); if (art) { setSelectedArticle(art); setViewMode('single_article'); } } else { setViewMode('timeline_noyear'); } }} onOpenTagArticle={openTagArticle} tagArticleValue={tagArticleInput} onTagArticleValueChange={setTagArticleInput} />}
                            {viewMode === 'network' && (
                                <div className="absolute inset-0 bg-slate-100 p-4">
                                    <NetworkGraphView articles={articles} focusedArticle={selectedArticle} worldData={worldData} onArticleSelect={(article) => {
                                        if (article) {
                                            setSelectedArticle(article);
                                            setViewMode('single_article');
                                        }
                                    }} />
                                </div>
                            )}
                            {viewMode === 'stats' && <GraphView setView={setViewMode} articles={articles} worldData={worldData} worldId={worldId} appContextId={appContextId} db={db} canIApprove={canIApprove} />}
                            {viewMode === 'spreadsheet' && <LargeSpreadsheetView articles={articles} filters={timelineFilters} />}
                            {viewMode === 'timeline_noyear' && (
                                <div className="absolute inset-0 overflow-auto p-6 bg-slate-900">
                                    <div className="flex items-center justify-between mb-4">
                                        <h2 className="text-xl font-bold text-white">年代未設定の記事一覧</h2>
                                        <div className="flex gap-2"><button onClick={() => setViewMode('timeline_large')} className="px-3 py-1 rounded bg-slate-700 text-white hover:bg-slate-600">年表に戻る</button><button onClick={() => { setPreviousViewMode('timeline_noyear'); setViewMode('edit'); }} className="px-3 py-1 rounded bg-indigo-600 text-white hover:bg-indigo-700">新規作成</button></div>
                                    </div>
                                    <div className="max-w-6xl mx-auto space-y-4">
                                        {articles.filter(a => {
                                            if (a.noYear === true) return true;
                                            const y = Math.floor(getArticleYear(a));
                                            return !y || Number(y) === 0;
                                        }).map(a => (
                                            <div key={a.id} className="bg-slate-800/50 border border-slate-700 rounded-xl p-6 hover:bg-slate-800 transition">
                                                <div className="flex items-center justify-between mb-3"><h3 className="font-bold text-xl text-white">{a.title}</h3><span className="text-xs text-slate-400 font-mono">{a.dateStr || ''}</span></div>
                                                <div className="text-sm text-slate-300 mb-4 rich-editor leading-relaxed" onClick={(e) => {
                                                    const link = e.target.closest && e.target.closest('.wiki-link');
                                                    if (link) {
                                                        e.preventDefault(); e.stopPropagation();
                                                        const id = link.getAttribute('data-article-id');
                                                        const wikiTitle = link.getAttribute('data-wiki-title');
                                                        if (id) {
                                                            const target = articleIndex.get(id);
                                                            if (target) {
                                                                setSelectedArticle(target);
                                                                setViewMode('single_article');
                                                                setTimelineFilters({ type: 'all', keyword: '', tag: '', excludeNoYear: true });
                                                            } else {
                                                                alert('リンク先の記事が見つかりません');
                                                            }
                                                        } else if (wikiTitle) {
                                                            if (wikiTitle === '年代なし') {
                                                                setViewMode('timeline_noyear');
                                                            } else {
                                                                const target = articles.find(x => (x.title || '').trim() === wikiTitle.trim());
                                                                if (target) {
                                                                    setSelectedArticle(target);
                                                                    setViewMode('single_article');
                                                                    setTimelineFilters({ type: 'all', keyword: '', tag: '', excludeNoYear: true });
                                                                } else {
                                                                    alert('リンク先の記事が見つかりません');
                                                                }
                                                            }
                                                        }
                                                    }
                                                }} dangerouslySetInnerHTML={{ __html: transformContent(a.contentHtml || '') }}></div>
                                                <div className="flex justify-end gap-2 border-t border-slate-700 pt-3">
                                                    <button onClick={() => { startEditingArticle(a); }} className="px-3 py-1 rounded bg-slate-700 text-white text-sm hover:bg-slate-600">編集</button>
                                                    <button onClick={() => { handleDuplicateArticle(a); }} className="px-3 py-1 rounded bg-emerald-600 text-white text-sm hover:bg-emerald-700">複製</button>
                                                    {(myRole === 'owner' || myRole === 'admin') && <button onClick={() => { handleDeleteArticle(a); }} className="px-3 py-1 rounded bg-red-600 text-white text-sm hover:bg-red-700">削除</button>}
                                                </div>
                                            </div>
                                        ))}
                                    </div>
                                </div>
                            )}
                            {viewMode === 'single_article' && selectedArticle && (
                                <div className="absolute inset-0 bg-slate-900 overflow-y-auto z-50 p-0">
                                    <div className="sticky top-0 bg-slate-900/95 backdrop-blur border-b border-slate-700 p-4 flex justify-between items-center z-50 shadow-lg">
                                        <div className="flex items-center gap-4">
                                            <button onClick={() => setViewMode('timeline_noyear')} className="flex items-center gap-1 text-sm text-slate-400 hover:text-white"><Icon name="arrow-left" size={16} /> 一覧に戻る</button>
                                            <h2 className="font-bold text-lg truncate max-w-xl flex items-center gap-2 text-white">
                                                {selectedArticle.title}
                                                {selectedArticle.isApproved && <span className="bg-emerald-600 text-white text-xs px-2 py-0.5 rounded flex items-center gap-1"><Icon name="check" size={12} /> 承認済</span>}
                                            </h2>
                                        </div>
                                        <div className="flex gap-2">
                                            {(myRole === 'owner' || myRole === 'admin') && (
                                                <button
                                                    onClick={() => handleSetMainPage(selectedArticle.id)}
                                                    className={`px-4 py-1.5 text-sm font-bold rounded shadow-sm flex items-center gap-1 transition-colors ${worldData?.mainPageId === selectedArticle.id ? 'bg-amber-600 text-white' : 'bg-amber-50 text-amber-600 border border-amber-200 hover:bg-amber-100'}`}
                                                    title={worldData?.mainPageId === selectedArticle.id ? 'メインページを解除' : 'この世界を開いた際の初期ページに設定'}
                                                >
                                                    <Icon name="star" size={14} />
                                                    {worldData?.mainPageId === selectedArticle.id ? 'メイン解除' : 'メイン設定'}
                                                </button>
                                            )}
                                            {isMember && <button onClick={() => startEditingArticle(selectedArticle)} className="px-4 py-1.5 bg-indigo-600 text-white text-sm font-bold rounded shadow-sm hover:bg-indigo-700">編集</button>}
                                            {isMember && <button onClick={() => handleDuplicateArticle(selectedArticle)} className="px-4 py-1.5 bg-emerald-600 text-white text-sm font-bold rounded shadow-sm hover:bg-emerald-700">複製</button>}
                                            {(myRole === 'owner' || myRole === 'admin') && <button onClick={() => handleDeleteArticle(selectedArticle)} className="px-4 py-1.5 bg-red-600 text-white text-sm font-bold rounded shadow-sm hover:bg-red-700">削除</button>}
                                        </div>
                                    </div>
                                    <div className="max-w-none p-8 md:p-12 mx-auto">
                                        {/* Full width rendering container without constraints for complex tables */}
                                        <div className="prose prose-xl max-w-none prose-invert" style={{ color: '#e2e8f0' }} dangerouslySetInnerHTML={{ __html: transformContent(selectedArticle.contentHtml || '') }} onClick={(e) => {
                                            const link = e.target.closest && e.target.closest('.wiki-link');
                                            if (link) {
                                                e.preventDefault(); e.stopPropagation();
                                                const id = link.getAttribute('data-article-id');
                                                if (id) {
                                                    const target = articleIndex.get(id);
                                                    if (target) {
                                                        const y = getArticleYear(target);
                                                        // 年代設定ありの記事なら年表ビューへ飛ぶ
                                                        if (y && y !== 0 && !target.noYear) {
                                                            setSelectedArticle(target);
                                                            setViewMode('timeline_large');
                                                            // フォーカスを当てるなど
                                                        } else {
                                                            setSelectedArticle(target);
                                                            /* stay in single view */
                                                        }
                                                    }
                                                    else alert('リンク先が見つかりません');
                                                }
                                            }
                                        }}></div>
                                    </div>
                                </div>
                            )}
                            {viewMode === 'edit' && (
                                <div className="absolute inset-0 flex flex-col bg-white z-50">
                                    <div className="border-b px-6 py-3 flex justify-between items-center bg-gray-50">
                                        <h2 className="font-bold text-gray-700 flex items-center gap-2">
                                            {canIApprove ? '編集' : '編集リクエスト'}
                                            {!canIApprove && <span className="text-[10px] bg-amber-100 text-amber-700 px-2 py-0.5 rounded">※承認待ちとなります</span>}
                                        </h2>
                                        <div className="flex gap-2">
                                            <button onClick={() => setViewMode(previousViewMode || 'timeline_large')} className="px-4 py-2 rounded bg-gray-200 text-sm">キャンセル</button>
                                            <button onClick={handleSaveArticle} className={`px-6 py-2 rounded text-white font-bold text-sm ${canIApprove ? 'bg-indigo-600 hover:bg-indigo-700' : 'bg-emerald-600 hover:bg-emerald-700'}`}>
                                                {canIApprove ? '保存' : '申請する'}
                                            </button>
                                        </div>
                                    </div>
                                    <div className="flex-1 flex overflow-hidden">
                                        <div className="flex-1 p-6 overflow-y-auto flex flex-col gap-4">
                                            <input className="w-full text-3xl font-bold p-2 border-b outline-none serif" placeholder="タイトル" value={formData.title} onChange={e => setFormData(prev => ({ ...prev, title: e.target.value }))} />
                                            <div className="grid grid-cols-2 gap-4"><div><label className="text-xs font-bold text-gray-500 block mb-1">期間 (開始) (yyyy/mm/dd-hh:mm:ss)</label><input type="text" className="w-full border p-2 rounded" placeholder="2023/01/01-00:00:00" value={formData.period?.start || ''} onChange={e => setFormData(prev => ({ ...prev, period: { ...(prev.period || {}), start: e.target.value } }))} /></div><div><label className="text-xs font-bold text-gray-500 block mb-1">期間 (終了) (yyyy/mm/dd-hh:mm:ss)</label><input type="text" className="w-full border p-2 rounded" placeholder="2023/12/31-23:59:59" value={formData.period?.end || ''} onChange={e => setFormData(prev => ({ ...prev, period: { ...(prev.period || {}), end: e.target.value } }))} /></div></div>
                                            <div className="grid grid-cols-3 gap-4">
                                                <div>
                                                    <label className="text-xs font-bold text-gray-500 block mb-1">種別</label>
                                                    <select className="w-full border p-2 rounded" value={formData.type} onChange={e => setFormData(prev => ({ ...prev, type: e.target.value }))}>
                                                        {Object.entries(ARTICLE_TYPES).map(([k, v]) => <option key={k} value={k}>{v.label}</option>)}
                                                    </select>
                                                </div>
                                                <div>
                                                    <label className="text-xs font-bold text-gray-500 block mb-1">フォルダ</label>
                                                    <input className="w-full border p-2 rounded" placeholder="国/組織" value={formData.folder} onChange={e => setFormData(prev => ({ ...prev, folder: e.target.value }))} />
                                                </div>
                                                <div>
                                                    <label className="text-xs font-bold text-gray-500 block mb-1">日時 (yyyy/mm/dd-hh:mm:ss)</label>
                                                    <input className="w-full border p-2 rounded" placeholder="2023/11/20-14:00:00" value={formData.dateStr || ''} onChange={e => setFormData(prev => ({ ...prev, dateStr: e.target.value }))} />
                                                </div>
                                            </div>
                                            <div className="my-2">
                                                <label className="text-xs font-bold text-gray-500 block mb-1">重要度 (1-5)</label>
                                                <div className="flex gap-1">
                                                    {[1, 2, 3, 4, 5].map(v => (
                                                        <button key={v} onClick={() => setFormData(prev => ({ ...prev, importance: v }))} className={`px-3 py-1 rounded text-sm font-bold border ${formData.importance === v ? 'bg-yellow-100 text-yellow-600 border-yellow-300' : 'bg-gray-50 text-gray-400'}`}>
                                                            {v}
                                                        </button>
                                                    ))}
                                                </div>
                                            </div>
                                            <div className="flex items-center gap-4">
                                                <label className="flex items-center gap-2 text-sm"><input type="checkbox" checked={!!formData.noYear} onChange={e => setFormData(prev => ({ ...prev, noYear: e.target.checked }))} /> <span className="text-sm text-gray-600">年代なしにする</span></label>
                                                {canIApprove && (
                                                    <label className="flex items-center gap-2 text-sm bg-emerald-50 px-2 py-1 rounded border border-emerald-200">
                                                        <input type="checkbox" checked={!!formData.isApproved} onChange={e => setFormData(prev => ({ ...prev, isApproved: e.target.checked }))} />
                                                        <span className="text-sm font-bold text-emerald-800">承認済みにする</span>
                                                    </label>
                                                )}
                                            </div>
                                            {!canIApprove && (
                                                <div className="text-xs text-gray-500">
                                                    現在のステータス: <span className={`font-bold ${formData.isApproved ? 'text-emerald-600' : 'text-gray-400'}`}>{formData.isApproved ? '承認済み' : '未承認'}</span>
                                                    (承認権限がありません)
                                                </div>
                                            )}
                                            <div className="flex gap-2">
                                                <div className="flex-1"><LocationsEditor locations={formData.locations} onChange={l => setFormData(prev => ({ ...prev, locations: l }))} /></div>
                                                <div className="w-1/3 space-y-2">
                                                    <ArticleLinkInserter articles={articles} onInsert={(a) => {
                                                        if (formData._editorMode === 'html' && htmlTextareaRef.current) {
                                                            const ta = htmlTextareaRef.current;
                                                            const start = ta.selectionStart;
                                                            const end = ta.selectionEnd;
                                                            const text = formData.contentHtml || '';
                                                            const wikiLink = `[[${a.title}|${a.id}]]`;
                                                            const newText = text.substring(0, start) + wikiLink + text.substring(end);
                                                            setFormData(prev => ({ ...prev, contentHtml: newText }));
                                                            setTimeout(() => {
                                                                ta.focus();
                                                                ta.setSelectionRange(start + wikiLink.length, start + wikiLink.length);
                                                            }, 0);
                                                        } else if (editorRef.current) {
                                                            editorRef.current.insertLink(a);
                                                        }
                                                    }} />
                                                    <div className="text-xs text-gray-500">※文字色はエディタのカラー機能で変更できます</div>
                                                </div>
                                            </div>
                                            <div className="space-y-2">
                                                <div className="mt-2 flex items-center gap-3">
                                                    <label className="text-xs font-bold text-gray-500">本文</label>
                                                    <div className="flex items-center gap-2">
                                                        <button onClick={() => setFormData(prev => ({ ...prev, _editorMode: 'wysiwyg' }))} className={`px-2 py-1 rounded text-xs ${formData._editorMode !== 'html' ? 'bg-indigo-600 text-white' : 'bg-white'}`}>WYSIWYG</button>
                                                        <button onClick={() => setFormData(prev => ({ ...prev, _editorMode: 'html' }))} className={`px-2 py-1 rounded text-xs ${formData._editorMode === 'html' ? 'bg-indigo-600 text-white' : 'bg-white'}`}>HTML編集</button>
                                                    </div>
                                                </div>
                                                {formData._editorMode === 'html' ? (
                                                    <div className="flex-1 border rounded overflow-hidden flex flex-col min-h-[320px] bg-white">
                                                        <label className="text-xs font-bold text-gray-500 p-2">HTML ソース</label>
                                                        <textarea ref={htmlTextareaRef} className="w-full h-48 p-2 font-mono text-sm border-t" value={formData.contentHtml || ''} onChange={e => setFormData(prev => ({ ...prev, contentHtml: e.target.value }))} />
                                                        <div className="p-2 border-t">
                                                            <AttachmentUploader storage={storage} appContextId={appContextId} onAddAttachment={(att) => setFormData(prev => ({ ...prev, attachments: [...(prev.attachments || []), att] }))} />
                                                            <div className="mt-2 space-y-1 text-xs">
                                                                {(formData.attachments || []).map((att, i) => (
                                                                    <div key={i} className="flex items-center justify-between gap-2 p-1 bg-gray-50 rounded mb-1">
                                                                        <a className="text-indigo-600 underline truncate flex-1" href={att.url} target="_blank" rel="noreferrer" title={att.name}>{att.name}</a>
                                                                        <div className="flex gap-1">
                                                                            <button onClick={() => copyText(att.url)} className="text-gray-500 hover:text-indigo-600 text-[10px] border px-1 rounded bg-white">URL</button>
                                                                            <button onClick={() => {
                                                                                const tag = `<img src="${att.url}" alt="${att.name}" style="max-width:100%;" />`;
                                                                                if (htmlTextareaRef.current) {
                                                                                    const ta = htmlTextareaRef.current;
                                                                                    const start = ta.selectionStart;
                                                                                    const end = ta.selectionEnd;
                                                                                    const text = formData.contentHtml || '';
                                                                                    const newText = text.substring(0, start) + tag + text.substring(end);
                                                                                    setFormData(prev => ({ ...prev, contentHtml: newText }));
                                                                                    setTimeout(() => {
                                                                                        ta.focus();
                                                                                        ta.setSelectionRange(start + tag.length, start + tag.length);
                                                                                    }, 0);
                                                                                }
                                                                            }} className="text-indigo-600 hover:text-indigo-800 text-[10px] border px-1 rounded font-bold bg-white">IMG挿入</button>
                                                                            <button onClick={() => setFormData(prev => ({ ...prev, attachments: prev.attachments.filter((_, ii) => ii !== i) }))} className="text-red-500 hover:text-red-700 text-[10px] border px-1 rounded bg-white">削除</button>
                                                                        </div>
                                                                    </div>
                                                                ))}
                                                            </div>
                                                        </div>
                                                    </div>
                                                ) : (
                                                    <div className="flex-1 border rounded overflow-hidden flex flex-col min-h-[320px] bg-white"><RichTextEditor ref={editorRef} value={formData.contentHtml || ''} onChange={val => setFormData(prev => ({ ...prev, contentHtml: val }))} /></div>
                                                )}
                                            </div>
                                            <div className="bg-gray-50 p-2 rounded"><label className="text-xs font-bold text-gray-500 block mb-1">タグ (カンマ区切り)</label><input className="w-full border p-2 rounded" placeholder="王, 歴史, 重要" value={tagInput} onChange={e => setTagInput(e.target.value)} /></div>
                                            <div className="bg-white border rounded p-3 shadow-sm space-y-3">
                                                <div className="flex items-center justify-between">
                                                    <div><label className="text-xs font-bold text-gray-500 block mb-1">メイン画像</label></div>
                                                    <ImageUploader storage={storage} appContextId={appContextId} onUploadComplete={url => setFormData(prev => ({ ...prev, mainImageUrl: url }))} label="アップロード" />
                                                </div>
                                                {formData.mainImageUrl && <>
                                                    <img src={formData.mainImageUrl} alt="preview" className="w-full rounded border" />
                                                    <div className="flex gap-2 text-[11px] text-gray-500">
                                                        <button type="button" onClick={() => setFormData(prev => ({ ...prev, mainImageUrl: '' }))} className="px-2 py-1 border rounded">削除</button>
                                                    </div>
                                                </>}
                                            </div>
                                        </div>
                                        <div className="w-80 border-l bg-gray-50 flex flex-col overflow-y-auto">
                                            <div className="h-52 relative border-b">
                                                <MapView
                                                    articles={previewArticles}
                                                    worldData={worldData}
                                                    highlightArticleId={formData?.id || '__draft__'}
                                                    isEditing={true}
                                                    onLocationSelect={c => {
                                                        const newLoc = { lat: Number(c.lat.toFixed(4)), lng: Number(c.lng.toFixed(4)), label: 'New Point' };
                                                        setFormData(prev => ({ ...prev, locations: [...(prev.locations || []), newLoc] }));
                                                    }}
                                                    appContextId={appContextId}
                                                    storage={storage}
                                                    onMapImageUpdate={null} // Disable direct image update in edit sidebar in favor of admin panel
                                                    myRole={myRole}
                                                />
                                            </div>
                                            <div className="p-4 border-t"><div className="text-xs font-bold text-gray-500 mb-2 border-b pb-1">ステータス</div><StatsEditor stats={stats} onChange={setStats} /></div>
                                        </div>
                                    </div>
                                </div>
                            )}
                            {showMemberManager && <MemberManager db={db} worldId={worldId} appContextId={appContextId} onClose={() => setShowMemberManager(false)} />}
                            {showRegionRuleEditor && <RegionRuleEditor rules={regionRules} worldData={worldData} onSave={(r) => { handleSaveRegionRules(r); setShowRegionRuleEditor(false); }} onClose={() => setShowRegionRuleEditor(false)} />}
                            {showAdminPanel && (
                                <div className="fixed inset-0 bg-black/50 flex items-center justify-center z-[9999] p-4">
                                    <div className="bg-white p-6 rounded-lg shadow-xl w-full max-w-md">
                                        <div className="flex justify-between items-center mb-4">
                                            <h3 className="text-lg font-bold text-gray-800">管理パネル</h3>
                                            <button onClick={() => setShowAdminPanel(false)} className="text-gray-500"><Icon name="x" size={18} /></button>
                                        </div>
                                        <div className="space-y-4">
                                            <div className="flex items-center justify-between">
                                                <div>
                                                    <div className="text-sm font-bold">メンバー管理</div>
                                                    <div className="text-xs text-gray-500">メンバーの追加・削除を行います</div>
                                                </div>
                                                <div>
                                                    <button onClick={() => { setShowMemberManager(true); setShowAdminPanel(false); }} className="px-3 py-1.5 bg-indigo-600 text-white rounded text-sm">開く</button>
                                                </div>
                                            </div>
                                            <div className="flex items-center justify-between">
                                                <div>
                                                    <div className="text-sm font-bold">地図レイヤー管理</div>
                                                    <div className="text-xs text-gray-500">複数の地図レイヤーを管理します</div>
                                                </div>
                                                <div>
                                                    {/* Just a placeholder, main UI is below */}
                                                </div>
                                            </div>
                                            <div className="border border-indigo-100 rounded bg-indigo-50 p-3">
                                                <MapLayerManager
                                                    layers={worldData?.mapLayers || (worldData?.mapImageUrl ? [{ id: 'default', name: '標準マップ', url: worldData.mapImageUrl }] : [])}
                                                    onUpdate={handleMapLayersUpdate}
                                                    storage={storage}
                                                    appContextId={appContextId}
                                                />
                                            </div>

                                            <div className="flex items-center justify-between">
                                                <div>
                                                    <div className="text-sm font-bold">地域タグ自動付与</div>
                                                    <div className="text-xs text-gray-500">座標に応じたタグ割り当てルールを設定します</div>
                                                </div>
                                                <div className="flex gap-2">
                                                    <button onClick={handleReapplyRegionTags} className="px-3 py-1.5 bg-gray-500 text-white rounded text-sm hover:bg-gray-600" title="現在のルールに基づいてタグを再計算・追加します">再適用</button>
                                                    <button onClick={() => { setShowRegionRuleEditor(true); setShowAdminPanel(false); }} className="px-3 py-1.5 bg-emerald-600 text-white rounded text-sm">編集</button>
                                                </div>
                                            </div>
                                            <div className="flex items-center justify-between pt-4 border-t">
                                                <div>
                                                    <div className="text-sm font-bold">メインページ設定</div>
                                                    <div className="text-xs text-gray-500">
                                                        {worldData?.mainPageId ? `現在: ${articles.find(a => a.id === worldData.mainPageId)?.title || worldData.mainPageId}` : '未設定'}
                                                    </div>
                                                </div>
                                                <button onClick={() => {
                                                    const pageId = prompt('メインページにする記事IDを入力してください（解除する場合は空欄）:', worldData?.mainPageId || '');
                                                    if (pageId !== null) handleSetMainPage(pageId);
                                                }} className="px-3 py-1.5 bg-indigo-500 text-white rounded text-sm">設定</button>
                                            </div>
                                            <div className="flex items-center justify-between pt-4 border-t">
                                                <div>
                                                    <div className="text-sm font-bold">Discord Webhook設定</div>
                                                    <div className="text-xs text-gray-500">記事更新通知の送信先</div>
                                                </div>
                                                <button onClick={async () => {
                                                    const currentUrl = worldData?.discordWebhookUrl || '';
                                                    const newUrl = prompt('Discord Webhook URLを入力:', currentUrl);
                                                    if (newUrl !== null) {
                                                        try {
                                                            const { doc, updateDoc } = window.firebaseModules;
                                                            await updateDoc(doc(db, 'artifacts', appContextId, 'public', 'data', 'worlds', worldId), { discordWebhookUrl: newUrl });
                                                            alert('Webhook URLを保存しました');
                                                        } catch (e) { alert('保存失敗: ' + e.message); }
                                                    }
                                                }} className="px-3 py-1.5 bg-indigo-500 text-white rounded text-sm">設定</button>
                                            </div>
                                            <div className="flex items-center justify-between pt-4 border-t">
                                                <div>
                                                    <div className="text-sm font-bold">Spreadsheet Proxy URL</div>
                                                    <div className="text-xs text-gray-500">Google Sheets API Proxy (GAS) URL</div>
                                                </div>
                                                <button onClick={async () => {
                                                    const current = worldData?.spreadsheetProxyUrl || '';
                                                    const input = prompt('GAS WebアプリのURLを入力してください:', current);
                                                    if (input !== null) {
                                                        try {
                                                            const { doc, updateDoc } = window.firebaseModules;
                                                            await updateDoc(doc(db, 'artifacts', appContextId, 'public', 'data', 'worlds', worldId), { spreadsheetProxyUrl: input });
                                                            alert('Proxy URLを保存しました');
                                                        } catch (e) { alert('保存失敗: ' + e.message); }
                                                    }
                                                }} className="px-3 py-1.5 bg-indigo-500 text-white rounded text-sm">設定</button>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            )}
                        </div>
                    </div >
                </div >
            );
        };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>

</html>