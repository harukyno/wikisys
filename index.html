<!DOCTYPE html>
<html lang="ja">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, user-scalable=yes">
    <title>WorldWeaver - 次世代創作Wiki</title>

    <!-- React & ReactDOM -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>

    <!-- Babel -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>

    <!-- Leaflet -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

    <!-- Lucide Icons -->
    <script src="https://unpkg.com/lucide@latest"></script>

    <!-- Quill.js 2.0.2 -->
    <link href="https://cdn.jsdelivr.net/npm/quill@2.0.2/dist/quill.snow.css" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/quill@2.0.2/dist/quill.js"></script>

    <!-- Google Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link
        href="https://fonts.googleapis.com/css2?family=Noto+Sans+JP:wght@300;400;500;700&family=Shippori+Mincho:wght@400;600&display=swap"
        rel="stylesheet">
    <!-- JSpreadsheet (Excel-like Grid) -->
    <script src="https://cdn.jsdelivr.net/npm/jspreadsheet-ce@4.13.1/dist/index.min.js"></script>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/jspreadsheet-ce@4.13.1/dist/jspreadsheet.min.css"
        type="text/css" />
    <script src="https://cdn.jsdelivr.net/npm/jsuites/dist/jsuites.min.js"></script>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/jsuites/dist/jsuites.min.css" type="text/css" />

    <!-- Firebase SDK -->
    <script type="module">
        import { initializeApp, deleteApp, getApps } from "https://www.gstatic.com/firebasejs/10.14.1/firebase-app.js";
        import { getAuth, signInWithEmailAndPassword, createUserWithEmailAndPassword, signInAnonymously, onAuthStateChanged, signOut, updateProfile, setPersistence, browserLocalPersistence } from "https://www.gstatic.com/firebasejs/10.14.1/firebase-auth.js";
        import { getFirestore, collection, doc, setDoc, addDoc, updateDoc, deleteDoc, onSnapshot, serverTimestamp, query, where, getDoc } from "https://www.gstatic.com/firebasejs/10.14.1/firebase-firestore.js";
        import { getStorage, ref, uploadBytes, getDownloadURL } from "https://www.gstatic.com/firebasejs/10.14.1/firebase-storage.js";

        window.firebaseModules = {
            initializeApp, deleteApp, getApps,
            getAuth, signInWithEmailAndPassword, createUserWithEmailAndPassword, signInAnonymously, onAuthStateChanged, signOut, updateProfile, setPersistence, browserLocalPersistence,
            getFirestore, collection, doc, setDoc, addDoc, updateDoc, deleteDoc, onSnapshot, serverTimestamp, query, where, getDoc,
            getStorage, ref, uploadBytes, getDownloadURL
        };
    </script>

    <style>
        /* フォント指定 */
        body {
            font-family: 'Noto Sans JP', sans-serif;
            background-color: #f3f4f6;
        }

        .serif {
            font-family: 'Shippori Mincho', serif;
        }

        .googlesheet-container iframe {
            width: 100%;
            height: 100%;
        }

        /* JSpreadsheet Custom Overrides */
        .jexcel>thead>tr>td {
            background-color: #f8fafc;
            font-weight: bold;
            color: #475569;
        }

        .jexcel>tbody>tr>td {
            font-size: 13px;
        }

        /* その他のスタイル */
        #map-container {
            height: 100%;
            width: 100%;
            z-index: 0;
        }

        .wiki-link {
            color: #2563eb;
            text-decoration: underline;
            cursor: pointer;
        }

        .wiki-link:hover {
            color: #1d4ed8;
            background-color: rgba(37, 99, 235, 0.1);
        }

        .folder-tree-item {
            cursor: pointer;
            user-select: none;
        }

        .folder-tree-item:hover {
            background-color: #f3f4f6;
        }

        .rich-editor h1 {
            font-size: 1.5em;
            font-weight: bold;
            margin: 0.5em 0;
        }

        .rich-editor h2 {
            font-size: 1.3em;
            font-weight: bold;
            margin: 0.5em 0;
            border-bottom: 1px solid #ddd;
        }

        .rich-editor ul {
            list-style-type: disc;
            margin-left: 1.5em;
        }

        .rich-editor ol {
            list-style-type: decimal;
            margin-left: 1.5em;
        }

        .rich-editor blockquote {
            border-left: 4px solid #ccc;
            padding-left: 1em;
            color: #666;
        }

        /* Quill Editor Customization */
        .ql-container {
            font-family: 'Noto Sans JP', sans-serif;
            font-size: 16px;
        }

        .ql-editor {
            min-height: 200px;
        }

        /* カスタムスクロールバー */
        .custom-scrollbar::-webkit-scrollbar {
            width: 6px;
            height: 6px;
        }

        .custom-scrollbar::-webkit-scrollbar-track {
            background: #f1f1f1;
        }

        .custom-scrollbar::-webkit-scrollbar-thumb {
            background: #ccc;
            border-radius: 3px;
        }

        .custom-scrollbar::-webkit-scrollbar-thumb:hover {
            background: #aaa;
        }

        /* テーブルの基本スタイル（記事表示用） */
        .rich-editor table,
        .prose table {
            border-collapse: collapse;
            width: 100%;
            margin: 1rem 0;
            border: 1px solid #444;
            background-color: rgba(255, 255, 255, 0.05);
        }

        .rich-editor th,
        .rich-editor td,
        .prose th,
        .prose td {
            border: 1px solid #444;
            padding: 8px;
            text-align: left;
        }

        .rich-editor th,
        .prose th {
            background-color: rgba(255, 255, 255, 0.1);
            font-weight: bold;
        }

        /* ダークモード環境用（.prose-invertなど） */
        .prose-invert table,
        .prose-invert th,
        .prose-invert td {
            border-color: #475569;
            /* slate-600 */
        }

        /* Placeholder style when table HTML is omitted from editor content */
        .csv-block .csv-placeholder {
            border: 1px dashed #666;
            padding: 8px;
            background: #fff;
            color: #222;
            font-size: 13px;
            border-radius: 6px;
            text-align: center;
        }

        /* スナップスクロール用 */
        .snap-y-mandatory {
            scroll-snap-type: y mandatory;
        }

        .snap-center {
            scroll-snap-align: center;
        }

        .snap-x-mandatory {
            scroll-snap-type: x mandatory;
        }

        .snap-start {
            scroll-snap-align: start;
        }

        /* マインドマップ風ライン */
        .mindmap-branch {
            position: absolute;
            left: -2rem;
            top: 50%;
            width: 2rem;
            height: 1px;
            background-color: rgba(255, 255, 255, 0.3);
        }

        /* タイムラインメーター */
        .timeline-ruler {
            background-image: linear-gradient(to bottom, rgba(255, 255, 255, 0.2) 1px, transparent 1px);
            background-size: 100% 40px;
        }

        /* スムーズスクロール */
        .scroll-smooth {
            scroll-behavior: smooth;
        }

        /* マップラベル */
        .leaflet-tooltip.map-label {
            background-color: rgba(255, 255, 255, 0.85);
            border: 1px solid rgba(0, 0, 0, 0.1);
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.2);
            font-size: 11px;
            font-weight: bold;
            color: #333;
            padding: 0px 4px;
            border-radius: 4px;
            margin-top: -3px;
        }
    </style>
</head>

<body>
    <div id="root"></div>

    <script type="text/babel">
        // --- デフォルト設定 ---
        const DEFAULT_CONFIG = {
            apiKey: "AIzaSyDp-ct-XP-4O-6Z_sZVFjyrgmDGbTplCps",
            authDomain: "rtts-studio.firebaseapp.com",
            projectId: "rtts-studio",
            storageBucket: "rtts-studio.firebasestorage.app",
            messagingSenderId: "980630089634",
            appId: "1:980630089634:web:7a3ee9ed7e118b99598cfb",
            measurementId: "G-D5YX71KKVP"
        };

        // 初期のデータID
        const DEFAULT_APP_CONTEXT_ID = 'world-weaver-wiki-v4';

        const ARTICLE_TYPES = {
            person: { label: '人物', color: 'bg-blue-100 text-blue-800', icon: 'user' },
            event: { label: '事象', color: 'bg-red-100 text-red-800', icon: 'flame' },
            region: { label: '地域', color: 'bg-green-100 text-green-800', icon: 'map' },
            organization: { label: '組織', color: 'bg-purple-100 text-purple-800', icon: 'building' },
            ideology: { label: '思想・宗教', color: 'bg-emerald-100 text-emerald-800', icon: 'star' },
            item: { label: '物品', color: 'bg-amber-100 text-amber-800', icon: 'package' },
            story: { label: '物語', color: 'bg-pink-100 text-pink-800', icon: 'book-open' },
            spreadsheet: { label: 'データ表', color: 'bg-cyan-100 text-cyan-800', icon: 'table-2' },
            other: { label: 'その他', color: 'bg-gray-100 text-gray-800', icon: 'box' }
        };

        // 重要度ごとのスタイル定義
        const getImportanceStyle = (imp) => {
            const v = Number(imp) || 3;
            if (v >= 5) return {
                card: 'border-amber-400/60 shadow-[0_0_15px_rgba(251,191,36,0.2)]',
                tag: 'bg-amber-900/40 border-amber-500/50 text-amber-100',
                badge: '⭐️⭐️⭐️⭐️⭐️'
            };
            if (v === 4) return {
                card: 'border-purple-400/50 shadow-[0_0_10px_rgba(168,85,247,0.15)]',
                tag: 'bg-purple-900/40 border-purple-500/50 text-purple-100',
                badge: '⭐️⭐️⭐️⭐️'
            };
            if (v === 3) return {
                card: 'border-blue-400/30',
                tag: 'bg-blue-900/40 border-blue-500/50 text-blue-100',
                badge: '⭐️⭐️⭐️'
            };
            if (v === 2) return {
                card: 'border-slate-600/30',
                tag: 'bg-slate-800/60 border-slate-600/50 text-slate-300',
                badge: '⭐️⭐️'
            };
            return {
                card: 'border-gray-700/20 opacity-90',
                tag: 'bg-gray-800/60 border-gray-700/50 text-gray-400',
                badge: '⭐️'
            };
        };

        const getImportanceClass = (imp) => getImportanceStyle(imp).tag;

        // ビュー設定：構造年表（Large Timeline）をメインの年表として統合
        const VIEW_TABS = [
            { key: 'list', label: '一覧', icon: 'list' },
            { key: 'map', label: '地図', icon: 'map' },
            { key: 'timeline_large', label: '構造年表', icon: 'git-branch' },
            { key: 'spreadsheet', label: 'データ', icon: 'table-2' },
            { key: 'stats', label: '統計', icon: 'bar-chart-2' },
            { key: 'wiki', label: 'Wiki閲覧', icon: 'book-open' }
        ];

        // Region tag rules: define rectangles or circles to auto-assign tags when a location falls inside.
        // Rectangle example: { tag: 'north', type: 'rect', bounds: { latMin: -500, latMax: 500, lngMin: -500, lngMax: 0 } }
        // Circle example: { tag: 'capital', type: 'circle', center: { lat: 0, lng: 0 }, radiusKm: 100 }
        // Leave empty to disable auto region tags.
        const REGION_TAG_RULES = [
            // { tag: 'north', type: 'rect', bounds: { latMin: -500, latMax: 500, lngMin: -500, lngMax: 0 } },
            // { tag: 'capital', type: 'circle', center: { lat: 0, lng: 0 }, radiusKm: 100 }
        ];

        // Region auto-tag rules default (editable via GUI)
        const REGION_TAG_RULES_DEFAULT = [
            // { tag: 'north', type: 'rect', bounds: { latMin: -500, latMax: 500, lngMin: -500, lngMax: 0 } },
            // { tag: 'capital', type: 'circle', center: { lat: 0, lng: 0 }, radiusKm: 100 }
        ];

        const createEmptyArticle = () => ({
            title: '',
            type: 'person',
            folder: '未分類',
            contentHtml: '',
            year: 0,
            period: { start: '', end: '' }, // 期間設定用
            dateStr: '',
            representedTag: '',
            locations: [], // 複数地点用 { lat, lng, label }
            locationArticleId: '',
            mainImageUrl: ''
            , noYear: false
            , importance: 3 // 重要度 (1-5)
            , attachments: [] // { name, url }
            , _editorMode: 'wysiwyg' // default editor view
        });

        const stripHtml = (html = '') => html.replace(/<[^>]*>/g, ' ');

        const escapeHtml = (str) => {
            if (!str) return '';
            return str.replace(/[&<>"']/g, (m) => ({ '&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;', "'": '&#39;' }[m]));
        };

        const applyRuby = (str) => {
            if (!str) return '';
            let s = str;
            // Explicit Ruby |Kanji《Furi》 or ｜Kanji《Furi》
            s = s.replace(/[\|｜]([^《]+)《([^》]+)》/g, '<ruby>$1<rt>$2</rt></ruby>');
            // Auto Kanji Ruby Kanji《Furi》
            s = s.replace(/([一-龠々〆ヵヶ]+)《([^》]+)》/g, '<ruby>$1<rt>$2</rt></ruby>');
            // Safe Ruby ruby{Kanji|Furi}
            s = s.replace(/ruby\{([^}|]+)\|([^}]+)\}/g, '<ruby>$1<rt>$2</rt></ruby>');
            return s;
        };

        // 年代抽出ユーティリティ
        const parseYear = (val) => {
            if (!val) return 0;
            if (typeof val === 'number') return val;
            // 文字列の場合、先頭の数字（負号含む）を年とみなす
            const match = val.toString().match(/^(\-?\d+)/);
            return match ? parseInt(match[1], 10) : 0;
        };

        // ソート用キー計算（期間がある場合は平均年を使用）
        const getArticleYear = (article) => {
            if (article.period && (article.period.start || article.period.end)) {
                const start = parseYear(article.period.start) || parseYear(article.year);
                const end = parseYear(article.period.end) || start;
                return (start + end) / 2;
            }
            // dateStrがある場合はそちらを優先
            if (article.dateStr) {
                return parseYear(article.dateStr);
            }
            return article.year || 0;
        };

        const chronologyKey = (article) => {
            const y = getArticleYear(article);
            // ゼロ埋めして文字列化（マイナス年も考慮してオフセットを加える簡易実装）
            return String(Math.floor(y + 100000)).padStart(10, '0');
        };

        const sortByChronology = (list = []) => [...list].sort((a, b) => {
            const ya = getArticleYear(a);
            const yb = getArticleYear(b);
            // treat missing/zero year as large value so they sort after dated items
            const va = (!ya || Number.isNaN(ya) || Number(ya) === 0) ? Number.MAX_SAFE_INTEGER : ya;
            const vb = (!yb || Number.isNaN(yb) || Number(yb) === 0) ? Number.MAX_SAFE_INTEGER : yb;
            return va - vb;
        });

        const filterTimelineArticles = (articles = [], filters = { type: 'all', keyword: '', tag: '', excludeNoYear: false }) => {
            const keyword = (filters.keyword || '').trim().toLowerCase();
            const tag = (filters.tag || '').replace(/^#/, '').trim().toLowerCase();
            const type = (filters.type || 'all');
            const minImportance = Number(filters.minImportance) || 0;
            return sortByChronology(articles).filter(article => {
                if (filters.excludeNoYear) {
                    const y = getArticleYear(article);
                    if (!y || Number.isNaN(y) || Number(y) === 0) return false;
                }
                if (filters.onlyApproved && !article.isApproved) return false;
                if (type !== 'all' && article.type !== type) return false;
                if (minImportance > 0 && (article.importance || 3) < minImportance) return false;
                if (keyword) {
                    const haystack = [
                        article.title,
                        article.folder,
                        stripHtml(article.contentHtml || ''),
                        (article.tags || []).join(' '),
                        article.representedTag || ''
                    ].join(' ').toLowerCase();
                    if (!haystack.includes(keyword)) return false;
                }
                if (tag) {
                    const tags = (article.tags || []).map(t => t.toLowerCase());
                    const rep = (article.representedTag || '').toLowerCase();
                    if (!tags.includes(tag) && rep !== tag) return false;
                }
                return true;
            });
        };

        // 記事が持つ全ての地点を取得
        const getArticleLocations = (article) => {
            if (!article) return [];
            const locs = [];
            // 新仕様: locations配列
            if (article.locations && Array.isArray(article.locations)) {
                article.locations.forEach(l => {
                    if (l.lat != null && l.lng != null) locs.push({ lat: parseFloat(l.lat), lng: parseFloat(l.lng), label: l.label || article.title, sourceId: article.id });
                });
            }
            // 旧仕様: lat, lng (互換性のため)
            if (article.lat != null && article.lng != null && article.lat !== '' && article.lng !== '') {
                const lat = parseFloat(article.lat);
                const lng = parseFloat(article.lng);
                // 重複チェック（簡易）
                if (!locs.some(l => Math.abs(l.lat - lat) < 0.0001 && Math.abs(l.lng - lng) < 0.0001)) {
                    locs.push({ lat, lng, label: article.title, sourceId: article.id });
                }
            }
            return locs;
        };

        // 再帰的に場所解決
        const resolveArticleLocation = (article, lookup = new Map(), visited = new Set()) => {
            if (!article) return null;
            const locs = getArticleLocations(article);
            if (locs.length > 0) return locs[0]; // 代表地点を返す

            if (article.locationArticleId) {
                if (visited.has(article.locationArticleId)) return null;
                visited.add(article.locationArticleId);
                return resolveArticleLocation(lookup.get(article.locationArticleId), lookup, visited);
            }
            return null;
        };

        // haversine distance (km) for circle-based region checks
        const haversineDistanceKm = (a, b) => {
            const R = 6371;
            const toRad = (x) => (x * Math.PI) / 180;
            const dLat = toRad(b.lat - a.lat);
            const dLng = toRad(b.lng - a.lng);
            const lat1 = toRad(a.lat);
            const lat2 = toRad(b.lat);
            const sinDLat = Math.sin(dLat / 2);
            const sinDLng = Math.sin(dLng / 2);
            const h = sinDLat * sinDLat + Math.cos(lat1) * Math.cos(lat2) * sinDLng * sinDLng;
            return 2 * R * Math.asin(Math.min(1, Math.sqrt(h)));
        };

        const computeRegionTags = (locations = [], rules = REGION_TAG_RULES_DEFAULT) => {
            const tags = new Set();
            if (!Array.isArray(locations) || locations.length === 0) return [];
            (rules || []).forEach(rule => {
                if (!rule || !rule.tag) return;
                if (rule.type === 'rect' && rule.bounds) {
                    const { latMin, latMax, lngMin, lngMax } = rule.bounds;
                    locations.forEach(loc => {
                        if (loc.lat == null || loc.lng == null) return;
                        if (loc.lat >= latMin && loc.lat <= latMax && loc.lng >= lngMin && loc.lng <= lngMax) {
                            tags.add(rule.tag);
                        }
                    });
                } else if (rule.type === 'circle' && rule.center && rule.radiusKm != null) {
                    locations.forEach(loc => {
                        if (loc.lat == null || loc.lng == null) return;
                        const d = haversineDistanceKm(rule.center, { lat: Number(loc.lat), lng: Number(loc.lng) });
                        if (d <= rule.radiusKm) tags.add(rule.tag);
                    });
                }
            });
            return Array.from(tags);
        };

        const getAdjacentArticles = (articles = [], currentId = null) => {
            if (!currentId) return { previous: null, next: null };
            const idx = articles.findIndex(a => a.id === currentId);
            return {
                previous: idx > 0 ? articles[idx - 1] : null,
                next: idx >= 0 && idx < articles.length - 1 ? articles[idx + 1] : null
            };
        };

        // Wiki Plugin Processor & Parser (PukiWiki Style)
        let parsePukiWikiSyntax; // Forward declaration

        const processPukiWikiPlugin = (name, args, content, isBlock) => {
            const argList = (args || '').split(',').map(s => s.trim());

            if (name.toLowerCase() === 'br') return '<br />';

            if (name === 'size') {
                return `<span style="font-size:${argList[0]}px">${content}</span>`;
            }
            if (name === 'color') {
                return `<span style="color:${argList[0]}; ${argList[1] ? 'background-color:' + argList[1] : ''}">${content}</span>`;
            }
            if (name === 'attachref' || name === 'ref') {
                const src = argList[0] || content;
                let w, h;
                if (argList[1]) {
                    const dim = argList[1].match(/(\d+)x(\d+)/);
                    if (dim) { w = dim[1]; h = dim[2]; }
                    else if (argList[1].endsWith('%')) { w = argList[1]; }
                }
                return `<img src="${src}" style="${w ? 'width:' + w + (w.includes('%') ? '' : 'px') + ';' : ''} ${h ? 'height:' + h + 'px;' : ''}" class="inline-block" />`;
            }
            if (name === 'cssbox') {
                return `<div style="${args}">${parsePukiWikiSyntax ? parsePukiWikiSyntax(content) : content}</div>`;
            }
            if (name === 'flex_container') {
                const [jus, ali, wrp] = argList;
                let style = 'display:flex; gap:10px;';
                if (jus) style += `justify-content:${jus};`;
                if (ali) style += `align-items:${ali};`;
                if (wrp) style += `flex-wrap:${wrp};`;
                return `<div style="${style}">${parsePukiWikiSyntax ? parsePukiWikiSyntax(content) : content}</div>`;
            }
            if (name === 'flex_box') {
                const w = argList[0];
                return `<div style="${w ? 'flex-basis:' + w + '; width:' + w + ';' : 'flex:1;'}">${parsePukiWikiSyntax ? parsePukiWikiSyntax(content) : content}</div>`;
            }
            if (name === 'skin') return content;
            if (name === 'marquee') return `<marquee>${args}</marquee>`;
            if (name === 'contents') return '';
            if (name === 'fold') return `<details><summary class="cursor-pointer font-bold text-indigo-600">${args || '詳細'}</summary><div class="pl-4 border-l-2 ml-1 mt-1">${parsePukiWikiSyntax ? parsePukiWikiSyntax(content) : content}</div></details>`;
            if (name === 'comment') return '<div class="text-xs text-gray-400 p-2 border bg-gray-50 my-2">[コメント欄]</div>';
            if (name === 'googlesheet') {
                const url = argList[0] || '';
                if (!url) return '<div class="p-4 bg-red-50 text-red-500 text-xs text-center">GoogleスプレッドシートのURLを指定してください</div>';

                // URL互換性向上ロジック: さまざまな共有形式を埋め込み用(preview)に変換
                // pubhtmlは「ウェブに公開」されたシート用。GAS作成直後は「リンク共有」のみなので preview が安全。
                let embedUrl = url;
                if (url.includes('docs.google.com/spreadsheets')) {
                    if (url.includes('/pubhtml')) {
                        // 既に pubhtml ならそのまま (パラメータだけ調整してもよいが、一旦そのまま)
                    } else {
                        // /edit, /view などを /preview に置換
                        embedUrl = url.replace(/\/(edit|view|preview|htmlview)(.*)$/, '/preview');
                    }
                }

                // 編集用URL（/editに変更）
                const editUrl = url.replace(/\/(preview|pubhtml|view|htmlview).*$/, '/edit');

                return `<div class="googlesheet-container my-4 border rounded overflow-hidden shadow-sm bg-white">
                    <div class="flex items-center justify-between bg-slate-100 px-3 py-1.5 border-b">
                        <span class="text-xs text-slate-600 font-medium flex items-center gap-1">
                            <img src="https://www.gstatic.com/images/branding/product/1x/sheets_2020q4_48dp.png" class="w-4 h-4" />
                            Googleスプレッドシート
                        </span>
                        <a href="${editUrl}" target="_blank" rel="noopener noreferrer" 
                           class="text-xs bg-green-600 text-white px-3 py-1 rounded hover:bg-green-700 transition-colors font-bold flex items-center gap-1">
                            ✏️ Googleで編集
                        </a>
                    </div>
                    <div style="height:450px">
                        <iframe src="${embedUrl}" class="w-full h-full border-0"></iframe>
                    </div>
                </div>`;
            }
            if (name === 'datatable') {
                const folder = argList.find(a => a.startsWith('folder='))?.split('=')[1] || '';
                const tag = argList.find(a => a.startsWith('tag='))?.split('=')[1] || '';
                const id = 'dt-' + Math.random().toString(36).substr(2, 9);

                // 動的に読み込むためのプレースホルダ
                setTimeout(async () => {
                    const el = document.getElementById(id);
                    if (!el || !window.articles) return;

                    const filtered = window.articles.filter(a => {
                        if (folder && a.folder !== folder) return false;
                        if (tag && !(a.tags || []).includes(tag)) return false;
                        return true;
                    }).sort((a, b) => (a.year || 0) - (b.year || 0));

                    if (filtered.length === 0) {
                        el.innerHTML = '<div class="p-4 text-gray-400 text-xs italic">該当する記事が見つかりません。</div>';
                        return;
                    }

                    // マッピング設定を取得
                    const mappings = window.worldData?.sheetFieldMappings || [];

                    // 各記事のスプレッドシートデータを取得する関数
                    const fetchSheetData = async (article) => {
                        // 記事内容からスプレッドシートURLを抽出
                        const content = article.contentHtml || '';
                        const sheetMatch = content.match(/#googlesheet\(([^)]+)\)/);
                        if (!sheetMatch || mappings.length === 0) return {};

                        const sheetUrl = sheetMatch[1];
                        const sheetIdMatch = sheetUrl.match(/\/d\/([a-zA-Z0-9-_]+)/);
                        if (!sheetIdMatch) return {};

                        const sheetId = sheetIdMatch[1];
                        const proxyUrl = window.worldData?.spreadsheetProxyUrl;
                        if (!proxyUrl) return {};

                        // GAS経由でセル値を取得 (JSONP)
                        return new Promise((resolve) => {
                            const callbackName = 'sheet_cb_' + Math.random().toString(36).substr(2, 9);
                            const timeout = setTimeout(() => {
                                delete window[callbackName];
                                resolve({});
                            }, 10000);

                            window[callbackName] = (res) => {
                                clearTimeout(timeout);
                                delete window[callbackName];
                                const s = document.getElementById(callbackName);
                                if (s) s.remove();

                                if (res.status === 'success' && res.values) {
                                    // マッピングに従ってフィールド値を作成
                                    const result = {};
                                    mappings.forEach(m => {
                                        if (res.values[m.cell] !== undefined) {
                                            result[m.field] = res.values[m.cell];
                                        }
                                    });
                                    resolve(result);
                                } else {
                                    resolve({});
                                }
                            };

                            const cells = mappings.map(m => m.cell).join(',');
                            const params = new URLSearchParams();
                            params.set('callback', callbackName);
                            params.set('action', 'getCellValues');
                            params.set('sheetId', sheetId);
                            params.set('cells', cells);

                            const script = document.createElement('script');
                            script.id = callbackName;
                            script.src = proxyUrl + (proxyUrl.includes('?') ? '&' : '?') + params.toString();
                            document.body.appendChild(script);
                        });
                    };

                    // ローディング表示
                    el.innerHTML = '<div class="p-4 text-gray-400 text-xs italic text-center">データ読み込み中...</div>';

                    // 全記事のシートデータを取得（並列実行）
                    const sheetDataPromises = filtered.map(a => fetchSheetData(a));
                    const sheetDataResults = await Promise.all(sheetDataPromises);

                    // 記事データにシートデータをマージ
                    const enrichedArticles = filtered.map((a, i) => ({
                        ...a,
                        sheetData: sheetDataResults[i]
                    }));

                    const wikiLinkRenderer = (instance, td, col, row, index, val) => {
                        td.innerHTML = parsePukiWikiSyntax ? parsePukiWikiSyntax(val) : val;
                    };

                    // 基本列 + マッピング列を構築
                    const baseColumns = [
                        { type: 'text', title: 'ID', width: 60, readOnly: true },
                        { type: 'text', title: 'タイトル', width: 200, readOnly: true, renderer: wikiLinkRenderer },
                        { type: 'numeric', title: '年代', width: 80 },
                        { type: 'numeric', title: '重要度', width: 60 },
                    ];

                    // マッピングで定義されたフィールドを列として追加
                    const mappingColumns = mappings.map(m => ({
                        type: 'text',
                        title: m.field,
                        width: 100,
                        readOnly: true
                    }));

                    const allColumns = [...baseColumns, ...mappingColumns];

                    // データ行を構築
                    const data = enrichedArticles.map(a => {
                        const baseRow = [a.id, `[[${a.title}|${a.id}]]`, a.year || 0, a.importance || 3];
                        const mappingValues = mappings.map(m => a.sheetData[m.field] ?? '');
                        return [...baseRow, ...mappingValues];
                    });

                    el.innerHTML = ''; // ローディング表示をクリア

                    jspreadsheet(el, {
                        data: data,
                        columns: allColumns,
                        onchange: async (instance, cell, col, row, val) => {
                            const articleId = instance.jexcel.getValueFromCoords(0, row);
                            const field = col === 2 ? 'year' : col === 3 ? 'importance' : null;
                            if (field && articleId) {
                                try {
                                    const { doc, updateDoc } = window.firebaseModules;
                                    const db = window.db;
                                    const ctx = window.appContextId;
                                    const w = window.worldId;
                                    await updateDoc(doc(db, 'artifacts', ctx, 'public', 'data', 'worlds', w, 'articles', articleId), {
                                        [field]: Number(val)
                                    });
                                } catch (e) { console.error(e); }
                            }
                        },
                        search: true,
                        pagination: 10,
                    });
                }, 100);

                return `<div class="wiki-datatable my-6 p-2 bg-slate-50 border rounded-lg shadow-inner overflow-hidden">
                    <div class="px-2 py-1 text-[10px] font-bold text-slate-400 uppercase tracking-wider flex items-center gap-1">
                        <i data-lucide="database" class="w-3 h-3"></i> データベース自動集計: ${folder || tag || '全て'}
                    </div>
                    <div id="${id}" class="mt-2 text-sm"></div>
                </div>`;
            }
            return null;
        };

        parsePukiWikiSyntax = (text) => {
            if (!text) return '';

            // 0. Pre-process HTML
            const decodeHtml = (html) => {
                const txt = document.createElement("textarea");
                txt.innerHTML = html;
                return txt.value;
            };

            let cleanText = text
                .replace(/\r/g, '') // Normalize newlines
                .replace(/<br\s*\/?>/gi, '&br;')
                .replace(/<\/p>/gi, '\n')
                .replace(/<div>/gi, '\n')
                .replace(/<\/div>/gi, '\n')
                .replace(/<\/tr>/gi, '\n')
                .replace(/<\/li>/gi, '\n');

            cleanText = decodeHtml(cleanText);

            let res = cleanText;

            // 1. Recursive Layout/Block Plugin Parser
            for (let i = 0; i < 20; i++) {
                const regex = /(?:#|&)([a-zA-Z0-9_]+)(?:\(([^)]*)\))?(\{+)([\s\S]*?)(\}+)(;?)/g;
                let matched = false;
                res = res.replace(regex, (m, name, args, open, content, close, semi) => {
                    if (open.length !== close.length) return m;
                    matched = true;
                    // The recursive call happens inside processPukiWikiPlugin now
                    const p = processPukiWikiPlugin(name, args, content, open.startsWith('#'));
                    return p !== null ? p : m;
                });
                if (!matched) break;
            }

            const splitTableRow = (rowStr) => {
                const cells = [];
                let current = '';
                let depthBracket = 0;
                let depthBrace = 0;
                for (let i = 0; i < rowStr.length; i++) {
                    const char = rowStr[i];
                    if (char === '[' && rowStr[i + 1] === '[') { depthBracket++; i++; current += '[['; continue; }
                    if (char === ']' && rowStr[i + 1] === ']') { depthBracket--; i++; current += ']]'; continue; }
                    if (char === '{') depthBrace++;
                    if (char === '}') depthBrace--;
                    if (char === '|' && depthBracket === 0 && depthBrace === 0) {
                        cells.push(current);
                        current = '';
                    } else {
                        current += char;
                    }
                }
                cells.push(current);
                return cells;
            };



            const processInline = (str) => {
                let s = str;
                for (let i = 0; i < 10; i++) {
                    let replaced = false;
                    s = s.replace(/(&|#)([a-zA-Z0-9_]+)(?:\(([^)]*)\))?(?:\{([^}]*)\})?(;?)/g, (m, type, name, args, blockContent, semi) => {
                        replaced = true;
                        const p = processPukiWikiPlugin(name, args, blockContent || '', type === '#');
                        return p !== null ? p : m;
                    });
                    if (!replaced) break;
                }
                s = s.replace(/'''([^']+)'''/g, '<i>$1</i>');
                s = s.replace(/''([^']+)''/g, '<b>$1</b>');
                s = s.replace(/\[\[([^\]|]+)\|([^\]]+)\]\]/g, '<span class="wiki-link" data-article-id="$2">🔗 $1</span>');
                s = s.replace(/\[\[([^\]]+)\]\]/g, '<span class="wiki-link" data-wiki-title="$1">🔗 $1</span>');

                // Ruby Support
                s = applyRuby(s);

                return s;
            };

            const lines = res.split('\n');
            const outLines = [];
            let inTable = false;
            let tableRows = [];

            const flushTable = () => {
                if (!inTable) return;
                let html = '<div class="overflow-x-auto my-2"><table class="wiki-table min-w-full border-collapse border border-gray-400 bg-white text-sm">';
                tableRows.forEach(row => {
                    html += '<tr>';
                    const cells = splitTableRow(row.trim());
                    if (cells.length > 0 && cells[0].trim() === '') cells.shift();
                    if (cells.length > 0 && cells[cells.length - 1].trim() === '') cells.pop();
                    if (cells.length === 0) return;
                    cells.forEach(cell => {
                        let c = cell;
                        let tag = 'td';
                        let style = 'border: 1px solid #cbd5e1; padding: 6px;';
                        while (true) {
                            c = c.trim();
                            if (c.startsWith('~')) { tag = 'th'; c = c.substring(1); style += 'background-color:#f1f5f9; font-weight:bold;'; continue; }
                            if (c.startsWith('BGCOLOR')) {
                                const m = c.match(/^BGCOLOR\(([^)]+)\):/);
                                if (m) { style += `background-color:${m[1]};`; c = c.substring(m[0].length); continue; }
                            }
                            if (c.startsWith('CENTER:')) { style += 'text-align:center;'; c = c.substring(7); continue; }
                            if (c.startsWith('LEFT:')) { style += 'text-align:left;'; c = c.substring(5); continue; }
                            if (c.startsWith('RIGHT:')) { style += 'text-align:right;'; c = c.substring(6); continue; }
                            if (c === '>') { c = '&nbsp;'; }
                            break;
                        }
                        html += `<${tag} style="${style}">${processInline(c)}</${tag}>`;
                    });
                    html += '</tr>';
                });
                html += '</table></div>';
                outLines.push(html);
                tableRows = [];
                inTable = false;
            };

            lines.forEach(line => {
                let l = line.trim();

                // Table
                if (l.startsWith('|')) {
                    inTable = true;
                    tableRows.push(l);
                    return;
                }
                flushTable();

                // Headers
                const parseHeader = (line, level) => {
                    let text = line.substring(level).trim();
                    let id = Math.random().toString(36).substr(2, 9);
                    const anchorMatch = text.match(/\[#([a-zA-Z0-9_-]+)\]$/);
                    if (anchorMatch) {
                        id = anchorMatch[1];
                        text = text.substring(0, text.length - anchorMatch[0].length).trim();
                    }
                    return { text, id };
                };

                if (l.startsWith('***')) { const h = parseHeader(l, 3); outLines.push(`<h4 id="${h.id}" class="text-lg font-bold mt-2 border-b border-gray-200 pb-1 flex items-center gap-2"><span class="w-1 h-4 bg-indigo-300 inline-block"></span>${processInline(h.text)}</h4>`); return; }
                if (l.startsWith('**')) { const h = parseHeader(l, 2); outLines.push(`<h3 id="${h.id}" class="text-xl font-bold mt-3 mb-2 border-b-2 border-indigo-100 flex items-center gap-2"><span class="w-2 h-2 rounded-full bg-indigo-500 inline-block"></span>${processInline(h.text)}</h3>`); return; }
                if (l.startsWith('*')) { const h = parseHeader(l, 1); outLines.push(`<h2 id="${h.id}" class="text-2xl font-bold mt-6 mb-3 border-b-2 border-indigo-600 pb-1 serif text-indigo-900">${processInline(h.text)}</h2>`); return; }

                // HR
                if (l.startsWith('----')) { outLines.push('<hr class="my-4 border-gray-300 border-dashed">'); return; }

                // Alignments
                if (l.startsWith('CENTER:')) { outLines.push(`<div class="text-center">${processInline(l.substring(7))}</div>`); return; }
                if (l.startsWith('LEFT:')) { outLines.push(`<div class="text-left">${processInline(l.substring(5))}</div>`); return; }
                if (l.startsWith('RIGHT:')) { outLines.push(`<div class="text-right">${processInline(l.substring(6))}</div>`); return; }

                if (l === '') { outLines.push('<br class="my-2" />'); return; }
                outLines.push(processInline(l) + '<br>');
            });
            flushTable();
            return outLines.join('\n');
        };

        // Wiki記法をHTMLリンクに変換する関数 (Wrapper)
        const transformContent = (html) => {
            if (!html) return '';

            // Explicit HTML Mode check
            if (html.trim().startsWith('<!-- html-mode -->') || html.trim().startsWith('<!DOCTYPE html>')) {
                // Just do simple link replacement
                let out = html.replace(/\[\[([^\]|]+)\|([^\]]+)\]\]/g, (match, title, id) => {
                    return `<span class="wiki-link" data-article-id="${id}">🔗 ${title}</span>`;
                });
                out = out.replace(/\[\[([^\]|]+)\]\]/g, (match, title) => {
                    const t = title.trim();
                    return `<span class="wiki-link" data-wiki-title="${t}">🔗 ${t}</span>`;
                });
                return out;
            }

            // Detect Wiki Syntax (Heuristic)
            // If it contains plugin syntax #plugin or &plugin or table | |
            // Updated to catch simple plugins ending with ; like &br;
            if (html.match(/(?:#|&)[a-zA-Z0-9_]+(?:[\(\{;])/) || html.match(/^\|.+\|$/m)) {
                // Ensure the function is defined before calling
                if (parsePukiWikiSyntax) return parsePukiWikiSyntax(html);
            }

            // Fallback for Standard HTML with simple Wiki Links
            let out = html.replace(/\[\[([^\]|]+)\|([^\]]+)\]\]/g, (match, title, id) => {
                return `<span class="wiki-link" data-article-id="${id}">🔗 ${title}</span>`;
            });
            out = out.replace(/\[\[([^\]|]+)\]\]/g, (match, title) => {
                const t = title.trim();
                return `<span class="wiki-link" data-wiki-title="${t}">🔗 ${t}</span>`;
            });
            return out;
        };

        const extractLinkedKeywords = (html = '') => {
            const keywords = new Set();
            let match;
            // 正規表現リテラルを使って修正
            const bracketRegex = /\[\[([^\]]+)\]\]/g;
            const dataRefRegex = /data-(?:link|ref)=\"([^\"]+)\"/g;
            const wikiLinkRegex = /class=\"wiki-link\"[^>]*>(.*?)<\//g;

            while ((match = bracketRegex.exec(html)) !== null) if (match[1]) keywords.add(match[1].trim());
            while ((match = dataRefRegex.exec(html)) !== null) if (match[1]) keywords.add(match[1].trim());
            while ((match = wikiLinkRegex.exec(html)) !== null) {
                const textValue = stripHtml(match[1] || '').trim();
                if (textValue) keywords.add(textValue);
            }
            return Array.from(keywords).filter(Boolean);
        };

        // ハイライトユーティリティ: HTML文字列中のテキストノードに対してキーワードをマークアップする
        const highlightHtml = (html = '', keyword = '') => {
            if (!keyword) return html || '';
            try {
                const parser = new DOMParser();
                const doc = parser.parseFromString(html || '', 'text/html');
                const esc = (s) => s.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
                const re = new RegExp(esc(keyword), 'ig');
                const walker = doc.createTreeWalker(doc.body, NodeFilter.SHOW_TEXT, null, false);
                const nodes = [];
                while (walker.nextNode()) nodes.push(walker.currentNode);
                nodes.forEach(t => {
                    const parent = t.parentNode;
                    if (!parent) return;
                    const text = t.nodeValue;
                    if (!text) return;
                    if (re.test(text)) {
                        const frag = document.createDocumentFragment();
                        let lastIndex = 0;
                        text.replace(re, (match, offset) => {
                            const idx = arguments[arguments.length - 2];
                            if (idx > lastIndex) frag.appendChild(document.createTextNode(text.substring(lastIndex, idx)));
                            const mark = doc.createElement('mark');
                            mark.textContent = match;
                            frag.appendChild(mark);
                            lastIndex = idx + match.length;
                            return match;
                        });
                        if (lastIndex < text.length) frag.appendChild(document.createTextNode(text.substring(lastIndex)));
                        parent.replaceChild(frag, t);
                    }
                });
                return doc.body.innerHTML;
            } catch (e) { return html; }
        };

        const Icon = ({ name, size = 20, className = "" }) => {
            const ref = React.useRef(null);
            React.useEffect(() => {
                if (window.lucide && ref.current) {
                    const i = document.createElement('i');
                    i.setAttribute('data-lucide', name);
                    i.setAttribute('width', size);
                    i.setAttribute('height', size);
                    if (className) i.className = className;
                    ref.current.innerHTML = '';
                    ref.current.appendChild(i);
                    window.lucide.createIcons({ root: ref.current });
                }
            }, [name, size, className]);
            return <span ref={ref} style={{ display: 'inline-flex', lineHeight: 0, verticalAlign: 'middle' }}></span>;
        };

        // ユーティリティ: テキストコピー
        const copyText = (text) => {
            if (navigator.clipboard && navigator.clipboard.writeText) {
                navigator.clipboard.writeText(text).then(() => alert("コピーしました: " + text)).catch(e => alert("コピー失敗"));
            } else {
                const textArea = document.createElement("textarea");
                textArea.value = text;
                textArea.style.position = "fixed";
                textArea.style.left = "-9999px";
                document.body.appendChild(textArea);
                textArea.focus();
                textArea.select();
                try { document.execCommand('copy'); alert("コピーしました: " + text); } catch (err) { alert("コピー失敗"); }
                document.body.removeChild(textArea);
            }
        };

        // --- Config Editor ---
        const ConfigEditor = ({ currentConfig, currentAppId, onSave, onCancel }) => {
            const [text, setText] = React.useState(`const firebaseConfig = ${JSON.stringify(currentConfig, null, 2)};`);
            const [appIdText, setAppIdText] = React.useState(currentAppId || DEFAULT_APP_CONTEXT_ID);
            const [parseError, setParseError] = React.useState(null);
            const handleSave = () => {
                try {
                    let cleanText = text.replace(/\/\/.*$/gm, '').replace(/\/\*[\s\S]*?\*\//g, '').replace(/^(const|var|let)\s+\w+\s*=\s*/, '').replace(/;+\s*$/, '').trim();
                    let config;
                    try { config = JSON.parse(cleanText); } catch (e) { config = new Function(`return ${cleanText}`)(); }
                    if (!config.apiKey) throw new Error("apiKey が空です。");
                    onSave(config, appIdText);
                } catch (e) { setParseError("設定エラー: " + e.message); }
            };
            return (
                <div className="fixed inset-0 bg-black/50 flex items-center justify-center z-[9999] p-4">
                    <div className="bg-white p-6 rounded-lg shadow-xl w-full max-w-2xl flex flex-col max-h-[90vh] overflow-y-auto">
                        <h3 className="text-lg font-bold mb-4 flex items-center gap-2 text-indigo-900 border-b pb-2"><Icon name="settings" /> システム設定</h3>
                        <div className="mb-6"><label className="block text-sm font-bold text-gray-700 mb-1">データID (App ID)</label><input className="w-full border p-2 rounded text-sm font-mono" value={appIdText} onChange={e => setAppIdText(e.target.value)} /></div>
                        <div className="mb-4"><label className="block text-sm font-bold text-gray-700 mb-1">Firebase接続設定</label><textarea className="w-full border p-4 font-mono text-xs h-32" value={text} onChange={e => setText(e.target.value)} /></div>
                        {parseError && <div className="text-red-600 text-xs mb-4 p-2 bg-red-50">{parseError}</div>}
                        <div className="flex justify-end gap-2"><button onClick={onCancel} className="px-4 py-2 bg-gray-200 rounded">キャンセル</button><button onClick={handleSave} className="px-4 py-2 bg-indigo-600 text-white rounded">保存</button></div>
                    </div>
                </div>
            );
        };

        // --- Member Manager ---
        const MemberManager = ({ db, worldId, appContextId, onClose, members = [], onAddMember }) => {
            const [inviteId, setInviteId] = React.useState('');
            const [loading, setLoading] = React.useState(false);

            const addMember = async () => {
                if (!inviteId.trim()) return;
                await onAddMember(inviteId.trim());
                setInviteId('');
            };

            const updateMemberName = async (member) => {
                const newName = prompt("新しい表示名を入力してください", member.username || "");
                if (newName === null) return;
                try {
                    const { doc, updateDoc } = window.firebaseModules;
                    await updateDoc(doc(db, 'artifacts', appContextId, 'public', 'data', 'worlds', worldId, 'members', member.id), {
                        username: newName
                    });
                } catch (e) { alert('更新エラー: ' + e.message); }
            };

            const removeMember = async (uid) => {
                if (!confirm('このメンバーを削除しますか？')) return;
                try {
                    const { doc, deleteDoc } = window.firebaseModules;
                    await deleteDoc(doc(db, 'artifacts', appContextId, 'public', 'data', 'worlds', worldId, 'members', uid));
                } catch (e) { alert('削除エラー: ' + e.message); }
            };

            const toggleApprovalParams = async (member) => {
                try {
                    const { doc, updateDoc } = window.firebaseModules;
                    await updateDoc(doc(db, 'artifacts', appContextId, 'public', 'data', 'worlds', worldId, 'members', member.id), {
                        canApprove: !member.canApprove
                    });
                } catch (e) { alert('更新エラー: ' + e.message); }
            };

            const assignRole = async (member, newRole) => {
                try {
                    const { doc, updateDoc } = window.firebaseModules;
                    await updateDoc(doc(db, 'artifacts', appContextId, 'public', 'data', 'worlds', worldId, 'members', member.id), {
                        role: newRole
                    });
                } catch (e) { alert('更新エラー: ' + e.message); }
            };

            const pendingMembers = members.filter(m => m.role === 'pending');
            const activeMembers = members.filter(m => m.role !== 'pending');

            return (
                <div className="fixed inset-0 bg-black/50 flex items-center justify-center z-[9999] p-4">
                    <div className="bg-white p-6 rounded-lg shadow-xl w-full max-w-md">
                        <h3 className="text-lg font-bold mb-4 text-indigo-900 border-b pb-2 flex justify-between items-center">
                            <span>メンバー管理</span>
                            <button onClick={onClose}><Icon name="x" size={20} /></button>
                        </h3>

                        {pendingMembers.length > 0 && (
                            <div className="mb-6 bg-indigo-50 p-3 rounded">
                                <div className="text-xs font-bold text-indigo-700 mb-2">承認待ちの申請 ({pendingMembers.length})</div>
                                <div className="space-y-2 max-h-40 overflow-y-auto custom-scrollbar">
                                    {pendingMembers.map(m => (
                                        <div key={m.id} className="bg-white p-2 rounded shadow-sm border">
                                            <div className="flex justify-between items-start mb-1">
                                                <span className="font-bold text-sm">{m.username || 'No Name'}</span>
                                                <div className="flex gap-1">
                                                    <button onClick={() => assignRole(m, 'editor')} className="bg-indigo-600 text-white text-xs px-2 py-1 rounded hover:bg-indigo-700">承認</button>
                                                    <button onClick={() => removeMember(m.id)} className="bg-gray-200 text-gray-600 text-xs px-2 py-1 rounded hover:bg-gray-300">拒否</button>
                                                </div>
                                            </div>
                                            <div className="text-xs text-gray-600">{m.message || '(メッセージなし)'}</div>
                                        </div>
                                    ))}
                                </div>
                            </div>
                        )}

                        <div className="flex gap-2 mb-4">
                            <input className="border p-2 rounded flex-1 text-sm" placeholder="ユーザーID (UID) を入力" value={inviteId} onChange={e => setInviteId(e.target.value)} />
                            <button onClick={addMember} disabled={loading} className="bg-indigo-600 text-white px-4 py-2 rounded text-sm font-bold">追加</button>
                        </div>
                        <div className="space-y-2 max-h-60 overflow-y-auto custom-scrollbar">
                            {activeMembers.map(m => (
                                <div key={m.id} className="flex justify-between items-center border-b pb-2">
                                    <div className="flex-1">
                                        <div className="flex items-center gap-2">
                                            <span className="text-sm font-bold text-gray-800">{m.username || 'No Name'}</span>
                                            <button onClick={() => updateMemberName(m)} className="text-gray-400 hover:text-indigo-600"><Icon name="edit-2" size={12} /></button>
                                            <span className="text-[10px] text-gray-400 font-mono">({m.id})</span>
                                        </div>
                                        <div className="flex items-center gap-2 mt-1">
                                            <span className={`text-[10px] px-2 py-0.5 rounded ${m.role === 'owner' ? 'bg-red-100 text-red-800' : 'bg-blue-100 text-blue-800'}`}>{m.role}</span>
                                            {m.role !== 'owner' && (
                                                <label className="flex items-center gap-1 text-[10px] cursor-pointer bg-gray-100 px-2 py-0.5 rounded hover:bg-gray-200">
                                                    <input type="checkbox" checked={!!m.canApprove} onChange={() => toggleApprovalParams(m)} />
                                                    承認権限
                                                </label>
                                            )}
                                        </div>
                                    </div>
                                    {m.role !== 'owner' && <button onClick={() => removeMember(m.id)} className="text-red-500 text-xs border px-2 py-1 rounded hover:bg-red-50 ml-2">削除</button>}
                                </div>
                            ))}
                        </div>
                    </div>
                </div>
            );
        };

        // --- Region Rule Editor (Map-based Interactive) ---
        const RegionRuleEditor = ({ rules = [], onSave, onClose, worldData }) => {
            const [items, setItems] = React.useState(rules);
            const [mode, setMode] = React.useState('view'); // view, drawing_rect, drawing_circle
            const [tempPoints, setTempPoints] = React.useState([]);
            const mapRef = React.useRef(null);
            const leafletMap = React.useRef(null);
            const layerGroupRef = React.useRef(null);

            // Init Map
            React.useEffect(() => {
                if (!mapRef.current || leafletMap.current) return;
                const map = L.map(mapRef.current, { crs: L.CRS.Simple, minZoom: -3, maxZoom: 4, zoomControl: true });
                leafletMap.current = map;
                layerGroupRef.current = L.layerGroup().addTo(map);

                // Load Background Image
                const layers = worldData?.mapLayers || (worldData?.mapImageUrl ? [{ id: 'default', url: worldData.mapImageUrl }] : []);
                if (layers.length > 0) {
                    const img = new Image();
                    img.src = layers[0].url;
                    img.onload = () => {
                        const bounds = [[-img.height / 2, -img.width / 2], [img.height / 2, img.width / 2]];
                        L.imageOverlay(layers[0].url, bounds).addTo(map);
                        map.fitBounds(bounds);
                    };
                } else {
                    const bounds = [[-500, -500], [500, 500]];
                    L.rectangle(bounds, { color: "#9ca3af", weight: 1, fill: false }).addTo(map);
                    map.fitBounds(bounds);
                }

                // Click Handler
                map.on('click', (e) => {
                    handleMapClick(e.latlng);
                });
            }, []);

            // Ref for accessing current mode in event handler (if needed) but state works if defined inside component (closure)
            // Render items on map
            React.useEffect(() => {
                if (!leafletMap.current || !layerGroupRef.current) return;
                layerGroupRef.current.clearLayers();

                items.forEach((item, idx) => {
                    const color = ['#6366f1', '#10b981', '#f59e0b', '#ef4444'][idx % 4];
                    let layer = null;
                    if (item.type === 'rect' && item.bounds) {
                        const b = [[item.bounds.latMin, item.bounds.lngMin], [item.bounds.latMax, item.bounds.lngMax]];
                        layer = L.rectangle(b, { color, weight: 2, fillOpacity: 0.2 });
                    } else if (item.type === 'circle' && item.center) {
                        layer = L.circle([item.center.lat, item.center.lng], { radius: (item.radiusKm || 1) * 1000, color, weight: 2, fillOpacity: 0.2 }); // Leaflet circle radius is meters roughly in CRS.Simple? No, it depends.
                        // In CRS.Simple, radius is map units. If "radiusKm" is treated as map units:
                        layer = L.circle([item.center.lat, item.center.lng], { radius: item.radiusKm, color, weight: 2, fillOpacity: 0.2 });
                    }

                    if (layer) {
                        layer.bindTooltip(`<b>${item.tag}</b>`, { permanent: true, direction: 'center', className: 'bg-transparent border-0 font-bold shadow-none' });
                        layer.addTo(layerGroupRef.current);
                    }
                });
            }, [items]);

            const handleMapClick = (latlng) => {
                setMode(prevMode => {
                    if (prevMode === 'drawing_rect') {
                        setTempPoints(prev => {
                            const newPoints = [...prev, latlng];
                            if (newPoints.length === 2) {
                                // Finish Rect
                                const [p1, p2] = newPoints;
                                const latMin = Math.min(p1.lat, p2.lat);
                                const latMax = Math.max(p1.lat, p2.lat);
                                const lngMin = Math.min(p1.lng, p2.lng);
                                const lngMax = Math.max(p1.lng, p2.lng);
                                const tag = prompt("タグ名を入力してください:");
                                if (tag) {
                                    setItems(current => [...current, { tag, type: 'rect', bounds: { latMin, latMax, lngMin, lngMax } }]);
                                }
                                setTempPoints([]);
                                return []; // Reset in next render by mode change
                            }
                            return newPoints;
                        });
                        if (tempPoints.length === 1) return 'view'; // Will be handled by effect or logic above? No, setState is async.
                        // Logic simplified:
                        // If we just added the 2nd point, we are done.
                        // But we need to check the updated state.
                        // Better to handle logic inside the setTempPoints callback or separate ref.
                        return prevMode; // Stay in mode until 2nd point logic executes
                    } else if (prevMode === 'drawing_circle') {
                        setTempPoints(prev => {
                            if (prev.length === 0) {
                                return [latlng]; // Set Center
                            } else {
                                // Set Radius
                                const center = prev[0];
                                const radius = Math.sqrt(Math.pow(latlng.lat - center.lat, 2) + Math.pow(latlng.lng - center.lng, 2));
                                const tag = prompt("タグ名を入力してください:");
                                if (tag) {
                                    setItems(current => [...current, { tag, type: 'circle', center: { lat: center.lat, lng: center.lng }, radiusKm: radius }]);
                                }
                                return [];
                            }
                        });
                    }
                    return prevMode;
                });
            };

            // Side effect to exit mode after shape completion
            React.useEffect(() => {
                if (mode === 'drawing_rect' && tempPoints.length === 2) setMode('view');
                if (mode === 'drawing_circle' && tempPoints.length === 0 && mode !== 'view') setMode('view'); // slightly buggy logic, fix below
            }, [tempPoints]);

            // Fix circle logic: clearing tempPoints implies done
            const handleModeChange = (m) => {
                setMode(m);
                setTempPoints([]);
            };

            const removeItem = (idx) => setItems(items.filter((_, i) => i !== idx));

            return (
                <div className="fixed inset-0 bg-black/50 flex items-center justify-center z-[9999] p-4">
                    <div className="bg-white w-full h-full max-w-6xl max-h-[90vh] rounded-lg shadow-2xl flex flex-col overflow-hidden">
                        <div className="p-4 border-b flex justify-between items-center bg-gray-50">
                            <div className="flex items-center gap-4">
                                <h3 className="text-lg font-bold flex items-center gap-2"><Icon name="map" /> 地域タグ設定</h3>
                                <div className="flex bg-white border rounded p-1 gap-1">
                                    <button onClick={() => handleModeChange('view')} className={`px-3 py-1 rounded text-sm ${mode === 'view' ? 'bg-indigo-100 text-indigo-700 font-bold' : 'hover:bg-gray-100'}`}><Icon name="mouse-pointer" size={14} /> 操作</button>
                                    <button onClick={() => handleModeChange('drawing_rect')} className={`px-3 py-1 rounded text-sm ${mode === 'drawing_rect' ? 'bg-indigo-600 text-white font-bold' : 'hover:bg-gray-100'}`}><Icon name="square" size={14} /> 矩形追加</button>
                                    <button onClick={() => handleModeChange('drawing_circle')} className={`px-3 py-1 rounded text-sm ${mode === 'drawing_circle' ? 'bg-indigo-600 text-white font-bold' : 'hover:bg-gray-100'}`}><Icon name="circle" size={14} /> 円追加</button>
                                </div>
                                <div className="text-sm text-gray-500">
                                    {mode === 'drawing_rect' && (tempPoints.length === 0 ? '始点をクリック' : '終点をクリック')}
                                    {mode === 'drawing_circle' && (tempPoints.length === 0 ? '中心をクリック' : '半径位置をクリック')}
                                </div>
                            </div>
                            <div className="flex gap-2">
                                <button onClick={onClose} className="px-4 py-2 border rounded hover:bg-gray-50">キャンセル</button>
                                <button onClick={() => onSave(items)} className="px-6 py-2 bg-indigo-600 text-white font-bold rounded hover:bg-indigo-700">保存</button>
                            </div>
                        </div>
                        <div className="flex-1 flex overflow-hidden">
                            <div className="w-64 border-r bg-gray-50 overflow-y-auto p-2 space-y-2">
                                <div className="text-xs font-bold text-gray-500 mb-2">登録済みルール ({items.length})</div>
                                {items.map((item, idx) => (
                                    <div key={idx} className="bg-white p-2 rounded border shadow-sm text-sm group">
                                        <div className="flex justify-between items-center font-bold text-gray-800">
                                            <span>{item.tag}</span>
                                            <button onClick={() => removeItem(idx)} className="text-gray-400 hover:text-red-500"><Icon name="trash-2" size={14} /></button>
                                        </div>
                                        <div className="text-xs text-gray-500 mt-1">
                                            {item.type === 'rect' ? '矩形エリア' : '円形エリア'}
                                        </div>
                                    </div>
                                ))}
                                {items.length === 0 && <div className="text-xs text-gray-400 text-center py-4">ルールはまだありません</div>}
                            </div>
                            <div className="flex-1 relative">
                                <div className="absolute inset-0 bg-slate-200" ref={mapRef}></div>
                            </div>
                        </div>
                    </div>
                </div>
            );
        };

        // --- Rich Editor (Quill.js) ---
        // CSV パーサ（簡易実装、引用符と改行に対応）
        const parseCSV = (text, delimiter) => {
            if (!text) return [];
            // デリミタが指定されていない場合、タブが含まれていればTSV、そうでなければカンマとみなす（自動判定）
            const activeDelimiter = delimiter || (text.includes('\t') ? '\t' : ',');

            const rows = [];
            let cur = '';
            let row = [];
            let inQuotes = false;
            for (let i = 0; i < text.length; i++) {
                const ch = text[i];
                if (ch === '"') {
                    if (inQuotes && text[i + 1] === '"') { cur += '"'; i++; }
                    else { inQuotes = !inQuotes; }
                } else if (ch === activeDelimiter && !inQuotes) {
                    row.push(cur); cur = '';
                } else if ((ch === '\n' || ch === '\r') && !inQuotes) {
                    if (ch === '\r' && text[i + 1] === '\n') { i++; }
                    row.push(cur); rows.push(row); row = []; cur = '';
                } else { cur += ch; }
            }
            if (cur !== '' || row.length > 0) { row.push(cur); rows.push(row); }
            return rows.map(r => r.map(c => c.trim()));
        };

        const RichTextEditor = React.forwardRef(({ value, onChange }, ref) => {
            const containerRef = React.useRef(null);
            const quillRef = React.useRef(null);

            React.useImperativeHandle(ref, () => ({
                insertLink: (article) => {
                    if (quillRef.current) {
                        const cursor = quillRef.current.getSelection(true);
                        // 独自記法 [[Title|ID]] を挿入
                        quillRef.current.insertText(cursor ? cursor.index : 0, `[[${article.title}|${article.id}]]`);
                    }
                },
                insertTable: (rows = 3, cols = 3) => {
                    if (quillRef.current) {
                        const table = quillRef.current.getModule('table');
                        if (table) {
                            table.insertTable(rows, cols);
                        }
                    }
                },
                insertCSV: (csvText) => {
                    if (!csvText || !quillRef.current) return;
                    const rows = parseCSV(csvText, ',');
                    if (!rows || rows.length === 0) return;

                    // CSVデータを標準的なHTMLテーブルに変換して挿入
                    let tableHtml = '<table style="width:100%; border-collapse:collapse; border:1px solid #ccc;"><tbody>';
                    rows.forEach((r) => {
                        tableHtml += '<tr>';
                        r.forEach((cell) => {
                            tableHtml += `<td style="border:1px solid #ccc; padding:8px;">${cell || '&nbsp;'}</td>`;
                        });
                        tableHtml += '</tr>';
                    });
                    tableHtml += '</tbody></table><p><br></p>';

                    const cursor = quillRef.current.getSelection(true);
                    quillRef.current.clipboard.dangerouslyPasteHTML(cursor ? cursor.index : 0, tableHtml);
                },
                insertRow: (where = 'below') => {
                    const table = quillRef.current.getModule('table');
                    if (table) {
                        if (where === 'below') table.insertRowBelow();
                        else table.insertRowAbove();
                    }
                },
                insertColumn: (where = 'right') => {
                    const table = quillRef.current.getModule('table');
                    if (table) {
                        if (where === 'right') table.insertColumnRight();
                        else table.insertColumnLeft();
                    }
                },
                deleteRow: () => {
                    const table = quillRef.current.getModule('table');
                    if (table) table.deleteRow();
                },
                deleteColumn: () => {
                    const table = quillRef.current.getModule('table');
                    if (table) table.deleteColumn();
                },
                mergeCells: () => {
                    const table = quillRef.current.getModule('table');
                    if (table) table.mergeCells();
                },
                unmergeCells: () => {
                    const table = quillRef.current.getModule('table');
                    if (table) table.unmergeCells();
                },
                formatCell: (attr, value) => {
                    const quill = quillRef.current;
                    const range = quill.getSelection();
                    if (!range) return;

                    // セル内のすべての行に対して書式を適用
                    // Quill 2.0 のテーブルモジュールでは、背景色は line 単位ではなく cell 単位の属性として扱う必要がある場合があるが
                    // ここではDOMを直接操作してスタイルを設定し、Quillの変更を即座に反映させる
                    const [line] = quill.getLine(range.index);
                    let cell = line;
                    while (cell && cell.statics.blotName !== 'table-cell') {
                        cell = cell.parent;
                    }

                    if (cell && cell.domNode) {
                        if (attr === 'background') {
                            cell.domNode.style.backgroundColor = value;
                        } else if (attr === 'align') {
                            cell.domNode.style.textAlign = value;
                        }
                        // 変更を親コンポーネントに通知
                        onChange(quill.root.innerHTML);
                    }
                },
                insertText: (text) => {
                    if (quillRef.current) {
                        const range = quillRef.current.getSelection(true);
                        quillRef.current.insertText(range ? range.index : 0, text);
                    }
                }
            }));

            React.useEffect(() => {
                if (containerRef.current && !quillRef.current) {
                    if (typeof Quill === 'undefined') {
                        console.error('Quill is not defined');
                        return;
                    }

                    // Quill 2.0 ではテーブルモジュールが標準搭載されている
                    const quill = new Quill(containerRef.current, {
                        theme: 'snow',
                        modules: {
                            table: true, // テーブルモジュールを有効化
                            toolbar: [
                                [{ 'header': [1, 2, 3, false] }],
                                ['bold', 'italic', 'underline', 'strike'],
                                [{ 'color': [] }, { 'background': [] }],
                                [{ 'list': 'ordered' }, { 'list': 'bullet' }],
                                [{ 'align': [] }],
                                ['link', 'image', 'blockquote', 'code-block'],
                                [{ 'table': [] }], // テーブル挿入・操作ボタンを追加
                                ['clean']
                            ]
                        }
                    });

                    quill.on('text-change', () => {
                        const html = quill.root.innerHTML;
                        onChange(html);
                    });

                    quillRef.current = quill;

                    // テーブル操作用のコンテキストメニュー的な補助（Quill 2.0のUIに任せるが、必要ならここで追加可能）
                }
            }, []);

            // 初期値設定
            React.useEffect(() => {
                if (quillRef.current && value !== quillRef.current.root.innerHTML) {
                    if (!quillRef.current.hasFocus()) {
                        // 既存のHTMLをセット
                        quillRef.current.root.innerHTML = value || '';
                    }
                }
            }, [value]);

            return (
                <div className="h-full flex flex-col bg-white rounded rich-editor-container">
                    <style dangerouslySetInnerHTML={{
                        __html: `
                        .rich-editor-container .ql-editor table {
                            border-collapse: collapse;
                            width: 100%;
                            margin: 10px 0;
                        }
                        .rich-editor-container .ql-editor td, 
                        .rich-editor-container .ql-editor th {
                            border: 1px solid #ccc;
                            padding: 8px;
                            min-width: 20px;
                        }
                        /* Quill 2.0 Table UI Customization */
                        .ql-table-controls {
                            padding: 5px;
                            background: #f8f9fa;
                            border: 1px solid #ddd;
                            display: flex;
                            gap: 5px;
                        }
                    `}} />
                    <div ref={containerRef} className="flex-1 overflow-visible min-h-[400px]"></div>
                </div>
            );
        });

        // --- Stats Editor ---
        const StatsEditor = ({ stats = [], onChange }) => {
            const updateStat = (idx, field, val) => { const newStats = [...stats]; newStats[idx][field] = val; onChange(newStats); };
            return (
                <div className="space-y-2">
                    {stats.map((stat, idx) => (
                        <div key={idx} className="flex gap-2 items-center">
                            <input className="border p-1 rounded text-sm w-1/3" value={stat.label} onChange={e => updateStat(idx, 'label', e.target.value)} />
                            <input className="border p-1 rounded text-sm w-1/3" value={stat.value} onChange={e => updateStat(idx, 'value', e.target.value)} />
                            <select className="border p-1 rounded text-sm" value={stat.color} onChange={e => updateStat(idx, 'color', e.target.value)}>
                                <option value="gray">灰</option><option value="red">赤</option><option value="blue">青</option><option value="green">緑</option><option value="yellow">金</option>
                            </select>
                            <button onClick={() => onChange(stats.filter((_, i) => i !== idx))}><Icon name="x" size={16} /></button>
                        </div>
                    ))}
                    <button onClick={() => onChange([...stats, { label: '', value: '', color: 'gray' }])} className="text-xs flex items-center gap-1"><Icon name="plus" size={12} /> 追加</button>
                </div>
            );
        };

        // --- Locations Editor ---
        const LocationsEditor = ({ locations = [], onChange }) => {
            const updateLoc = (idx, field, val) => { const newLocs = [...locations]; newLocs[idx][field] = val; onChange(newLocs); };
            return (
                <div className="space-y-2 bg-gray-50 p-2 rounded border">
                    <label className="text-xs font-bold text-gray-500 block">地点リスト (複数登録可)</label>
                    {locations.map((loc, idx) => (
                        <div key={idx} className="flex gap-2 items-center text-sm">
                            <input placeholder="緯度" type="number" step="0.0001" className="border p-1 rounded w-20" value={loc.lat} onChange={e => updateLoc(idx, 'lat', e.target.value)} />
                            <input placeholder="経度" type="number" step="0.0001" className="border p-1 rounded w-20" value={loc.lng} onChange={e => updateLoc(idx, 'lng', e.target.value)} />
                            <input placeholder="ラベル" className="border p-1 rounded flex-1" value={loc.label} onChange={e => updateLoc(idx, 'label', e.target.value)} />
                            <button onClick={() => onChange(locations.filter((_, i) => i !== idx))} className="text-red-500"><Icon name="x" size={14} /></button>
                        </div>
                    ))}
                    <button onClick={() => onChange([...locations, { lat: 0, lng: 0, label: '' }])} className="text-xs text-indigo-600 flex items-center gap-1"><Icon name="plus" size={12} /> 地点追加</button>
                </div>
            );
        };

        // --- Article Link Inserter ---
        const ArticleLinkInserter = ({ articles, onInsert }) => {
            const [query, setQuery] = React.useState('');
            const [searchMode, setSearchMode] = React.useState('title'); // 'title' or 'tag'

            const filtered = React.useMemo(() => {
                if (!query) return [];
                const lowerQuery = query.toLowerCase();

                if (searchMode === 'tag') {
                    // タグ検索: 記事のタグ配列に部分一致するタグが含まれているかチェック
                    return articles.filter(a =>
                        Array.isArray(a.tags) && a.tags.some(tag => tag.toLowerCase().includes(lowerQuery))
                    );
                } else {
                    // 記事名検索
                    return articles.filter(a =>
                        a.title.toLowerCase().includes(lowerQuery)
                    );
                }
            }, [articles, query, searchMode]);

            return (
                <div className="space-y-2 bg-white border p-2 rounded">
                    <div className="flex items-center justify-between">
                        <label className="text-xs font-bold text-gray-500">
                            {searchMode === 'title' ? '記事名検索' : 'タグ検索'}
                        </label>
                        <div className="flex gap-1">
                            <button
                                onClick={() => setSearchMode('title')}
                                className={`px-2 py-0.5 text-xs rounded ${searchMode === 'title' ? 'bg-indigo-600 text-white' : 'bg-gray-100 text-gray-600'}`}
                            >
                                記事名
                            </button>
                            <button
                                onClick={() => setSearchMode('tag')}
                                className={`px-2 py-0.5 text-xs rounded ${searchMode === 'tag' ? 'bg-indigo-600 text-white' : 'bg-gray-100 text-gray-600'}`}
                            >
                                タグ
                            </button>
                        </div>
                    </div>
                    <input
                        className="w-full border p-1 text-sm rounded"
                        placeholder={searchMode === 'title' ? '記事名を検索...' : 'タグを検索...'}
                        value={query}
                        onChange={e => setQuery(e.target.value)}
                    />
                    <div className="max-h-48 overflow-y-auto space-y-1 custom-scrollbar">
                        {filtered.map(a => (
                            <div key={a.id} className="w-full text-left text-xs px-2 py-1 hover:bg-indigo-50 rounded group">
                                <div className="flex justify-between items-center gap-2">
                                    <div className="flex-1 pr-2 min-w-0">
                                        <div className="overflow-x-auto whitespace-nowrap text-sm font-medium" style={{ maxWidth: '100%' }} title={a.title}>
                                            {a.title}
                                        </div>
                                        {searchMode === 'tag' && Array.isArray(a.tags) && a.tags.length > 0 && (
                                            <div className="flex flex-wrap gap-1 mt-1">
                                                {a.tags.filter(t => typeof t === 'string').map(tag => (
                                                    <span key={tag} className="text-[10px] bg-gray-100 text-gray-600 px-1 rounded">
                                                        #{tag}
                                                    </span>
                                                ))}
                                            </div>
                                        )}
                                    </div>
                                    <div className="flex gap-2 shrink-0">
                                        <button onClick={() => { copyText(a.id); }} className="text-gray-400 hover:text-indigo-600 text-xs">IDコピー</button>
                                        <button onClick={() => { onInsert(a); setQuery(''); }} className="text-indigo-600 font-bold text-xs">挿入</button>
                                    </div>
                                </div>
                            </div>
                        ))}
                        {query && filtered.length === 0 && <div className="text-xs text-gray-400">見つかりません</div>}
                    </div>
                </div>
            );
        };

        // --- Table Inserter ---
        const TableInserter = ({ onInsert, onAction, isWysiwyg, canCreateSheet }) => {
            const [rows, setRows] = React.useState(3);
            const [cols, setCols] = React.useState(3);
            const [pasteArea, setPasteArea] = React.useState('');
            const [showPaste, setShowPaste] = React.useState('normal'); // 'normal', 'copy', 'live', 'cloud', 'data'
            const [sheetUrl, setSheetUrl] = React.useState('');

            // Cloud Create Option State
            const [cloudMode, setCloudMode] = React.useState('new'); // 'new' | 'copy'
            const [templateUrl, setTemplateUrl] = React.useState('');

            const handlePasteInsert = () => {
                if (!pasteArea.trim()) return;
                onAction('insertFromText', pasteArea);
                setPasteArea('');
                setShowPaste(false);
            };

            return (
                <div className="space-y-3 bg-white border p-3 rounded shadow-sm">
                    <div className="flex items-center justify-between">
                        <label className="text-xs font-bold text-gray-500 flex items-center gap-1">
                            <Icon name="table" size={14} /> 表ブロック
                        </label>
                        <div className="flex gap-2">
                            <button onClick={() => setShowPaste('normal')} className={`text-[10px] ${showPaste === 'normal' ? 'font-bold text-indigo-700' : 'text-gray-400'}`}>通常</button>
                            {canCreateSheet && (
                                <button onClick={() => setShowPaste('cloud')} className={`text-[10px] ${showPaste === 'cloud' ? 'font-bold text-indigo-700' : 'text-gray-400'}`}>クラウド制作</button>
                            )}
                            <button onClick={() => setShowPaste('copy')} className={`text-[10px] ${showPaste === 'copy' ? 'font-bold text-indigo-700' : 'text-gray-400'}`}>コピペ</button>
                            <button onClick={() => setShowPaste('live')} className={`text-[10px] ${showPaste === 'live' ? 'font-bold text-indigo-700' : 'text-gray-400'}`}>ライブ同期</button>
                            <button onClick={() => setShowPaste('data')} className={`text-[10px] ${showPaste === 'data' ? 'font-bold text-indigo-700' : 'text-gray-400'}`}>自動集計</button>
                        </div>
                    </div>

                    {showPaste === 'cloud' && (
                        /* クラウド制作エリア */
                        <div className="space-y-2 pb-2 border-b border-gray-100">
                            <div className="flex gap-4 mb-2 px-1">
                                <label className="flex items-center gap-1 text-[10px] cursor-pointer hover:text-indigo-600">
                                    <input type="radio" name="cloudMode" checked={cloudMode === 'new'} onChange={() => setCloudMode('new')} className="accent-indigo-600" /> 新規作成
                                </label>
                                <label className="flex items-center gap-1 text-[10px] cursor-pointer hover:text-indigo-600">
                                    <input type="radio" name="cloudMode" checked={cloudMode === 'copy'} onChange={() => setCloudMode('copy')} className="accent-indigo-600" /> テンプレート複製
                                </label>
                            </div>

                            {cloudMode === 'copy' && (
                                <div className="space-y-1">
                                    <input
                                        className="w-full border p-1.5 text-[10px] rounded focus:border-indigo-500 outline-none"
                                        placeholder="テンプレート元シートのURLを貼り付け"
                                        value={templateUrl}
                                        onChange={e => setTemplateUrl(e.target.value)}
                                    />
                                </div>
                            )}

                            <div className="text-[10px] text-gray-500 ml-1 font-bold">
                                {cloudMode === 'new' ? '疑似アカウントで新規シートを作成' : '指定シートをコピーして作成'}
                            </div>


                            <button
                                onClick={async (e) => {
                                    const btn = e.currentTarget;
                                    const proxyUrl = window.worldData?.spreadsheetProxyUrl;
                                    if (!proxyUrl) {
                                        alert("管理パネルから「GAS連携URL」を設定してください。");
                                        return;
                                    }

                                    // 権限チェック
                                    if (!canCreateSheet) {
                                        alert("この操作を行う権限がありません。");
                                        return;
                                    }

                                    // JSONP方式ではFirebaseは不要だが、念のためチェック（警告のみ）
                                    if (!window.firebaseModules || !window.db) {
                                        console.warn("Firebase未接続ですが、JSONP方式のため続行します。");
                                    }

                                    let payload = {};
                                    let title = '';

                                    if (cloudMode === 'new') {
                                        title = prompt("新しいスプレッドシート名を入力してください", "Wiki Data Sheet");
                                        if (!title) return;
                                        payload = { action: 'create', title };
                                    } else {
                                        if (!templateUrl) { alert('テンプレートURLを入力してください'); return; }
                                        const match = templateUrl.match(/\/d\/([a-zA-Z0-9-_]+)/);
                                        if (!match) { alert('有効なGoogleスプレッドシートURLではありません'); return; }

                                        title = prompt("作成するスプレッドシート名を入力してください", "Wiki Data Sheet (Copy)");
                                        if (!title) return;

                                        payload = { action: 'copy', title, templateId: match[1] };
                                    }

                                    const originalText = btn.innerText;
                                    btn.innerText = "作成中(GAS連携)...";
                                    btn.disabled = true;

                                    // JSONPによるGAS連携 (鍵不要・CORS回避)
                                    const callbackName = 'gas_cb_' + Math.random().toString(36).substr(2, 9);

                                    // クリーンアップ関数（先に定義）
                                    const cleanup = () => {
                                        delete window[callbackName];
                                        if (timeoutId) clearTimeout(timeoutId);
                                        const s = document.getElementById(callbackName);
                                        if (s) s.remove();
                                        btn.innerText = originalText;
                                        btn.disabled = false;
                                    };

                                    // グローバルコールバック定義
                                    window[callbackName] = (res) => {
                                        cleanup();
                                        if (res.status === 'success' && res.url) {
                                            onAction('insertEmbed', `#googlesheet(${res.url})`);
                                            alert("シート作成完了！入力しました。");
                                            setSheetUrl('');
                                            setShowPaste('normal');
                                        } else {
                                            alert("GASエラー: " + (res.message || '不明なエラー'));
                                        }
                                    };

                                    // タイムアウト監視
                                    const timeoutId = setTimeout(() => {
                                        cleanup();
                                        alert("応答タイムアウト: GASからの応答がありませんでした。");
                                    }, 60000); // 60秒待機

                                    // スクリプトタグ生成 (GETリクエスト)
                                    const script = document.createElement('script');
                                    script.id = callbackName;

                                    // URL構築
                                    const params = new URLSearchParams();
                                    params.set('callback', callbackName);
                                    params.set('action', payload.action);
                                    params.set('title', payload.title);
                                    if (payload.templateId) params.set('templateId', payload.templateId);

                                    // proxyUrlが既にパラメータ持ってるかチェック
                                    const joinChar = proxyUrl.includes('?') ? '&' : '?';
                                    script.src = proxyUrl + joinChar + params.toString();

                                    // 実行
                                    document.body.appendChild(script);
                                }}
                                className="w-full bg-blue-600 text-white hover:bg-blue-700 py-2 rounded text-[11px] font-bold transition-all shadow-sm flex items-center justify-center gap-2"
                            >
                                <img src="https://www.gstatic.com/images/branding/product/1x/sheets_2020q4_48dp.png" className="w-4 h-4" />
                                {cloudMode === 'new' ? 'Googleシートを新規作成' : 'テンプレートから作成'}
                            </button>
                            <div className="text-[9px] text-gray-400 italic px-1">
                                ※GASスクリプト側で {cloudMode === 'new' ? 'create' : 'copy'} アクションに対応している必要があります。
                            </div>
                        </div>
                    )}

                    {showPaste === 'normal' && (
                        /* 新規作成エリア */
                        <div className="space-y-2 pb-2 border-b border-gray-100">
                            <div className="flex gap-2 items-center">
                                <div className="flex-1">
                                    <label className="text-[10px] text-gray-400 block mb-0.5 ml-1">行数</label>
                                    <input
                                        type="number" min="1" max="20"
                                        className="w-full border p-1 text-sm rounded focus:border-indigo-500 outline-none"
                                        value={rows}
                                        onChange={e => setRows(parseInt(e.target.value) || 1)}
                                    />
                                </div>
                                <div className="text-gray-300 mt-5">×</div>
                                <div className="flex-1">
                                    <label className="text-[10px] text-gray-400 block mb-0.5 ml-1">列数</label>
                                    <input
                                        type="number" min="1" max="20"
                                        className="w-full border p-1 text-sm rounded focus:border-indigo-500 outline-none"
                                        value={cols}
                                        onChange={e => setCols(parseInt(e.target.value) || 1)}
                                    />
                                </div>
                            </div>
                            <button
                                onClick={() => onInsert(rows, cols)}
                                className="w-full bg-indigo-600 text-white hover:bg-indigo-700 py-1.5 rounded text-[11px] font-bold transition-all shadow-sm active:scale-95"
                            >
                                新しい表を挿入
                            </button>
                        </div>
                    )}
                    {showPaste === 'copy' && (
                        /* コピペエリア */
                        <div className="space-y-2 pb-2 border-b border-gray-100">
                            <div className="text-[10px] text-gray-400 ml-1">スプレッドシート等の範囲をここに貼り付け</div>
                            <textarea
                                className="w-full h-20 border rounded p-1 text-[10px] focus:border-indigo-500 outline-none resize-none font-mono"
                                placeholder="Col1   Col2   Col3..."
                                value={pasteArea}
                                onChange={e => setPasteArea(e.target.value)}
                            ></textarea>
                            <button
                                onClick={handlePasteInsert}
                                className="w-full bg-emerald-600 text-white hover:bg-emerald-700 py-1.5 rounded text-[11px] font-bold transition-all shadow-sm active:scale-95"
                            >
                                表に変換して挿入
                            </button>
                        </div>
                    )}

                    {showPaste === 'live' && (
                        /* ライブラリ埋め込みエリア */
                        <div className="space-y-2 pb-2 border-b border-gray-100">
                            <div className="text-[10px] text-gray-400 ml-1">Googleスプレッドシートを同期表示</div>
                            <input
                                type="text"
                                className="w-full border rounded p-1.5 text-[10px] focus:border-indigo-500 outline-none"
                                placeholder="スプレッドシートのURLを貼り付け"
                                value={sheetUrl}
                                onChange={e => setSheetUrl(e.target.value)}
                            />
                            <button
                                onClick={() => {
                                    if (!sheetUrl) return;
                                    onAction('insertEmbed', `#googlesheet(${sheetUrl})`);
                                    setSheetUrl('');
                                }}
                                className="w-full bg-indigo-600 text-white hover:bg-indigo-700 py-1.5 rounded text-[11px] font-bold transition-all shadow-sm active:scale-95"
                            >
                                ライブ同期表を挿入
                            </button>
                            <div className="text-[9px] text-gray-400 p-1 bg-gray-50 rounded">
                                ※シートの「ファイル」 &gt; 「共有」 &gt; 「ウェブに公開」で公開設定にする必要があります。
                            </div>
                        </div>
                    )}

                    {showPaste === 'data' && (
                        /* 自動集計エリア */
                        <div className="space-y-2 pb-2 border-b border-gray-100">
                            <div className="text-[10px] text-gray-400 ml-1">他記事のデータを自動で表にする</div>
                            <div className="space-y-1">
                                <label className="text-[9px] text-gray-400 ml-1">絞り込むフォルダ名 (任意)</label>
                                <input
                                    type="text"
                                    className="w-full border rounded p-1 text-[10px]"
                                    placeholder="例: 人物"
                                    id="dt-folder-input"
                                />
                            </div>
                            <button
                                onClick={() => {
                                    const folder = document.getElementById('dt-folder-input').value;
                                    const syntax = folder ? `#datatable(folder=${folder})` : `#datatable()`;
                                    onAction('insertEmbed', syntax);
                                }}
                                className="w-full bg-cyan-600 text-white hover:bg-cyan-700 py-1.5 rounded text-[11px] font-bold transition-all shadow-sm active:scale-95"
                            >
                                データベース表を挿入
                            </button>
                            <div className="text-[9px] text-gray-400 px-1 leading-tight">
                                ※挿入した表は閲覧画面で自動更新され、エディタ権限があればその場で一括編集できます。
                            </div>
                        </div>
                    )}

                    {/* テーブル操作エリア (WYSIWYGモード時のみ表示またはHTMLモードでのテンプレート的な案内) */}
                    <div className="space-y-1">
                        <div className="text-[10px] font-bold text-gray-400 mb-1 ml-1 uppercase tracking-wider">現在の表を操作</div>
                        <div className="grid grid-cols-2 gap-1">
                            <button onClick={() => onAction('insertRowBelow')} className="px-2 py-1.5 bg-gray-50 hover:bg-gray-100 border rounded text-[10px] flex items-center gap-1 justify-center"><Icon name="chevron-down" size={12} /> 行追加</button>
                            <button onClick={() => onAction('insertColumnRight')} className="px-2 py-1.5 bg-gray-50 hover:bg-gray-100 border rounded text-[10px] flex items-center gap-1 justify-center"><Icon name="chevron-right" size={12} /> 列追加</button>
                            <button onClick={() => onAction('deleteRow')} className="px-2 py-1.5 bg-red-50 hover:bg-red-100 border border-red-100 text-red-600 rounded text-[10px] flex items-center gap-1 justify-center"><Icon name="minus" size={12} /> 行削除</button>
                            <button onClick={() => onAction('deleteColumn')} className="px-2 py-1.5 bg-red-50 hover:bg-red-100 border border-red-100 text-red-600 rounded text-[10px] flex items-center gap-1 justify-center"><Icon name="minus" size={12} /> 列削除</button>
                        </div>
                        {isWysiwyg && (
                            <div className="space-y-1 mt-2 pt-2 border-t border-gray-100">
                                <div className="text-[10px] font-bold text-gray-400 mb-1 ml-1 uppercase tracking-wider">セルの装飾</div>
                                <div className="flex gap-1 flex-wrap">
                                    {['#ffffff', '#fef2f2', '#f0f9ff', '#f0fdf4', '#fefce8', '#f5f3ff'].map(c => (
                                        <button key={c} onClick={() => onAction('formatCell', { attr: 'background', value: c })}
                                            className="w-5 h-5 rounded border border-gray-200" style={{ backgroundColor: c }} title={c} />
                                    ))}
                                </div>
                                <div className="grid grid-cols-3 gap-1 mt-1">
                                    <button onClick={() => onAction('formatCell', { attr: 'align', value: 'left' })} className="px-1 py-1 bg-gray-50 border rounded text-[10px]"><Icon name="align-left" size={12} /></button>
                                    <button onClick={() => onAction('formatCell', { attr: 'align', value: 'center' })} className="px-1 py-1 bg-gray-50 border rounded text-[10px]"><Icon name="align-center" size={12} /></button>
                                    <button onClick={() => onAction('formatCell', { attr: 'align', value: 'right' })} className="px-1 py-1 bg-gray-50 border rounded text-[10px]"><Icon name="align-right" size={12} /></button>
                                </div>
                                <div className="grid grid-cols-2 gap-1 mt-1">
                                    <button onClick={() => onAction('mergeCells')} className="px-2 py-1 bg-indigo-50 hover:bg-indigo-100 text-indigo-700 border border-indigo-100 rounded text-[10px]">セル結合</button>
                                    <button onClick={() => onAction('unmergeCells')} className="px-2 py-1 bg-indigo-50 hover:bg-indigo-100 text-indigo-700 border border-indigo-100 rounded text-[10px]">結合解除</button>
                                </div>
                            </div>
                        )}
                    </div>
                </div>
            );
        };

        // --- Image Uploader ---
        const ImageUploader = ({ onUploadComplete, label = "画像アップロード", storage, appContextId }) => {
            const [uploading, setUploading] = React.useState(false);
            const handleFileChange = async (e) => {
                const file = e.target.files[0];
                if (!file) return;
                if (!storage) { alert("Firebase Storage未設定"); return; }
                setUploading(true);
                const { ref, uploadBytes, getDownloadURL } = window.firebaseModules;
                try {
                    const path = `artifacts/${appContextId || 'default'}/uploads/${Date.now()}_${file.name}`;
                    const storageRef = ref(storage, path);
                    await uploadBytes(storageRef, file);
                    const url = await getDownloadURL(storageRef);
                    onUploadComplete(url);
                } catch (err) { alert("アップロード失敗: " + err.message); } finally { setUploading(false); }
            };
            return (
                <label className={`cursor-pointer inline-flex items-center gap-2 px-3 py-1.5 bg-gray-100 hover:bg-gray-200 rounded text-xs ${uploading ? 'opacity-50' : ''}`}>
                    {uploading ? "..." : <Icon name="image" size={14} />} {label}
                    <input type="file" className="hidden" onChange={handleFileChange} disabled={uploading} />
                </label>
            );
        };

        // --- Attachment Uploader ---
        const AttachmentUploader = ({ onAddAttachment, storage, appContextId }) => {
            const [uploading, setUploading] = React.useState(false);
            const handleFile = async (file) => {
                if (!file) return;
                setUploading(true);
                // If Firebase storage available, upload and use downloadable URL
                if (storage && window.firebaseModules && window.firebaseModules.ref) {
                    try {
                        const { ref, uploadBytes, getDownloadURL } = window.firebaseModules;
                        const path = `artifacts/${appContextId || 'default'}/attachments/${Date.now()}_${file.name}`;
                        const storageRef = ref(storage, path);
                        await uploadBytes(storageRef, file);
                        const url = await getDownloadURL(storageRef);
                        onAddAttachment({ name: file.name, url });
                    } catch (err) {
                        console.error(err);
                        alert('アップロード失敗: ' + err.message);
                    } finally { setUploading(false); }
                } else {
                    // Fallback: embed as data URL (base64)
                    const reader = new FileReader();
                    reader.onload = () => {
                        const url = reader.result;
                        onAddAttachment({ name: file.name, url });
                        setUploading(false);
                    };
                    reader.onerror = () => { alert('ファイル読み込み失敗'); setUploading(false); };
                    reader.readAsDataURL(file);
                }
            };
            return (
                <div className="space-y-2">
                    <label className={`cursor-pointer inline-flex items-center gap-2 px-3 py-1.5 bg-gray-100 hover:bg-gray-200 rounded text-xs ${uploading ? 'opacity-50' : ''}`}>
                        <svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4" /><polyline points="17 8 12 3 7 8" /><line x1="12" y1="3" x2="12" y2="15" /></svg>
                        添付ファイル
                        <input type="file" className="hidden" onChange={e => handleFile(e.target.files[0])} />
                    </label>
                </div>
            );
        };

        // --- Firebase Hooks ---
        const useFirebase = () => {
            const [db, setDb] = React.useState(null);
            const [auth, setAuth] = React.useState(null);
            const [storage, setStorage] = React.useState(null);
            const [user, setUser] = React.useState(null);
            const [loading, setLoading] = React.useState(true);
            const [error, setError] = React.useState(null);
            const [activeConfig, setActiveConfig] = React.useState(null);
            const [appContextId, setAppContextId] = React.useState(DEFAULT_APP_CONTEXT_ID);

            React.useEffect(() => {
                let retry = 0;
                const timer = setInterval(() => {
                    if (window.firebaseModules) { clearInterval(timer); init(window.firebaseModules); }
                    else if (retry++ > 50) { clearInterval(timer); setError("SDK Load Timeout"); setLoading(false); }
                }, 100);
                const init = (modules) => {
                    try {
                        let config = DEFAULT_CONFIG;
                        let appId = DEFAULT_APP_CONTEXT_ID;
                        try { const s = localStorage.getItem('worldweaver_firebase_config'); if (s) config = JSON.parse(s); } catch (e) { }
                        setActiveConfig(config);
                        setAppContextId(appId);
                        const { initializeApp, getAuth, getFirestore, getStorage, onAuthStateChanged, getApps, setPersistence, browserLocalPersistence } = modules;
                        let app = getApps().length > 0 ? getApps()[0] : initializeApp(config);
                        const authInstance = getAuth(app);
                        setAuth(authInstance);
                        setDb(getFirestore(app));
                        try { setStorage(getStorage(app)); } catch (e) { }
                        // ログイン情報を永続化（ブラウザを閉じても保持）
                        setPersistence(authInstance, browserLocalPersistence).catch(e => console.warn('Persistence setup failed:', e));
                        onAuthStateChanged(authInstance, u => { setUser(u); setLoading(false); });
                    } catch (e) { setError(e.message); setLoading(false); }
                };
                return () => clearInterval(timer);
            }, []);
            return { db, auth, storage, user, loading, error, activeConfig, appContextId };
        };

        // --- Views ---
        const WorldList = ({ db, appContextId, onSelect }) => {
            const [worlds, setWorlds] = React.useState([]);
            React.useEffect(() => {
                if (!db || !appContextId) return;
                const { collection, query, onSnapshot } = window.firebaseModules;
                const q = query(collection(db, 'artifacts', appContextId, 'public', 'data', 'worlds'));
                return onSnapshot(q, s => setWorlds(s.docs.map(d => ({ id: d.id, ...d.data() }))));
            }, [db, appContextId]);
            return (<div className="space-y-2 max-h-64 overflow-y-auto custom-scrollbar">{worlds.map(w => (<div key={w.id} onClick={() => onSelect(w.id)} className="p-3 border rounded hover:bg-indigo-50 cursor-pointer flex justify-between items-center transition group"><div><div className="font-bold text-indigo-900 group-hover:text-indigo-700">{w.name}</div><div className="text-xs text-gray-500 truncate w-64">{w.description}</div></div><Icon name="chevron-right" size={16} className="text-gray-300 group-hover:text-indigo-500" /></div>))}{worlds.length === 0 && <div className="text-gray-400 text-sm text-center py-4">世界はまだありません</div>}</div>);
        };

        const FolderTreeItem = ({ name, node, depth = 0, onSelect, selectedFolder }) => {
            const [isOpen, setIsOpen] = React.useState(true);
            const hasChildren = Object.keys(node.children).length > 0;
            const isSelected = selectedFolder === node.fullPath;
            return (
                <div className="select-none">
                    <div className={`flex items-center gap-2 py-1.5 px-2 rounded cursor-pointer transition ${isSelected ? 'bg-indigo-600 text-white font-bold' : 'hover:bg-slate-700 text-slate-300'}`} style={{ paddingLeft: `${depth * 16 + 8}px` }} onClick={() => { if (node.articles.length > 0) onSelect(node); else setIsOpen(!isOpen); }}>
                        {hasChildren ? (<span onClick={(e) => { e.stopPropagation(); setIsOpen(!isOpen); }} className="p-0.5 hover:bg-slate-600 rounded text-slate-400"><Icon name={isOpen ? "chevron-down" : "chevron-right"} size={14} /></span>) : (<span className="w-4"></span>)}
                        <Icon name={node.icon || (hasChildren ? (isOpen ? "folder-open" : "folder") : "folder")} size={14} className={hasChildren || node.icon ? "text-indigo-400" : "text-slate-500"} />
                        <span className="truncate text-sm flex-1">{name}</span>
                        {node.articles.length > 0 && <span className="text-[10px] bg-slate-700 px-1.5 rounded-full text-slate-300">{node.articles.length}</span>}
                    </div>
                    {isOpen && hasChildren && <div>{Object.entries(node.children).sort((a, b) => a[0].localeCompare(b[0])).map(([childName, childNode]) => (<FolderTreeItem key={childName} name={childName} node={childNode} depth={depth + 1} onSelect={onSelect} selectedFolder={selectedFolder} />))}</div>}
                </div>
            );
        };

        const FolderIntegratedList = ({ articles, onSelectArticle, onTagClick, onOpenNoYear, onSearchChange, onlyApproved = false, onlyUnapproved = false, filterFn = null }) => {
            const [selectedFolderNode, setSelectedFolderNode] = React.useState(null);
            const [query, setQuery] = React.useState('');
            const [showSidebar, setShowSidebar] = React.useState(false);
            const [layoutStyle, setLayoutStyle] = React.useState('list'); // 'list' | 'grid'

            const handleContentClick = (e) => {
                const link = e.target.closest && e.target.closest('.wiki-link');
                if (!link) return;
                e.preventDefault(); e.stopPropagation();
                const id = link.getAttribute('data-article-id');
                const wikiTitle = link.getAttribute('data-wiki-title');
                if (id) {
                    const target = articles.find(a => a.id === id);
                    if (target) {
                        const y = getArticleYear(target);
                        const hasYear = y && y !== 0 && !target.noYear;
                        if (typeof onSearchChange === 'function') {
                            try { onSearchChange({ excludeNoYear: hasYear }); } catch (e) { console.warn(e); }
                        }
                        if (onSelectArticle) onSelectArticle(target);
                    } else alert('リンク先の記事が見つかりません');
                } else if (wikiTitle) {
                    if (wikiTitle === '年代なし' && onOpenNoYear) {
                        onOpenNoYear();
                        return;
                    }
                    const target = articles.find(a => (a.title || '').trim() === wikiTitle.trim());
                    if (target) {
                        const y = getArticleYear(target);
                        const hasYear = y && y !== 0 && !target.noYear;
                        if (typeof onSearchChange === 'function') {
                            try { onSearchChange({ excludeNoYear: hasYear }); } catch (e) { console.warn(e); }
                        }
                        if (onSelectArticle) onSelectArticle(target);
                    } else alert('リンク先の記事が見つかりません');
                }
            };

            const folderTree = React.useMemo(() => {
                const root = { name: 'root', fullPath: '', children: {}, articles: [] };
                // フィルタ適用後の記事リストでツリーを構築
                let targetArticles = articles;
                if (filterFn) {
                    targetArticles = articles.filter(filterFn);
                }

                const allArticlesNode = { name: 'すべての記事', fullPath: 'ALL', children: {}, articles: targetArticles, icon: 'layers' };
                const uncategorizedNode = { name: '未分類', fullPath: '未分類', children: {}, articles: [], icon: 'inbox' };
                const rootDocsNode = { name: '(ルート)', fullPath: '(root)', children: {}, articles: [], icon: 'file' };

                targetArticles.forEach(article => {
                    const hasFolder = !!article.folder;
                    const hasTags = Array.isArray(article.tags) && article.tags.length > 0;
                    const hasPendingTag = hasTags && article.tags.includes('分類待ち');

                    if (!hasFolder) {
                        // フォルダなしの場合の振り分けロジック
                        // タグなし、または「分類待ち」タグがある場合は「未分類」へ
                        if (!hasTags || hasPendingTag) {
                            uncategorizedNode.articles.push(article);
                        } else {
                            // タグはあるがフォルダ指定がないものはルート直下へ（便宜上 (ルート) フォルダに入れる）
                            rootDocsNode.articles.push(article);
                        }
                    } else {
                        // フォルダあり
                        if (article.folder === '未分類') {
                            uncategorizedNode.articles.push(article);
                        } else {
                            const parts = article.folder.split('/').filter(Boolean);
                            let current = root;
                            let currentPath = '';
                            parts.forEach((part) => {
                                currentPath = currentPath ? `${currentPath}/${part}` : part;
                                if (!current.children[part]) current.children[part] = { name: part, fullPath: currentPath, children: {}, articles: [] };
                                current = current.children[part];
                            });
                            current.articles.push(article);
                        }
                    }
                });

                if (uncategorizedNode.articles.length > 0) root.children['未分類'] = uncategorizedNode;
                if (rootDocsNode.articles.length > 0) root.children['(ルート)'] = rootDocsNode;

                return { root, allNode: allArticlesNode };
            }, [articles, filterFn]);

            React.useEffect(() => { if (!selectedFolderNode && articles.length > 0) setSelectedFolderNode(folderTree.allNode); }, [articles, selectedFolderNode, folderTree]);

            const displayArticles = React.useMemo(() => {
                let target = selectedFolderNode ? selectedFolderNode.articles : [];
                if (onlyApproved) target = target.filter(a => a.isApproved);
                if (onlyUnapproved) target = target.filter(a => !a.isApproved);
                if (query) { const lower = query.toLowerCase(); target = target.filter(a => [a.title, a.folder, stripHtml(a.contentHtml)].join(' ').toLowerCase().includes(lower)); }
                return sortByChronology(target);
            }, [selectedFolderNode, query, onlyApproved, onlyUnapproved]);

            return (
                <div className="flex h-full bg-slate-900 relative">
                    <div className={`fixed inset-y-0 left-0 z-30 w-64 bg-slate-800 transition-transform transform ${showSidebar ? 'translate-x-0' : '-translate-x-full'} md:translate-x-0 md:static md:flex-shrink-0 border-r border-slate-700 flex flex-col h-full`}>
                        <div className="md:hidden absolute top-2 right-2">
                            <button onClick={() => setShowSidebar(false)} className="text-slate-400 hover:text-white"><Icon name="x" size={20} /></button>
                        </div>
                        <div className="p-3 border-b border-slate-700 bg-slate-800/50 flex flex-col gap-2">
                            <input className="w-full border border-slate-600 bg-slate-700 text-white placeholder-slate-400 rounded px-2 py-1 text-sm focus:border-indigo-500 focus:outline-none" placeholder="記事を検索..." value={query} onChange={e => setQuery(e.target.value)} />
                            <div className="flex justify-between items-center text-xs text-slate-400">
                                <span>表示形式:</span>
                                <div className="flex bg-slate-700 rounded p-0.5">
                                    <button onClick={() => setLayoutStyle('list')} className={`p-1 rounded ${layoutStyle === 'list' ? 'bg-slate-500 text-white' : 'hover:text-white'}`} title="リスト"><Icon name="list" size={14} /></button>
                                    <button onClick={() => setLayoutStyle('grid')} className={`p-1 rounded ${layoutStyle === 'grid' ? 'bg-slate-500 text-white' : 'hover:text-white'}`} title="グリッド"><Icon name="grid" size={14} /></button>
                                </div>
                            </div>
                        </div>
                        <div className="flex-1 overflow-y-auto p-2 custom-scrollbar">
                            {!query && <>
                                <FolderTreeItem name="すべての記事" node={folderTree.allNode} onSelect={(n) => { setSelectedFolderNode(n); if (window.innerWidth < 768) setShowSidebar(false); }} selectedFolder={selectedFolderNode?.fullPath} />
                                <hr className="my-2 border-slate-700" />
                                {Object.entries(folderTree.root.children).sort((a, b) => {
                                    // 未分類と(ルート)は最後にするなどのソートロジックが必要ならここ
                                    if (a[0] === '未分類') return 1;
                                    if (b[0] === '未分類') return -1;
                                    return a[0].localeCompare(b[0]);
                                }).map(([name, node]) => (<FolderTreeItem key={name} name={name} node={node} onSelect={(n) => { setSelectedFolderNode(n); if (window.innerWidth < 768) setShowSidebar(false); }} selectedFolder={selectedFolderNode?.fullPath} />))}
                            </>}
                        </div>
                    </div>
                    {showSidebar && <div className="fixed inset-0 bg-black/50 z-20 md:hidden" onClick={() => setShowSidebar(false)}></div>}
                    <button className="md:hidden fixed bottom-6 right-6 z-50 p-3 bg-indigo-600 rounded-full text-white shadow-lg flex items-center justify-center animate-bounce" onClick={() => setShowSidebar(!showSidebar)}><Icon name="menu" size={24} /></button>
                    <div className="flex-1 overflow-y-auto p-4 bg-slate-900 custom-scrollbar w-full">
                        <div className={layoutStyle === 'grid' ? "grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4 gap-4" : "space-y-4"}>
                            {displayArticles.map(article => (
                                <div key={article.id} onClick={() => onSelectArticle && onSelectArticle(article)} className={`bg-slate-800/50 border rounded-xl cursor-pointer hover:border-indigo-500 hover:bg-slate-800 transition group flex flex-col ${getImportanceStyle(article.importance).card} ${layoutStyle === 'grid' ? 'h-full' : 'p-6'}`}>
                                    {layoutStyle === 'grid' ? (
                                        <>
                                            <div className="p-4 flex-1">
                                                <div className="flex items-center justify-between text-[10px] text-slate-400 mb-2">
                                                    <span className={`px-1.5 py-0.5 rounded ${ARTICLE_TYPES[article.type]?.color || 'bg-gray-100 text-gray-800'}`}>{ARTICLE_TYPES[article.type]?.label || 'その他'}</span>
                                                    <div className="flex items-center gap-2">
                                                        <span className="text-[10px] opacity-70">{getImportanceStyle(article.importance).badge}</span>
                                                        <span className="font-mono bg-slate-700 text-slate-300 px-1 rounded">{article.dateStr || article.year}</span>
                                                    </div>
                                                </div>
                                                <h3 className="font-bold text-white group-hover:text-indigo-400 mb-2 flex items-center gap-1 leading-snug">
                                                    {article.isApproved && <Icon name="check-circle" size={14} className="text-emerald-400 shrink-0" />}
                                                    <span className="truncate-2-lines" dangerouslySetInnerHTML={{ __html: applyRuby(escapeHtml(article.title)) }}></span>
                                                </h3>
                                                <div className="text-xs text-slate-400 line-clamp-3 mb-2" dangerouslySetInnerHTML={{ __html: transformContent(article.contentHtml || '') }}></div>
                                            </div>
                                            <div className="px-4 pb-4 pt-0 mt-auto">
                                                <div className="flex flex-wrap gap-1">{Array.isArray(article.tags) && article.tags.slice(0, 3).map(tag => <span key={tag} className="text-[10px] bg-slate-700 text-slate-300 px-1.5 py-0.5 rounded">#{tag}</span>)}</div>
                                            </div>
                                        </>
                                    ) : (
                                        <>
                                            <div className="flex items-center justify-between text-xs text-slate-400 mb-3"><span className={`px-2 py-0.5 rounded ${ARTICLE_TYPES[article.type]?.color || 'bg-gray-100 text-gray-800'}`}>{ARTICLE_TYPES[article.type]?.label || 'その他'}</span><span className="font-mono bg-slate-700 text-slate-300 px-1 rounded">{article.dateStr || article.year}</span></div>
                                            <h3 className="text-xl font-bold text-white group-hover:text-indigo-400 mb-3 flex items-center gap-2">
                                                {article.isApproved && <Icon name="check-circle" size={16} className="text-emerald-400" />}
                                                <span dangerouslySetInnerHTML={{ __html: applyRuby(escapeHtml(article.title)) }}></span>
                                            </h3>
                                            <div className="text-sm text-slate-300 mb-4 leading-relaxed line-clamp-3" onClick={handleContentClick} dangerouslySetInnerHTML={{ __html: transformContent(article.contentHtml || '') }}></div>
                                            <div className="flex flex-wrap gap-1 pt-3 border-t border-slate-700">{Array.isArray(article.tags) && article.tags.map(tag => <span key={tag} className="text-xs bg-slate-700 text-slate-300 px-2 py-1 rounded">#{tag}</span>)}</div>
                                        </>
                                    )}
                                </div>
                            ))}
                        </div>
                    </div>
                </div>
            );
        };

        // MapLayerManager: 地図レイヤー管理
        const MapLayerManager = ({ layers = [], onUpdate, storage, appContextId }) => {
            const [name, setName] = React.useState('');
            const handleAdd = (url) => {
                const newLayer = { id: Math.random().toString(36).substr(2, 9), name: name || '新規レイヤー', url };
                onUpdate([...layers, newLayer]);
                setName('');
            };
            const handleRemove = (id) => {
                if (confirm('このレイヤーを削除しますか？')) {
                    onUpdate(layers.filter(l => l.id !== id));
                }
            };
            return (
                <div className="space-y-4">
                    {layers.map((l, i) => (
                        <div key={l.id} className="flex justify-between items-center border p-2 rounded bg-white">
                            <span className="font-bold text-sm">{l.name}</span>
                            <div className="flex items-center gap-2">
                                <a href={l.url} target="_blank" className="text-blue-500 text-xs underline">確認</a>
                                <button onClick={() => handleRemove(l.id)} className="text-red-500 text-xs hover:underline">削除</button>
                            </div>
                        </div>
                    ))}
                    <div className="border border-dashed p-3 rounded bg-gray-50">
                        <div className="text-xs font-bold mb-2 text-gray-500">新規レイヤー追加</div>
                        <input className="w-full border p-1.5 rounded mb-2 text-sm" placeholder="レイヤー名 (例: 1000年, 地下)" value={name} onChange={e => setName(e.target.value)} />
                        <ImageUploader storage={storage} appContextId={appContextId} onUploadComplete={handleAdd} label="画像を追加" />
                    </div>
                </div>
            );
        };

        // MapView: 年代バー付き・複数地点対応・レイヤー切り替え対応
        const MapView = ({ articles = [], worldData, onSelectArticle, onLocationSelect, isEditing = false, storage, highlightArticleId, appContextId, showControls = true, myRole = 'guest', externalQuery, onExternalQueryChange, restrictToHighlightOnEdit = true, minImportance = 0 }) => {
            const mapRef = React.useRef(null);
            const leafletMap = React.useRef(null);
            const markersRef = React.useRef([]);
            const [mapQuery, setMapQuery] = React.useState('');
            const [yearRange, setYearRange] = React.useState({ years: [], min: -1000, max: 3000, index: 0, currentCenter: 1000, range: 2000, manualRange: false });

            // Layer Management
            const [activeLayerId, setActiveLayerId] = React.useState(null);
            const layers = React.useMemo(() => {
                if (Array.isArray(worldData?.mapLayers) && worldData.mapLayers.length > 0) return worldData.mapLayers;
                // fallback legacy
                if (worldData?.mapImageUrl) return [{ id: 'default', name: '標準マップ', url: worldData.mapImageUrl }];
                return [];
            }, [worldData]);

            const activeLayer = React.useMemo(() => {
                if (activeLayerId) {
                    const found = layers.find(l => l.id === activeLayerId);
                    if (found) return found;
                }
                return layers.length > 0 ? layers[0] : null;
            }, [layers, activeLayerId]);

            // Sync active layer ID if needed (initially)
            React.useEffect(() => {
                if (!activeLayerId && layers.length > 0) setActiveLayerId(layers[0].id);
            }, [layers]);


            // 記事全体の年代範囲計算
            React.useEffect(() => {
                if (articles.length > 0) {
                    // build sorted unique integer years from articles
                    const yrs = Array.from(new Set(articles.map(getArticleYear).map(y => Math.floor(y)).filter(y => !isNaN(y)))).sort((a, b) => a - b);
                    if (yrs.length > 0) {
                        const idx = Math.floor(yrs.length / 2);
                        const computeRangeForIndex = (i) => {
                            if (yrs.length === 1) return 50;
                            if (i === 0) return Math.max(50, Math.floor((yrs[1] - yrs[0]) / 2));
                            if (i === yrs.length - 1) return Math.max(50, Math.floor((yrs[i] - yrs[i - 1]) / 2));
                            return Math.max(30, Math.floor(Math.min((yrs[i] - yrs[i - 1]) / 2, (yrs[i + 1] - yrs[i]) / 2)));
                        };
                        const initialRange = computeRangeForIndex(idx);
                        setYearRange({ years: yrs, min: yrs[0], max: yrs[yrs.length - 1], index: idx, currentCenter: yrs[idx], range: initialRange, manualRange: false });
                    }
                }
            }, [articles]);

            const filteredArticles = React.useMemo(() => {
                // Determine effective query (external overrides internal)
                const q = (externalQuery !== undefined ? externalQuery : mapQuery || '').trim().toLowerCase();

                // base set depending on editing mode and restriction flag
                let base = articles;
                if (isEditing && restrictToHighlightOnEdit) {
                    // only show the highlighted/draft article while editing
                    if (highlightArticleId) base = articles.filter(a => a.id === highlightArticleId);
                    else base = articles.filter(a => a.id === '__draft__');
                } else if (!(isEditing || !showControls)) {
                    base = articles.filter(a => {
                        const y = getArticleYear(a);
                        return Math.abs(y - yearRange.currentCenter) <= yearRange.range;
                    });
                }

                if (!q && !minImportance) return base;
                const matches = (a) => {
                    if (minImportance > 0 && (a.importance || 3) < minImportance) return false;
                    const hay = [a.title || '', stripHtml(a.contentHtml || ''), (a.tags || []).join(' '), a.representedTag || ''].join(' ').toLowerCase();
                    return hay.includes(q);
                };
                return base.filter(matches);
            }, [articles, yearRange, isEditing, showControls, mapQuery, externalQuery, highlightArticleId, restrictToHighlightOnEdit, minImportance]);

            React.useEffect(() => {
                if (!mapRef.current || leafletMap.current) return;
                const map = L.map(mapRef.current, { crs: L.CRS.Simple, minZoom: -3, maxZoom: 4, zoomControl: false });
                leafletMap.current = map;
                map.on('click', (e) => isEditing && onLocationSelect && onLocationSelect({ lat: e.latlng.lat, lng: e.latlng.lng }));
            }, []); // Initialize map once

            // Update Image Layer
            React.useEffect(() => {
                const map = leafletMap.current;
                if (!map) return;

                // Remove existing image layers
                map.eachLayer(layer => {
                    if (layer instanceof L.ImageOverlay || layer instanceof L.Rectangle) {
                        map.removeLayer(layer);
                    }
                });

                if (activeLayer) {
                    const img = new Image();
                    img.src = activeLayer.url;
                    img.onload = () => {
                        const bounds = [[-img.height / 2, -img.width / 2], [img.height / 2, img.width / 2]];
                        const overlay = L.imageOverlay(activeLayer.url, bounds).addTo(map);
                        overlay.bringToBack();
                        map.fitBounds(bounds);
                    };
                } else {
                    const bounds = [[-500, -500], [500, 500]];
                    const rect = L.rectangle(bounds, { color: "#9ca3af", weight: 1, fill: false }).addTo(map);
                    rect.bringToBack();
                    map.fitBounds(bounds);
                }
            }, [activeLayer]);

            React.useEffect(() => {
                if (!leafletMap.current) return;
                markersRef.current.forEach(m => m.remove());
                markersRef.current = [];
                filteredArticles.forEach(article => {
                    const locs = getArticleLocations(article);
                    locs.forEach((loc) => {
                        const highlighted = highlightArticleId && highlightArticleId === article.id;
                        const color = highlighted ? '#10b981' : '#3b82f6';
                        const marker = L.circleMarker([loc.lat, loc.lng], { color, fillColor: color, fillOpacity: highlighted ? 0.9 : 0.6, radius: highlighted ? 14 : 8, weight: 2 })
                            .addTo(leafletMap.current)
                            .bindTooltip(loc.label || article.title, { permanent: true, direction: 'top', className: 'map-label' });

                        if (onSelectArticle) {
                            marker.on('click', () => onSelectArticle(article));
                        }
                        markersRef.current.push(marker);

                        if (highlighted && showControls && leafletMap.current) {
                            leafletMap.current.panTo([loc.lat, loc.lng], { animate: true });
                        }
                    });
                });
            }, [filteredArticles, highlightArticleId, showControls]);

            React.useEffect(() => {
                const updateMapSize = () => { if (leafletMap.current) leafletMap.current.invalidateSize(); };
                const resizeObserver = new ResizeObserver(updateMapSize);
                if (mapRef.current) resizeObserver.observe(mapRef.current);
                const timers = [100, 300, 500, 1000].map(delay => setTimeout(updateMapSize, delay));
                return () => { resizeObserver.disconnect(); timers.forEach(clearTimeout); };
            }, []);

            React.useEffect(() => { if (leafletMap.current) setTimeout(() => leafletMap.current.invalidateSize(), 200); }, [highlightArticleId]);

            return (
                <div className="relative w-full h-full group">
                    <div ref={mapRef} className="w-full h-full bg-slate-200 rounded-lg overflow-hidden" />

                    {/* Layer Switcher */}
                    {layers.length > 1 && (
                        <div className="absolute top-4 right-4 z-[1000] bg-white/90 p-2 rounded shadow-sm flex items-center gap-2">
                            <Icon name="layers" size={14} className="text-gray-500" />
                            <select
                                value={activeLayerId || ''}
                                onChange={e => setActiveLayerId(e.target.value)}
                                className="text-sm bg-transparent outline-none font-bold text-gray-700"
                            >
                                {layers.map(l => <option key={l.id} value={l.id}>{l.name}</option>)}
                            </select>
                        </div>
                    )}

                    {/* Map search input (visible when controls shown and not editing, and no external query) */}
                    {!isEditing && showControls && externalQuery === undefined && (
                        <div className="absolute top-4 left-4 z-[1000]">
                            <input
                                value={mapQuery}
                                onChange={e => {
                                    setMapQuery(e.target.value);
                                }}
                                placeholder="地図検索 (タイトル/本文/タグ)..."
                                className="p-2 rounded bg-white/90 text-sm border w-64 shadow-sm"
                            />
                        </div>
                    )}

                    {!isEditing && showControls && (
                        <div className="absolute bottom-4 left-4 right-4 z-[1000] bg-white/90 p-3 rounded-lg shadow-lg backdrop-blur flex flex-col gap-2 opacity-90 hover:opacity-100 transition-opacity duration-300">
                            <div className="flex justify-between text-xs font-bold text-gray-600">
                                <span>中心年代: {Math.floor(yearRange.currentCenter)}年</span>
                                <span>範囲: ±{Math.floor(yearRange.range)}年</span>
                            </div>
                            <div className="flex flex-col gap-1">
                                <label className="text-[10px] text-gray-500">
                                    選択年代 {yearRange.years && yearRange.years.length > 0 ? `(${yearRange.years[0]} ~ ${yearRange.years[yearRange.years.length - 1]})` : ''}
                                </label>
                                <input
                                    type="range"
                                    min={0}
                                    max={Math.max(0, (yearRange.years ? yearRange.years.length - 1 : 0))}
                                    value={yearRange.index || 0}
                                    onChange={e => {
                                        const idx = Number(e.target.value);
                                        const yrs = yearRange.years || [];
                                        if (yrs.length === 0) return;
                                        const newCenter = yrs[idx];
                                        const computeRange = (i) => {
                                            if (yrs.length === 1) return 50;
                                            if (i === 0) return Math.max(50, Math.floor((yrs[1] - yrs[0]) / 2));
                                            if (i === yrs.length - 1) return Math.max(50, Math.floor((yrs[i] - yrs[i - 1]) / 2));
                                            return Math.max(30, Math.floor(Math.min((yrs[i] - yrs[i - 1]) / 2, (yrs[i + 1] - yrs[i]) / 2)));
                                        };
                                        setYearRange(prev => {
                                            const newState = { ...prev, index: idx, currentCenter: newCenter };
                                            // only auto-compute range if user didn't override it
                                            if (!prev.manualRange) newState.range = computeRange(idx);
                                            return newState;
                                        });
                                    }}
                                    className="w-full h-1 bg-indigo-200 rounded-lg appearance-none cursor-pointer"
                                />
                                <div className="flex items-center gap-2">
                                    <div className="text-[10px] text-gray-500">表示範囲: ±{Math.floor(yearRange.range)}年</div>
                                    <div className="flex-1">
                                        {/* range slider: allow manual adjustment of ± years */}
                                        <input type="range" min={0} max={Math.max(1, Math.ceil((yearRange.max - yearRange.min) || 100))} value={yearRange.range || 0} onChange={e => setYearRange(prev => ({ ...prev, range: Number(e.target.value), manualRange: true }))} className="w-full h-1 bg-gray-300 rounded-lg appearance-none cursor-pointer" />
                                    </div>
                                </div>
                            </div>
                        </div>
                    )}
                </div>
            );
        };

        const SearchFilterBar = ({ searchState, onSearchChange, onResetFilters, count, variant = 'light' }) => {
            const handleChange = (field, value) => onSearchChange && onSearchChange({ [field]: value });
            const isDark = variant === 'dark';
            const bgClass = isDark ? 'bg-slate-800 border-slate-700 text-white' : 'bg-white border-gray-100 text-gray-800';
            const inputClass = isDark ? 'bg-slate-700 border-slate-600 text-white placeholder-slate-400' : 'bg-white border-gray-200 text-gray-800';
            return (
                <div className={`${bgClass} rounded-xl shadow-sm border p-4 space-y-3`}>
                    <div className="grid grid-cols-3 gap-3">
                        <input className={`w-full border rounded px-2 py-1.5 text-sm ${inputClass}`} value={searchState.keyword || ''} onChange={e => handleChange('keyword', e.target.value)} placeholder="名称" />
                        <input className={`w-full border rounded px-2 py-1.5 text-sm ${inputClass}`} value={searchState.tag || ''} onChange={e => handleChange('tag', e.target.value)} placeholder="#タグ" />
                        <select className={`w-full border rounded px-2 py-1.5 text-sm ${inputClass}`} value={searchState.type || 'all'} onChange={e => handleChange('type', e.target.value)}>{['all', ...Object.keys(ARTICLE_TYPES)].map(k => <option key={k} value={k}>{ARTICLE_TYPES[k]?.label || 'すべて'}</option>)}</select>
                    </div>
                    <div className="flex items-center gap-2 mt-2">
                        <label className="text-xs font-bold opacity-70">重要度:</label>
                        <div className="flex bg-gray-100 rounded p-0.5">
                            {[1, 2, 3, 4, 5].map(v => (
                                <button key={v} onClick={() => handleChange('minImportance', searchState.minImportance === v ? 0 : v)} className={`px-2 py-0.5 text-xs rounded ${searchState.minImportance === v ? 'bg-indigo-600 text-white font-bold' : searchState.minImportance > v ? 'text-indigo-600' : 'text-gray-400'}`}>
                                    {v}
                                </button>
                            ))}
                            <span className="text-[10px] items-center flex px-1 text-gray-400">{searchState.minImportance ? '以上' : '指定なし'}</span>
                        </div>
                    </div>
                    <div className="flex justify-between items-center text-xs opacity-80 mt-2">
                        <div className="flex items-center gap-2">
                            <span>{count}件</span>
                            <label className="flex items-center gap-1 cursor-pointer bg-black/10 px-2 py-0.5 rounded">
                                <input type="checkbox" checked={!!searchState.onlyApproved} onChange={e => handleChange('onlyApproved', e.target.checked)} />
                                承認済みのみ
                            </label>
                        </div>
                        <button onClick={onResetFilters}>クリア</button>
                    </div>
                </div>
            );
        };

        const TagMiniTimeline = ({ tag, articles = [], onSelectArticle, isTreeMode = false, selectedArticleId, onTagClick }) => {
            if (!tag) return null;
            const items = React.useMemo(() => sortByChronology(articles.filter(a => (a.tags || []).includes(tag))), [articles, tag]);

            const displayItems = React.useMemo(() => {
                if (!selectedArticleId || items.length === 0) return items.slice(0, 3);
                const currentIndex = items.findIndex(item => item.id === selectedArticleId);
                if (currentIndex === -1) return items.slice(0, 3);
                const start = Math.max(0, currentIndex - 1);
                const end = Math.min(items.length, currentIndex + 2);
                return items.slice(start, end);
            }, [items, selectedArticleId]);

            if (isTreeMode) {
                return (
                    <div className="min-w-[200px] bg-white/5 rounded-lg p-3 border border-white/10 snap-start shrink-0 relative">
                        <div className="absolute top-4 -left-4 w-4 h-px bg-white/30"></div>
                        <div onClick={() => onTagClick && onTagClick(tag)} className="text-xs font-bold text-white/80 mb-4 flex items-center gap-2 border-b border-white/10 pb-2 cursor-pointer hover:text-indigo-300 transition-colors"><Icon name="hash" size={12} /> {tag}<span className="ml-auto text-[10px] bg-white/10 px-1.5 rounded-full">{items.length}</span></div>
                        <div className="relative pl-4 space-y-0">
                            <div className="absolute left-0 top-2 bottom-2 w-px bg-white/20"></div>
                            {displayItems.map(item => {
                                const isCurrent = item.id === selectedArticleId;
                                return (
                                    <div key={item.id} className="relative py-1">
                                        <div className="mindmap-branch"></div>
                                        <button onClick={() => onSelectArticle && onSelectArticle(item)} className={`text-left w-full pl-2 py-1.5 rounded transition flex flex-col relative z-10 ${isCurrent ? 'bg-white/20 shadow' : 'hover:bg-white/10'}`}>
                                            <span className={`text-xs font-bold truncate w-full ${isCurrent ? 'text-white' : 'text-white/70'}`}>{item.title}</span>
                                            <span className="text-[10px] text-white/40 font-mono">{item.year}</span>
                                        </button>
                                    </div>
                                );
                            })}
                            {items.length > displayItems.length && <div className="text-[10px] text-white/40 italic pl-2 pt-1">他 {items.length - displayItems.length} 件</div>}
                            {items.length === 0 && <div className="text-[10px] text-white/30 italic">記事なし</div>}
                        </div>
                    </div>
                );
            }
            return null;
        };

        const TagTimelineColumns = ({ tags = [], articles = [], onSelectArticle, selectedArticleId, onTagClick }) => (
            <div className="flex gap-8 overflow-x-auto pb-4 snap-x-mandatory w-full custom-scrollbar pl-4">
                {tags.map(tag => <TagMiniTimeline key={tag} tag={tag} articles={articles} onSelectArticle={onSelectArticle} selectedArticleId={selectedArticleId} isTreeMode={true} onTagClick={onTagClick} />)}
            </div>
        );

        const RelatedArticlesList = ({ article, allArticles, onJump }) => {
            const related = React.useMemo(() => {
                const keywords = extractLinkedKeywords(article.contentHtml);
                // Outgoing
                const outgoing = allArticles.filter(a => keywords.includes(a.title) || keywords.includes(a.id));
                // Incoming (Backlinks)
                const incoming = allArticles.filter(a => {
                    const k = extractLinkedKeywords(a.contentHtml);
                    return k.includes(article.title) || k.includes(article.id);
                });
                // Merge & Dedup
                const combined = [...outgoing, ...incoming].filter((v, i, arr) => arr.findIndex(t => t.id === v.id) === i && v.id !== article.id);
                return sortByChronology(combined);
            }, [article, allArticles]);

            if (related.length === 0) return null;

            return (
                <div className="mb-6 pl-8">
                    <div className="mb-2 flex items-center gap-2 text-white/60 text-xs font-bold uppercase tracking-widest">関連する記事 ({related.length})</div>
                    <div className="flex flex-col gap-2 max-h-60 overflow-y-auto custom-scrollbar pr-2">
                        {related.map(r => (
                            <div key={r.id} className={`p-2 rounded border cursor-pointer hover:brightness-125 transition ${getImportanceClass(r.importance)}`} onClick={() => onJump && onJump(r)}>
                                <div className="flex justify-between items-start">
                                    <span className="text-xs font-bold truncate">{r.title}</span>
                                    <span className="text-[10px] opacity-70 whitespace-nowrap ml-2">{getArticleYear(r)}年</span>
                                </div>
                                <div className="text-[10px] opacity-60 truncate mt-0.5">{ARTICLE_TYPES[r.type]?.label || 'その他'}</div>
                            </div>
                        ))}
                    </div>
                </div>
            );
        };

        // --- Large Spreadsheet View (Database View) ---
        const LargeSpreadsheetView = ({ articles, db, appContextId, worldId, filters }) => {
            const containerRef = React.useRef(null);
            const jexcelRef = React.useRef(null);

            // フィルタリング
            const filtered = articles.filter(a => {
                if (filters.type !== 'all' && a.type !== filters.type) return false;
                if (filters.tag && !((a.tags || []).includes(filters.tag) || a.representedTag === filters.tag)) return false;
                if (filters.keyword) {
                    const k = filters.keyword.toLowerCase();
                    return a.title.toLowerCase().includes(k) || (a.folder || '').toLowerCase().includes(k);
                }
                return true;
            }).sort((a, b) => (a.year || 0) - (b.year || 0));

            const handleExport = () => {
                if (jexcelRef.current) {
                    jexcelRef.current.download('world_weaver_data.csv');
                }
            };

            const handleBulkImport = async () => {
                const input = prompt("スプレッドシート（Google Sheets等）からコピーしたデータをここに貼り付けてください。\n(フォーマット: タイトル\t種別\tフォルダ\t年代\t重要度)");
                if (!input) return;

                const rows = input.split('\n').filter(r => r.trim());
                if (rows.length === 0) return;

                const { addDoc, collection, serverTimestamp } = window.firebaseModules;
                let count = 0;

                try {
                    for (const row of rows) {
                        const cols = row.split('\t');
                        if (cols.length < 1) continue;

                        const title = cols[0].trim();
                        if (!title) continue;

                        const type = Object.keys(ARTICLE_TYPES).includes(cols[1]?.trim()) ? cols[1].trim() : 'other';
                        const folder = cols[2]?.trim() || '未分類';
                        const year = Number(cols[3]) || 0;
                        const importance = Number(cols[4]) || 3;

                        await addDoc(collection(db, 'artifacts', appContextId, 'public', 'data', 'worlds', worldId, 'articles'), {
                            ...createEmptyArticle(),
                            title, type, folder, year, importance,
                            createdAt: serverTimestamp(),
                            updatedAt: serverTimestamp(),
                            isApproved: true
                        });
                        count++;
                    }
                    alert(`${count}件の記事を一括追加しました。`);
                } catch (e) {
                    alert("インポート失敗: " + e.message);
                }
            };

            React.useEffect(() => {
                if (!containerRef.current) return;

                const data = filtered.map(a => [
                    a.id,
                    a.title,
                    a.type,
                    a.folder,
                    a.year || 0,
                    a.importance || 3,
                    (a.tags || []).join(', '),
                    a.isApproved ? 'Yes' : 'No'
                ]);

                if (jexcelRef.current) {
                    jexcelRef.current.destroy();
                }

                const wikiLinkRenderer = (instance, td, col, row, index, val) => {
                    td.innerHTML = transformContent(val);
                };

                jexcelRef.current = jspreadsheet(containerRef.current, {
                    data: data,
                    columns: [
                        { type: 'text', title: 'ID', width: 80, readOnly: true },
                        { type: 'text', title: 'タイトル', width: 250, renderer: wikiLinkRenderer },
                        { type: 'dropdown', title: '種別', width: 100, source: Object.keys(ARTICLE_TYPES) },
                        { type: 'text', title: 'フォルダ', width: 120, renderer: wikiLinkRenderer },
                        { type: 'numeric', title: '年代', width: 80 },
                        { type: 'numeric', title: '重要度', width: 60 },
                        { type: 'text', title: 'タグ', width: 200, renderer: wikiLinkRenderer },
                        { type: 'checkbox', title: '承認', width: 60 },
                    ],
                    onchange: async (instance, cell, col, row, val) => {
                        const articleId = jexcelRef.current.getValueFromCoords(0, row);
                        const fields = ['id', 'title', 'type', 'folder', 'year', 'importance', 'tags', 'isApproved'];
                        const field = fields[col];

                        let finalValue = val;
                        if (field === 'year' || field === 'importance') finalValue = Number(val);
                        if (field === 'tags') finalValue = val.split(',').map(s => s.trim()).filter(Boolean);
                        if (field === 'isApproved') finalValue = (val === true || val === '1' || val === 'Yes');

                        if (field && field !== 'id') {
                            try {
                                const { doc, updateDoc } = window.firebaseModules;
                                await updateDoc(doc(db, 'artifacts', appContextId, 'public', 'data', 'worlds', worldId, 'articles', articleId), {
                                    [field]: finalValue
                                });
                            } catch (e) {
                                console.error("Update failed", e);
                            }
                        }
                    },
                    allowInsertRow: false,
                    allowDeleteRow: false,
                    csvHeaders: true,
                    search: true,
                    pagination: 20,
                });
            }, [filtered.length, db, appContextId, worldId]);

            return (
                <div className="p-4 bg-white rounded-xl shadow-sm border border-slate-200 overflow-hidden h-full flex flex-col" onClick={(e) => {
                    const link = e.target.closest('.wiki-link');
                    if (link && window.openArticleById) {
                        e.preventDefault();
                        e.stopPropagation();
                        const id = link.getAttribute('data-article-id');
                        const wikiTitle = link.getAttribute('data-wiki-title');
                        window.openArticleById(id || wikiTitle);
                    }
                }}>
                    <div className="mb-4 flex justify-between items-center bg-slate-50 p-3 rounded-lg border border-slate-100">
                        <div className="flex items-center gap-4">
                            <h2 className="text-xl font-bold text-slate-800 flex items-center gap-2">
                                <Icon name="table-2" className="text-indigo-600" /> 世界データ管理
                            </h2>
                            <span className="text-xs text-slate-500 font-medium px-2 py-1 bg-white rounded border border-slate-200">
                                全 {filtered.length} 件表示中
                            </span>
                        </div>
                        <div className="flex gap-2">
                            <button onClick={handleBulkImport} className="px-4 py-2 bg-emerald-600 hover:bg-emerald-700 text-white text-xs font-bold rounded shadow-sm flex items-center gap-1 transition-all active:scale-95">
                                <Icon name="plus-square" size={14} /> 一括インポート
                            </button>
                            <button onClick={handleExport} className="px-4 py-2 bg-indigo-600 hover:bg-indigo-700 text-white text-xs font-bold rounded shadow-sm flex items-center gap-1 transition-all active:scale-95">
                                <Icon name="download" size={14} /> CSV保存
                            </button>
                        </div>
                    </div>
                    <div className="flex-1 overflow-auto rounded-lg border border-slate-100 shadow-inner bg-slate-50/30 p-2">
                        <div ref={containerRef}></div>
                    </div>
                    <div className="mt-3 p-3 bg-blue-50/50 rounded-lg border border-blue-100/50 flex items-start gap-2">
                        <Icon name="info" size={16} className="text-blue-500 mt-0.5 shrink-0" />
                        <div className="text-[11px] text-blue-700 leading-relaxed">
                            <span className="font-bold">Googleスプレッドシート互換:</span> セルをコピー（Ctrl+C）して外部に貼り付けたり、外部のデータをインポートボタンから一括作成したりできます。編集内容はリアルタイムでデータベースに反映されます。
                        </div>
                    </div>
                </div>
            );
        };

        // --- LargeTimelineView (構造年表: 統合版) ---
        const LargeTimelineView = ({ articles = [], onSelectArticle, onEditArticle, onDeleteArticle, onDuplicateArticle, focusedArticle, onFocusChange, allArticles = [], searchState, onSearchChange, onResetFilters, worldData, appContextId, myRole, onOpenNoYear, onOpenTagArticle, tagArticleValue, onTagArticleValueChange, members = [], onAddMember }) => {
            const [showSearch, setShowSearch] = React.useState(false);
            const [centeredArticleId, setCenteredArticleId] = React.useState(null);
            const [viewMode, setViewMode] = React.useState('broad'); // 'broad' (title only) or 'detailed'
            const containerRef = React.useRef(null);
            const articleRefs = React.useRef(new Map());
            const noYearRefs = React.useRef(new Map());
            const sortedArticles = React.useMemo(() => sortByChronology(articles), [articles]);
            const isJumpingRef = React.useRef(false);


            const noYearArticles = React.useMemo(() => sortedArticles.filter(a => {
                // noYearフラグが立っている、または年代が0/nullの記事
                if (a.noYear === true) return true;
                const y = Math.floor(getArticleYear(a));
                return !y || Number(y) === 0;
            }).sort((a, b) => String(a.title || '').localeCompare(String(b.title || ''))), [sortedArticles]);

            const datedArticles = React.useMemo(() => sortedArticles.filter(a => {
                // noYearフラグが立っている記事は除外
                if (a.noYear === true) return false;
                const y = Math.floor(getArticleYear(a));
                return y && Number(y) !== 0;
            }), [sortedArticles]);

            const displayArticles = React.useMemo(() => {
                // 詳細モードで年代あり記事を表示する場合のロジック
                // 年代なし記事は年表に表示しない（datedArticlesにはすでに含まれていない）
                // if (viewMode === 'detailed' && focusedArticle) {
                //     if (focusedArticle.noYear === true) return [focusedArticle];
                //     const y = Math.floor(getArticleYear(focusedArticle));
                //     if (!y || y === 0) return [focusedArticle];
                // }
                return datedArticles;
            }, [datedArticles]);

            const scrollToArticle = (id) => {
                // wait for render if switching modes
                setTimeout(() => {
                    const el = articleRefs.current.get(id);
                    if (el) el.scrollIntoView({ behavior: 'smooth', block: 'center' });
                }, 100);
            };

            const scrollToNoYearArticle = (id) => {
                const el = noYearRefs.current.get(id);
                if (el) el.scrollIntoView({ behavior: 'smooth', block: 'center' });
            };

            const handleJump = (item) => {
                isJumpingRef.current = true;
                const inList = sortedArticles.some(a => a.id === item.id);
                if (onResetFilters) onResetFilters();

                // Always switch to detailed view when jumping to a specific item
                if (viewMode === 'broad') setViewMode('detailed');

                if (!inList) {
                    if (onSelectArticle) onSelectArticle(item);
                    setTimeout(() => { scrollToArticle(item.id); isJumpingRef.current = false; }, 200);
                } else {
                    if (onSelectArticle) onSelectArticle(item);
                    setTimeout(() => { scrollToArticle(item.id); isJumpingRef.current = false; }, 100);
                }
            };

            const handleContentClick = (e) => {
                const link = e.target.closest('.wiki-link');
                if (link) {
                    e.preventDefault(); e.stopPropagation();
                    const id = link.getAttribute('data-article-id');
                    const wikiTitle = link.getAttribute('data-wiki-title');

                    const openTarget = (target) => {
                        if (onSelectArticle) onSelectArticle(target);

                        const y = getArticleYear(target);
                        const hasYear = y && Number(y) !== 0 && !target.noYear;

                        // 記事の年代状態に応じてフィルタを調整
                        if (typeof onSearchChange === 'function') {
                            onSearchChange({ excludeNoYear: hasYear });
                        }

                        if (hasYear) {
                            if (window.setAppViewMode) window.setAppViewMode('timeline_large');
                        } else {
                            if (window.setAppViewMode) window.setAppViewMode('single_article');
                        }

                        if (typeof onResetFilters !== 'undefined' && onResetFilters) onResetFilters();
                    };

                    if (id) {
                        const target = allArticles.find(a => a.id === id);
                        if (target) {
                            openTarget(target);
                        } else alert("リンク先の記事が見つかりません");
                    } else if (wikiTitle) {
                        if (wikiTitle === '年代なし') {
                            if (onOpenNoYear) onOpenNoYear();
                        } else {
                            const target = allArticles.find(a => (a.title || '').trim() === wikiTitle.trim());
                            if (target) openTarget(target); else alert("リンク先の記事が見つかりません");
                        }
                    }
                }
            };

            const handleScroll = () => {
                if (isJumpingRef.current || !containerRef.current || viewMode === 'broad') return;
                const container = containerRef.current;
                const containerRect = container.getBoundingClientRect();
                const centerY = containerRect.top + containerRect.height / 2;

                let closest = null, minDst = Infinity;
                sortedArticles.forEach(a => {
                    const el = articleRefs.current.get(a.id);
                    if (el) {
                        const elRect = el.getBoundingClientRect();
                        const elCenterY = elRect.top + elRect.height / 2;
                        const dst = Math.abs(elCenterY - centerY);
                        if (dst < minDst) { minDst = dst; closest = a; }
                    }
                });
                if (closest && closest.id !== centeredArticleId) {
                    setCenteredArticleId(closest.id);
                    if (onFocusChange) onFocusChange(closest);
                }
            };

            React.useEffect(() => { if (focusedArticle) { const t = setTimeout(() => scrollToArticle(focusedArticle.id), 500); return () => clearTimeout(t); } }, [focusedArticle]);
            const activeArticle = focusedArticle && focusedArticle.id === centeredArticleId ? focusedArticle : sortedArticles.find(a => a.id === centeredArticleId) || focusedArticle;


            // 外部から記事が選択されたとき（地図モードなどから遷移してきたとき）は詳細モードに切り替える
            React.useEffect(() => {
                if (focusedArticle && viewMode === 'broad') {
                    setViewMode('detailed');
                }
            }, [focusedArticle]);

            return (
                <div className="h-full w-full overflow-hidden bg-slate-900 text-white relative flex flex-col">
                    <div className="shrink-0 bg-slate-900/90 backdrop-blur px-4 md:px-6 py-4 border-b border-white/10 z-20 relative flex justify-between items-center">
                        <div className="flex flex-col">
                            <div className="text-[11px] uppercase tracking-widest text-white/60">LARGE TIMELINE</div>
                            <div className="flex items-center gap-3 flex-wrap">
                                <div className="text-sm text-white mt-1 flex-1">{searchState.keyword || searchState.tag || "全記事"}</div>
                                <input className="text-sm p-1 rounded bg-white/90 text-gray-800 w-full sm:w-64" placeholder="本文検索..." value={searchState.keyword || ''} onChange={e => onSearchChange({ keyword: e.target.value })} />
                                <label className="ml-3 text-xs text-white/70 flex items-center gap-2"><input type="checkbox" checked={!!searchState.excludeNoYear} onChange={e => onSearchChange({ excludeNoYear: e.target.checked })} /> 年代設定記事モード</label>

                                {onOpenTagArticle && (
                                    <div className="flex items-center gap-1 ml-0 sm:ml-4 w-full sm:w-auto">
                                        <input className="text-sm p-1 rounded bg-white/90 text-gray-800 w-full sm:w-40" placeholder="#タグ/キーワード" value={tagArticleValue || ''} onChange={e => onTagArticleValueChange && onTagArticleValueChange(e.target.value)} />
                                        <button onClick={() => { if (tagArticleValue) onOpenTagArticle(tagArticleValue); }} className="px-2 py-1 bg-emerald-500 text-white text-xs rounded">タグ記録</button>
                                    </div>
                                )}
                            </div>
                        </div>
                        <div className="flex items-center gap-2">
                            <div className="flex bg-white/10 rounded p-1">
                                <button onClick={() => setViewMode('broad')} className={`px-3 py-1 text-xs rounded transition ${viewMode === 'broad' ? 'bg-indigo-600 text-white font-bold' : 'text-white/60 hover:text-white'}`}>年表 (全体)</button>
                                <button onClick={() => setViewMode('detailed')} className={`px-3 py-1 text-xs rounded transition ${viewMode === 'detailed' ? 'bg-indigo-600 text-white font-bold' : 'text-white/60 hover:text-white'}`}>詳細</button>
                            </div>
                            <button onClick={() => setShowSearch(!showSearch)} className="p-2 bg-white/10 rounded"><Icon name="search" size={18} /></button>
                        </div>
                        {showSearch && <div className="absolute top-full left-0 right-0 z-30 mt-2 px-4"><SearchFilterBar searchState={searchState} onSearchChange={onSearchChange} onResetFilters={onResetFilters} count={articles.length} variant="dark" /></div>}
                    </div>
                    <div className="flex-1 flex relative overflow-hidden">
                        {/* 年代未設定記事のセクション（スクロール内の最上部に表示） */}
                        {noYearArticles.length > 0 && (
                            <div className="w-full p-6 border-b border-white/10 z-10 bg-transparent">
                                <div className="flex items-center justify-between mb-3">
                                    <div className="text-sm font-bold text-white">年代未設定の記事</div>
                                    <div className="text-xs text-white/60">編集で「年代なし」を設定した記事</div>
                                </div>
                                <div className="grid gap-3 sm:grid-cols-2 md:grid-cols-3 lg:grid-cols-4 max-h-60 overflow-y-auto">
                                    {noYearArticles.map(a => (
                                        <div key={a.id} ref={el => el ? noYearRefs.current.set(a.id, el) : noYearRefs.current.delete(a.id)} data-noyear-id={a.id} className="bg-white/5 p-3 rounded-lg border border-white/5 flex flex-col">
                                            <div className="flex justify-between items-start gap-2">
                                                <div className="text-sm font-bold text-white truncate">{a.title}</div>
                                                <div className="text-[10px] text-white/60">{a.dateStr || ''}</div>
                                            </div>
                                            <div className="text-xs text-white/60 mt-2 line-clamp-2" onClick={handleContentClick} dangerouslySetInnerHTML={{ __html: highlightHtml(transformContent(a.contentHtml || ''), searchState.keyword) }}></div>
                                            {(myRole === 'owner' || myRole === 'admin') && a.createdBy && (
                                                <div className="mt-2 flex items-center justify-between">
                                                    <div onClick={(e) => { e.stopPropagation(); copyText(a.createdBy); }} className="text-[10px] text-white/30 cursor-pointer hover:text-white truncate" title="作成者UIDをコピー">UID: {a.createdBy.slice(0, 6)}...</div>
                                                    {!members.some(m => m.id === a.createdBy) && (
                                                        <button onClick={(e) => { e.stopPropagation(); onAddMember && onAddMember(a.createdBy, a.title + " 作者"); }} className="text-[10px] bg-emerald-600/20 text-emerald-400 border border-emerald-500/30 px-1.5 py-0.5 rounded hover:bg-emerald-600/40">メンバ追加</button>
                                                    )}
                                                </div>
                                            )}
                                            <div className="mt-3 flex gap-2 justify-end">
                                                <button type="button" style={{ position: 'relative', zIndex: 1000, pointerEvents: 'auto' }} onClick={(e) => {
                                                    e.stopPropagation();
                                                    if (typeof onSearchChange === 'function') {
                                                        try { onSearchChange({ type: 'all', keyword: '', tag: '', excludeNoYear: false }); }
                                                        catch (err) { console.warn('onSearchChange failed', err); }
                                                    }
                                                    if (typeof onOpenNoYear === 'function') {
                                                        onOpenNoYear(a.id);
                                                        return;
                                                    }
                                                    setTimeout(() => {
                                                        if (onSelectArticle) onSelectArticle(a);
                                                        // Switch to dedicated single article view for complex layouts
                                                        if (window.setAppViewMode) window.setAppViewMode('single_article');
                                                    }, 150);
                                                }} className="px-2 py-1 text-xs bg-white/10 rounded">表示</button>
                                                <button type="button" style={{ position: 'relative', zIndex: 1000, pointerEvents: 'auto' }} onClick={(e) => { e.stopPropagation(); onEditArticle && onEditArticle(a); }} className="px-2 py-1 text-xs bg-indigo-600 text-white rounded">編集</button>
                                                <button type="button" style={{ position: 'relative', zIndex: 1000, pointerEvents: 'auto' }} onClick={(e) => { e.stopPropagation(); onDuplicateArticle && onDuplicateArticle(a); }} className="px-2 py-1 text-xs bg-emerald-600 text-white rounded">複製</button>
                                                {(myRole === 'owner' || myRole === 'admin') && <button type="button" style={{ position: 'relative', zIndex: 1000, pointerEvents: 'auto' }} onClick={(e) => { e.stopPropagation(); onDeleteArticle && onDeleteArticle(a); }} className="px-2 py-1 text-xs bg-red-600 text-white rounded">削除</button>}
                                            </div>
                                        </div>
                                    ))}
                                </div>
                            </div>
                        )}

                        {viewMode === 'detailed' && (() => {
                            const yearVal = activeArticle ? getArticleYear(activeArticle) : 0;
                            const isBC = yearVal < 0;
                            const rulerClass = isBC
                                ? "bg-red-950 border-r border-red-900/30"
                                : "bg-slate-950 border-r border-white/10";
                            const labelBg = isBC ? "bg-red-900" : "bg-slate-900";
                            const labelText = isBC ? "text-red-200" : "text-indigo-400";
                            const labelBorder = isBC ? "border-red-500/50" : "border-indigo-500/30";

                            return (
                                <div className={`w-12 hidden md:block timeline-ruler z-10 sticky top-0 h-full ${rulerClass}`}>
                                    <div className={`absolute top-1/2 w-full text-center text-[10px] font-bold py-1 border-y transform -translate-y-1/2 ${labelBg} ${labelText} ${labelBorder}`}>
                                        {activeArticle ? Math.floor(yearVal) : '???'}
                                    </div>
                                </div>
                            );
                        })()}

                        <div ref={containerRef} className={`flex-1 overflow-y-auto scroll-smooth relative ${viewMode === 'detailed' ? 'p-4 md:p-10' : 'p-6'}`} onScroll={handleScroll}>
                            {viewMode === 'detailed' && <div className="absolute left-8 top-0 bottom-0 w-px bg-white/10 z-0 md:left-20"></div>}

                            {viewMode === 'broad' ? (
                                <div className="relative pb-16">
                                    <div className="absolute left-6 top-0 bottom-0 w-px bg-white/10"></div>
                                    <div className="flex flex-col gap-5">
                                        {datedArticles.map((article) => (
                                            <div
                                                key={article.id}
                                                ref={el => el ? articleRefs.current.set(article.id, el) : articleRefs.current.delete(article.id)}
                                                onClick={() => {
                                                    if (onSelectArticle) onSelectArticle(article);
                                                    setCenteredArticleId(article.id);
                                                    setViewMode('detailed');
                                                    setTimeout(() => scrollToArticle(article.id), 100);
                                                }}
                                                className="relative pl-12"
                                            >
                                                <div className="absolute left-3 top-4 w-3 h-3 rounded-full bg-indigo-400 shadow-[0_0_0_4px_rgba(99,102,241,0.25)]"></div>
                                                <div className={`bg-white/5 border rounded-lg p-4 cursor-pointer hover:bg-white/10 hover:border-indigo-500/50 transition group flex flex-col ${getImportanceStyle(article.importance).card}`}>
                                                    <div className="flex justify-between items-start mb-1">
                                                        <span className={`text-[10px] px-1.5 py-0.5 rounded ${ARTICLE_TYPES[article.type]?.color || 'bg-gray-700 text-gray-300'}`}>{ARTICLE_TYPES[article.type]?.label}</span>
                                                        <span className="text-[10px]">{getImportanceStyle(article.importance).badge}</span>
                                                        <span className="font-mono text-indigo-300 text-xs font-bold">{getArticleYear(article)}</span>
                                                    </div>
                                                    <h3 className="text-sm font-bold text-white group-hover:text-indigo-300 line-clamp-2">{article.title}</h3>
                                                    <div className="text-[11px] text-white/50 mt-2 line-clamp-2" onClick={handleContentClick} dangerouslySetInnerHTML={{ __html: highlightHtml(transformContent(article.contentHtml || ''), searchState.keyword) }}></div>
                                                    <div className="text-[10px] text-white/40 mt-2 truncate">{article.dateStr}</div>
                                                </div>
                                            </div>
                                        ))}
                                    </div>
                                </div>
                            ) : (
                                <div className="flex flex-col gap-12 py-10">
                                    {displayArticles.map((article) => {
                                        const isActive = (focusedArticle?.id === article.id) || (centeredArticleId === article.id);
                                        return (
                                            <div key={article.id} data-article-id={article.id} ref={el => el ? articleRefs.current.set(article.id, el) : articleRefs.current.delete(article.id)} className="w-full flex flex-col relative box-border">
                                                <div className="w-full flex flex-col md:flex-row items-center md:items-center gap-0 z-10 relative">
                                                    <div className={`flex-1 w-full transition-all duration-500 ${isActive ? 'opacity-100 scale-100' : 'opacity-30 scale-95 grayscale'}`}>
                                                        <div className={`text-left text-gray-800 rounded-2xl shadow-2xl overflow-hidden border-4 relative w-full bg-white transition-all duration-300 ${getImportanceStyle(article.importance).card}`}>
                                                            <div className="h-32 bg-gradient-to-r from-indigo-900 to-slate-800 p-6 flex items-end relative" onClick={() => { isJumpingRef.current = true; if (onSelectArticle) onSelectArticle(article); scrollToArticle(article.id); setTimeout(() => isJumpingRef.current = false, 500); }}>
                                                                <h1 className="text-2xl md:text-3xl font-bold text-white z-10 serif flex items-center gap-2">
                                                                    {article.title}
                                                                    {article.isApproved && <Icon name="check-circle" size={24} className="text-emerald-400" title="承認済み" />}
                                                                </h1>
                                                                <div className="absolute right-4 bottom-4 text-white/20"><Icon name={ARTICLE_TYPES[article.type]?.icon} size={80} /></div>
                                                                <div className="absolute top-2 right-2 flex flex-col gap-1 items-end">
                                                                    <button onClick={(e) => { e.stopPropagation(); copyText(article.id); }} className="text-white/50 hover:text-white bg-black/20 px-2 py-1 rounded text-xs">ID: {article.id.slice(0, 4)}...</button>
                                                                    {(myRole === 'owner' || myRole === 'admin') && article.createdBy && (
                                                                        <div className="flex flex-col items-end gap-1">
                                                                            <button onClick={(e) => { e.stopPropagation(); copyText(article.createdBy); }} className="text-white/30 hover:text-white bg-black/20 px-2 py-1 rounded text-[10px]" title="作成者UIDをコピー">UID: {article.createdBy.slice(0, 8)}...</button>
                                                                            {!members.some(m => m.id === article.createdBy) && (
                                                                                <button onClick={(e) => { e.stopPropagation(); onAddMember && onAddMember(article.createdBy, article.title + " 作者"); }} className="text-[10px] bg-emerald-600/40 text-emerald-200 border border-emerald-500/30 px-2 py-0.5 rounded hover:bg-emerald-600/60 transition">メンバーに追加</button>
                                                                            )}
                                                                        </div>
                                                                    )}
                                                                </div>
                                                            </div>
                                                            <div className="p-6">
                                                                <div className="flex gap-2 text-xs text-gray-500 mb-4">
                                                                    <span className="bg-gray-100 px-2 py-1 rounded">{ARTICLE_TYPES[article.type]?.label}</span>
                                                                    <span className="font-mono text-indigo-600 font-bold bg-indigo-50 px-2 py-1 rounded">{article.dateStr || `Year: ${article.year}`}</span>
                                                                </div>
                                                                <div className="prose prose-sm max-w-none text-gray-800 mb-4" dangerouslySetInnerHTML={{ __html: highlightHtml(transformContent(article.contentHtml), searchState.keyword) }} onClick={handleContentClick}></div>
                                                                {article.mainImageUrl && <img src={article.mainImageUrl} className="w-full rounded-lg object-cover max-h-48 border" alt={article.title} />}
                                                                <div className="mt-4 pt-4 border-t flex justify-end gap-2">
                                                                    <button onClick={(e) => { e.stopPropagation(); onEditArticle(article); }} className="flex items-center gap-1 text-xs text-gray-400 hover:text-indigo-600 border px-2 py-1 rounded hover:bg-gray-50"><Icon name="edit-2" size={12} /> 編集</button>
                                                                    <button onClick={(e) => { e.stopPropagation(); onDuplicateArticle && onDuplicateArticle(article); }} className="flex items-center gap-1 text-xs text-emerald-600 hover:text-emerald-800 border border-emerald-200 px-2 py-1 rounded hover:bg-emerald-50"><Icon name="copy" size={12} /> 複製</button>
                                                                    {(myRole === 'owner' || myRole === 'admin') && <button onClick={(e) => { e.stopPropagation(); onDeleteArticle && onDeleteArticle(article); }} className="flex items-center gap-1 text-xs text-red-500 hover:text-red-700 border border-red-200 px-2 py-1 rounded hover:bg-red-50"><Icon name="trash-2" size={12} /> 削除</button>}
                                                                </div>
                                                            </div>
                                                        </div>
                                                        {isActive && (
                                                            <div className="mt-4 h-64 w-full rounded-xl overflow-hidden border border-white/20 relative bg-slate-800 shadow-lg animate-[fadeIn_0.3s_ease-out]">
                                                                <div className="absolute top-2 left-2 z-[500] text-[10px] font-bold text-black bg-white/80 px-2 py-0.5 rounded shadow backdrop-blur">LOCATION</div>
                                                                <MapView articles={[article]} worldData={worldData} highlightArticleId={article.id} appContextId={appContextId} showControls={false} />
                                                            </div>
                                                        )}
                                                    </div>
                                                    {isActive && (
                                                        <div className="flex flex-row items-center animate-[fadeIn_0.5s_ease-out] self-stretch md:self-auto w-full md:w-auto mt-8 md:mt-0">
                                                            <div className="hidden md:block w-12 h-px bg-white/30 shrink-0"></div>
                                                            <div className="w-full md:w-[320px] shrink-0 pl-0 md:pl-0 border-l-0 md:border-l border-white/30 py-4 relative">
                                                                <div className="hidden md:block absolute left-[-1px] top-1/2 w-2 h-2 bg-white rounded-full -translate-y-1/2 -translate-x-1/2 shadow-[0_0_10px_white]"></div>

                                                                {/* 関連する記事 (Related Articles) */}
                                                                <RelatedArticlesList article={article} allArticles={allArticles} onJump={handleJump} />

                                                                <div className="mb-2 flex items-center gap-2 text-white/60 text-xs font-bold uppercase tracking-widest pl-8">関連マインドマップ</div>
                                                                <TagTimelineColumns tags={article.tags} articles={allArticles} onSelectArticle={(item) => handleJump(item)} onTagClick={(t) => { isJumpingRef.current = true; if (onSearchChange) onSearchChange({ tag: t }); }} selectedArticleId={article.id} isTreeMode={true} variant="light" />
                                                                {article.stats && article.stats.length > 0 && (
                                                                    <div className="bg-white/5 rounded-xl p-4 border border-white/10 ml-8 mt-4"><div className="text-xs font-bold text-white/50 mb-2 border-b border-white/10 pb-1">STATS</div>{article.stats.map((s, i) => (<div key={i} className="flex justify-between text-sm text-white/80 py-1"><span>{s.label}</span><span className="font-bold font-mono text-indigo-300">{s.value}</span></div>))}</div>
                                                                )}
                                                            </div>
                                                        </div>
                                                    )}
                                                </div>
                                            </div>
                                        );
                                    })}
                                </div>
                            )}
                        </div>
                    </div>
                </div>
            );
        };

        // --- SimpleLineChart & GraphView: 年表からの統計表示機能 (年表(1)から移植・簡易化)
        // 記事本文中の <table> を解析して「ステータス名 -> 数値」マップを返す（年は記事の年を使う）
        const parseTablesFromHtml = (html) => {
            if (!html) return {};
            try {
                const parser = new DOMParser();
                const doc = parser.parseFromString(html, 'text/html');
                const map = {}; // label -> summed value within article

                // 1) csv-block があれば優先して読み取る
                const csvBlocks = Array.from(doc.querySelectorAll('.csv-block'));
                if (csvBlocks.length > 0) {
                    csvBlocks.forEach(cb => {
                        const raw = cb.getAttribute('data-csv') || '';
                        const decoded = raw ? decodeURIComponent(raw) : '';
                        if (!decoded) return;
                        const rows = parseCSV(decoded, ',');
                        rows.forEach(r => {
                            if (r.length >= 2) {
                                const label = r[0];
                                const val = parseFloat((r[1] || '').replace(/[,\s]/g, ''));
                                if (label && !isNaN(val)) map[label] = (map[label] || 0) + Number(val);
                            }
                        });
                    });
                    return map;
                }

                // 2) 通常の <table> 要素をパース
                const tables = Array.from(doc.querySelectorAll('table'));
                tables.forEach((table) => {
                    const rows = Array.from(table.querySelectorAll('tr'));
                    rows.forEach((row) => {
                        const cells = Array.from(row.querySelectorAll('td,th')).map(c => c.textContent.trim());
                        if (cells.length >= 2) {
                            const label = cells[0];
                            const val = parseFloat(cells[1].replace(/[,\s]/g, ''));
                            if (label && !isNaN(val)) {
                                map[label] = (map[label] || 0) + Number(val);
                            }
                        }
                    });
                });
                return map;
            } catch (e) { return {}; }
        };

        const collectAllTags = (articles = []) => {
            const set = new Set();
            articles.forEach(a => (a.tags || []).forEach(t => t && set.add(t)));
            return Array.from(set).sort((a, b) => a.localeCompare(b));
        };

        // articles: list, selectedTags: 条件タグ(複数), groupTag: 要素タグ（同一要素扱い）
        // statusA/statusB: 統計ステータス名（ラベル）
        // op: '+','-','*','/'
        const collectAllStatusLabels = (articles = []) => {
            const set = new Set();
            articles.forEach(a => {
                // from article.stats
                if (Array.isArray(a.stats)) a.stats.forEach(s => { if (s && s.label) set.add(String(s.label)); });
                // from tables
                const tableMap = parseTablesFromHtml(a.contentHtml || '');
                Object.keys(tableMap).forEach(k => set.add(k));
                // from fetched sheet data (if available)
                if (a.fetchedSheetData) {
                    Object.keys(a.fetchedSheetData).forEach(k => set.add(k));
                }
            });
            // マッピング設定のフィールド名も候補に追加
            const mappings = window.worldData?.sheetFieldMappings || [];
            mappings.forEach(m => set.add(m.field));

            return Array.from(set).sort((a, b) => a.localeCompare(b));
        };

        const aggregateSeriesByGroup = (articles = [], selectedTags = [], groupTags = [], statusA = '', statusB = '', op = '+') => {
            // filter by condition tags: if none selected include all, otherwise include articles that have ANY of the selectedTags
            const selected = articles.filter(a => {
                if (!selectedTags || selectedTags.length === 0) return true;
                const tags = (a.tags || []).map(t => String(t));
                return selectedTags.some(st => tags.includes(st));
            });

            // prepare per-article status map: label -> numeric value
            const perArticle = selected.map(a => {
                const year = Math.floor(getArticleYear(a));
                const map = {};
                // stats array
                if (Array.isArray(a.stats)) {
                    a.stats.forEach(s => {
                        const lbl = s.label || s.name || '';
                        const v = parseFloat(s.value || s.v || s.gdp || s.population || NaN);
                        if (lbl && !isNaN(v)) map[String(lbl)] = (map[String(lbl)] || 0) + Number(v);
                    });
                }
                const tableMap = parseTablesFromHtml(a.contentHtml || '');
                Object.keys(tableMap).forEach(k => { map[k] = (map[k] || 0) + Number(tableMap[k]); });

                // fetched sheet data
                if (a.fetchedSheetData) {
                    Object.keys(a.fetchedSheetData).forEach(k => {
                        const val = parseFloat(a.fetchedSheetData[k]);
                        if (!isNaN(val)) map[k] = (map[k] || 0) + Number(val);
                    });
                }

                return { article: a, year, map };
            });

            // grouping: support multiple groupTags (element tags). If groupTags provided, only create groups for those tags
            const groups = new Map();
            const useGroupTags = Array.isArray(groupTags) && groupTags.length > 0;
            perArticle.forEach(({ article, year, map }) => {
                const tags = (Array.isArray(article.tags) ? article.tags : []).map(t => String(t));
                if (useGroupTags) {
                    groupTags.forEach(gt => {
                        if (tags.includes(gt)) {
                            const key = gt;
                            if (!groups.has(key)) groups.set(key, new Map());
                            const yearMap = groups.get(key);
                            if (!yearMap.has(year)) yearMap.set(year, { A: 0, B: 0 });
                            const entry = yearMap.get(year);
                            if (statusA) entry.A += Number(map[statusA] || 0);
                            if (statusB) entry.B += Number(map[statusB] || 0);
                        }
                    });
                } else {
                    const key = (article.representedTag || article.title || article.id);
                    if (!groups.has(key)) groups.set(key, new Map());
                    const yearMap = groups.get(key);
                    if (!yearMap.has(year)) yearMap.set(year, { A: 0, B: 0 });
                    const entry = yearMap.get(year);
                    if (statusA) entry.A += Number(map[statusA] || 0);
                    if (statusB) entry.B += Number(map[statusB] || 0);
                }
            });

            // build series per group applying operator
            const series = [];
            groups.forEach((yearMap, key) => {
                const points = [];
                Array.from(yearMap.entries()).sort((a, b) => a[0] - b[0]).forEach(([year, vals]) => {
                    let value = null;
                    const A = vals.A || 0; const B = vals.B || 0;
                    if (statusA && statusB) {
                        switch (op) {
                            case '+': value = A + B; break;
                            case '-': value = A - B; break;
                            case '*': value = A * B; break;
                            case '/': value = B === 0 ? null : A / B; break;
                            default: value = A + B;
                        }
                    } else if (statusA) { value = A; }
                    else if (statusB) { value = B; }
                    if (value !== null) points.push({ year: Number(year), value: Number(value) });
                });
                series.push({ key, points });
            });
            return series;
        };

        const SimpleLineChart = ({ width = 700, height = 260, series = [], formatValue = (v) => String(v) }) => {
            if (!series || series.length === 0) return <div className="bg-white p-6 rounded shadow text-center text-gray-400">データがありません</div>;
            // collect years
            const yearsSet = new Set();
            let maxVal = 0;
            series.forEach(s => s.points.forEach(p => { yearsSet.add(p.year); if (p.value > maxVal) maxVal = p.value; }));
            const years = Array.from(yearsSet).sort((a, b) => a - b);
            if (years.length === 0) return <div className="bg-white p-6 rounded shadow text-center text-gray-400">データ不足</div>;
            const padding = { l: 50, r: 20, t: 20, b: 30 };
            const gw = width - padding.l - padding.r; const gh = height - padding.t - padding.b;
            const getX = (y) => padding.l + (years.indexOf(y) / (years.length - 1 || 1)) * gw;
            const getY = (v) => padding.t + gh - ((v / (maxVal || 1)) * gh);
            const colors = ['#3b82f6', '#ef4444', '#10b981', '#f59e0b', '#8b5cf6', '#06b6d4'];

            // Y-axis ticks (縦軸ラベル)
            const yTicksCount = 5;
            const yTicks = Array.from({ length: yTicksCount }).map((_, i) => {
                // descending values: top -> maxVal
                const val = maxVal * (1 - i / (yTicksCount - 1));
                // round to sensible precision
                if (Math.abs(val) >= 1000) return Math.round(val);
                return Math.round(val * 100) / 100;
            });

            return (
                <svg width={width} height={height} className="bg-white rounded-lg shadow-sm">
                    <rect x="0" y="0" width={width} height={height} fill="transparent" />
                    {/* grid lines + y-axis labels */}
                    {Array.from({ length: yTicksCount }).map((_, i) => {
                        const y = padding.t + (gh / (yTicksCount - 1)) * i;
                        const tickVal = yTicks[i];
                        return (
                            <g key={`yg_${i}`}>
                                <line x1={padding.l} x2={width - padding.r} y1={y} y2={y} stroke="#eee" />
                                <text x={padding.l - 8} y={y + 4} fontSize="10" textAnchor="end" fill="#666">{formatValue(tickVal)}</text>
                            </g>
                        );
                    })}
                    {/* x labels */}
                    {years.map((y, i) => (<text key={y} x={getX(y)} y={height - 6} fontSize="10" textAnchor="middle" fill="#666">{y}</text>))}
                    {/* series paths */}
                    {series.map((s, si) => {
                        const d = s.points.map((p, idx) => `${idx === 0 ? 'M' : 'L'} ${getX(p.year)} ${getY(p.value)}`).join(' ');
                        const color = colors[si % colors.length];
                        return (<g key={s.key}><path d={d} fill="none" stroke={color} strokeWidth={2.5} strokeLinejoin="round" strokeLinecap="round" /><text x={width - padding.r - 6} y={padding.t + 12 + si * 14} fontSize="12" textAnchor="end" fill={color}>{s.key}</text></g>);
                    })}
                </svg>
            );
        };

        // --- SimpleBarChart: 棒グラフ表示用コンポーネント ---
        // 年ごとにグループ化された棒グラフを描画
        const SimpleBarChart = ({ width = 700, height = 260, series = [], formatValue = (v) => String(v) }) => {
            const [hoveredBar, setHoveredBar] = React.useState(null); // ホバー中の棒情報

            if (!series || series.length === 0) return <div className="bg-white p-6 rounded shadow text-center text-gray-400">データがありません</div>;

            // 全年度を収集
            const yearsSet = new Set();
            let maxVal = 0;
            series.forEach(s => s.points.forEach(p => {
                yearsSet.add(p.year);
                if (p.value > maxVal) maxVal = p.value;
            }));
            const years = Array.from(yearsSet).sort((a, b) => a - b);
            if (years.length === 0) return <div className="bg-white p-6 rounded shadow text-center text-gray-400">データ不足</div>;

            const padding = { l: 60, r: 20, t: 30, b: 40 };
            const gw = width - padding.l - padding.r;
            const gh = height - padding.t - padding.b;

            // 年ごとのグループ幅とバー幅を計算
            const seriesCount = series.length;
            const groupWidth = gw / years.length; // 各年のグループ幅
            const barPadding = 4; // バー間のパディング
            const groupPadding = 8; // グループ間のパディング
            const barWidth = Math.max(8, (groupWidth - groupPadding * 2) / seriesCount - barPadding);

            // 座標計算関数
            const getGroupX = (year) => padding.l + years.indexOf(year) * groupWidth;
            const getBarY = (v) => padding.t + gh - ((v / (maxVal || 1)) * gh);
            const getBarHeight = (v) => (v / (maxVal || 1)) * gh;

            // カラーパレット（折れ線グラフと共通）
            const colors = ['#3b82f6', '#ef4444', '#10b981', '#f59e0b', '#8b5cf6', '#06b6d4'];

            // Y軸目盛り（縦軸ラベル）
            const yTicksCount = 5;
            const yTicks = Array.from({ length: yTicksCount }).map((_, i) => {
                const val = maxVal * (1 - i / (yTicksCount - 1));
                if (Math.abs(val) >= 1000) return Math.round(val);
                return Math.round(val * 100) / 100;
            });

            return (
                <svg width={width} height={height} className="bg-white rounded-lg shadow-sm">
                    <rect x="0" y="0" width={width} height={height} fill="transparent" />

                    {/* グリッド線とY軸ラベル */}
                    {Array.from({ length: yTicksCount }).map((_, i) => {
                        const y = padding.t + (gh / (yTicksCount - 1)) * i;
                        const tickVal = yTicks[i];
                        return (
                            <g key={`yg_${i}`}>
                                <line x1={padding.l} x2={width - padding.r} y1={y} y2={y} stroke="#eee" />
                                <text x={padding.l - 8} y={y + 4} fontSize="10" textAnchor="end" fill="#666">{formatValue(tickVal)}</text>
                            </g>
                        );
                    })}

                    {/* X軸（年度ラベル） */}
                    {years.map((year, i) => (
                        <text
                            key={year}
                            x={getGroupX(year) + groupWidth / 2}
                            y={height - 8}
                            fontSize="10"
                            textAnchor="middle"
                            fill="#666"
                        >
                            {year}
                        </text>
                    ))}

                    {/* 棒グラフ本体 */}
                    {series.map((s, si) => {
                        const color = colors[si % colors.length];
                        return (
                            <g key={s.key}>
                                {s.points.map((p, pi) => {
                                    const groupX = getGroupX(p.year);
                                    const barX = groupX + groupPadding + si * (barWidth + barPadding);
                                    const barH = getBarHeight(p.value);
                                    const barY = getBarY(p.value);
                                    const isHovered = hoveredBar && hoveredBar.seriesKey === s.key && hoveredBar.year === p.year;

                                    return (
                                        <rect
                                            key={`${s.key}-${p.year}`}
                                            x={barX}
                                            y={barY}
                                            width={barWidth}
                                            height={barH}
                                            fill={color}
                                            opacity={isHovered ? 1 : 0.85}
                                            rx={2}
                                            ry={2}
                                            style={{ transition: 'opacity 0.15s ease', cursor: 'pointer' }}
                                            onMouseEnter={() => setHoveredBar({ seriesKey: s.key, year: p.year, value: p.value, x: barX + barWidth / 2, y: barY })}
                                            onMouseLeave={() => setHoveredBar(null)}
                                        />
                                    );
                                })}
                            </g>
                        );
                    })}

                    {/* 凡例（右上に表示） */}
                    {series.map((s, si) => {
                        const color = colors[si % colors.length];
                        return (
                            <g key={`legend-${s.key}`}>
                                <rect x={width - padding.r - 80} y={padding.t + si * 18} width={12} height={12} fill={color} rx={2} />
                                <text x={width - padding.r - 64} y={padding.t + 10 + si * 18} fontSize="11" fill="#333">{s.key}</text>
                            </g>
                        );
                    })}

                    {/* ホバー時のツールチップ */}
                    {hoveredBar && (
                        <g>
                            <rect
                                x={hoveredBar.x - 40}
                                y={hoveredBar.y - 30}
                                width={80}
                                height={24}
                                fill="rgba(0,0,0,0.8)"
                                rx={4}
                            />
                            <text
                                x={hoveredBar.x}
                                y={hoveredBar.y - 13}
                                fontSize="11"
                                textAnchor="middle"
                                fill="white"
                            >
                                {hoveredBar.seriesKey}: {formatValue(hoveredBar.value)}
                            </text>
                        </g>
                    )}
                </svg>
            );
        };

        // スプレッドシートからデータを取得する非同期関数
        const fetchSheetDataForArticle = async (article, mappings) => {
            const content = article.contentHtml || '';
            const sheetMatch = content.match(/#googlesheet\(([^)]+)\)/);
            if (!sheetMatch || mappings.length === 0) return {};

            const sheetUrl = sheetMatch[1];
            const sheetIdMatch = sheetUrl.match(/\/d\/([a-zA-Z0-9-_]+)/);
            if (!sheetIdMatch) return {};

            const sheetId = sheetIdMatch[1];
            const proxyUrl = window.worldData?.spreadsheetProxyUrl;
            if (!proxyUrl) return {};

            return new Promise((resolve) => {
                const callbackName = 'sheet_cb_' + Math.random().toString(36).substr(2, 9);
                const timeout = setTimeout(() => {
                    delete window[callbackName];
                    resolve({});
                }, 10000); // 10秒タイムアウト

                window[callbackName] = (res) => {
                    clearTimeout(timeout);
                    delete window[callbackName];
                    const s = document.getElementById(callbackName);
                    if (s) s.remove();

                    if (res.status === 'success' && res.values) {
                        const result = {};
                        mappings.forEach(m => {
                            if (res.values[m.cell] !== undefined) {
                                result[m.field] = res.values[m.cell];
                            }
                        });
                        resolve(result);
                    } else {
                        resolve({});
                    }
                };

                const cells = mappings.map(m => m.cell).join(',');
                const params = new URLSearchParams();
                params.set('callback', callbackName);
                params.set('action', 'getCellValues');
                params.set('sheetId', sheetId);
                params.set('cells', cells);

                const script = document.createElement('script');
                script.id = callbackName;
                script.src = proxyUrl + (proxyUrl.includes('?') ? '&' : '?') + params.toString();
                document.body.appendChild(script);
            });
        };

        const GraphView = ({ setView, articles = [] }) => {
            const [conditionTags, setConditionTags] = React.useState([]); // 条件タグ（複数）
            const [elementTags, setElementTags] = React.useState([]); // 要素タグ（複数選択）
            const [statusA, setStatusA] = React.useState('');
            const [statusB, setStatusB] = React.useState('');
            const [op, setOp] = React.useState('+');
            const [series, setSeries] = React.useState([]);
            const [chartType, setChartType] = React.useState('line'); // グラフタイプ: 'line' or 'bar'
            const [isSyncing, setIsSyncing] = React.useState(false); // 同期処理中のフラグ
            const [enrichedArticles, setEnrichedArticles] = React.useState(articles); // スプレッドシートデータを付加した記事リスト

            // 記事リストが変わったらenrichedArticlesも初期化
            React.useEffect(() => {
                setEnrichedArticles(articles);
            }, [articles]);

            const tags = collectAllTags(enrichedArticles);
            const statuses = collectAllStatusLabels(enrichedArticles);

            const toggleConditionTag = (t) => setConditionTags(prev => prev.includes(t) ? prev.filter(x => x !== t) : [...prev, t]);
            const toggleElementTag = (t) => setElementTags(prev => prev.includes(t) ? prev.filter(x => x !== t) : [...prev, t]);

            const runAggregate = () => {
                if (!statusA && !statusB) { alert('少なくとも1つの統計ステータスを選択してください'); return; }
                const s = aggregateSeriesByGroup(enrichedArticles, conditionTags, elementTags, statusA, statusB, op);
                setSeries(s);
            };

            const syncSpreadsheetData = async () => {
                if (!window.worldData?.spreadsheetProxyUrl) {
                    alert('GAS連携URLが設定されていません。世界設定から設定してください。');
                    return;
                }
                const mappings = window.worldData?.sheetFieldMappings || [];
                if (mappings.length === 0) {
                    alert('スプレッドシート値マッピングが設定されていません。');
                    return;
                }

                setIsSyncing(true);
                try {
                    const targets = articles.filter(a => (a.contentHtml || '').includes('#googlesheet'));
                    if (targets.length === 0) {
                        alert('スプレッドシートを含む記事が見つかりません。');
                        setIsSyncing(false);
                        return;
                    }

                    // 並列実行数を制限しつつ実行（5並列）
                    const results = [];
                    const chunkSize = 5;
                    for (let i = 0; i < targets.length; i += chunkSize) {
                        const chunk = targets.slice(i, i + chunkSize);
                        const chunkResults = await Promise.all(chunk.map(async (article) => {
                            const data = await fetchSheetDataForArticle(article, mappings);
                            return { id: article.id, sheetData: data };
                        }));
                        results.push(...chunkResults);
                    }

                    // 取得データを記事にマージ
                    const newArticles = articles.map(a => {
                        const fetched = results.find(r => r.id === a.id);
                        if (fetched && Object.keys(fetched.sheetData).length > 0) {
                            return { ...a, fetchedSheetData: fetched.sheetData };
                        }
                        return a;
                    });

                    setEnrichedArticles(newArticles);
                    alert(`同期完了: ${results.filter(r => Object.keys(r.sheetData).length > 0).length} 件の記事からデータを取得しました。`);
                } catch (e) {
                    console.error(e);
                    alert('同期中にエラーが発生しました');
                } finally {
                    setIsSyncing(false);
                }
            };

            return (
                <div className="space-y-6 p-6 animate-[fadeIn_0.2s_ease-out]">
                    <div className="flex items-center gap-4"><button onClick={() => setView('timeline_large')} className="flex items-center gap-2 px-3 py-2 bg-white text-gray-700 rounded border"><Icon name="arrow-left" size={16} /> 年表へ戻る</button><h2 className="text-xl font-bold">統計ビュー</h2></div>

                    <div className="bg-white p-4 rounded shadow grid grid-cols-3 gap-4">
                        <div className="col-span-3">
                            <div className="text-sm font-bold mb-2">条件タグ（これらのタグを持つ記事が集計対象になります。複数選択可）</div>
                            <div className="flex flex-wrap gap-2">{tags.map(t => (<button key={t} onClick={() => toggleConditionTag(t)} className={`px-2 py-1 text-sm rounded ${conditionTags.includes(t) ? 'bg-indigo-600 text-white' : 'bg-gray-100 text-gray-700'}`}>#{t}</button>))}</div>
                        </div>
                        <div className="col-span-3">
                            <div className="text-sm font-bold mb-2">要素タグ（これらを同一要素として扱い比較します。複数選択可）</div>
                            <div className="flex flex-wrap gap-2">{tags.map(t => (<button key={t} onClick={() => toggleElementTag(t)} className={`px-2 py-1 text-sm rounded ${elementTags.includes(t) ? 'bg-emerald-600 text-white' : 'bg-gray-100 text-gray-700'}`}>#{t}</button>))}</div>
                        </div>
                        <div>
                            <div className="text-sm font-bold mb-2">統計ステータス A</div>
                            <select className="w-full border p-2 rounded" value={statusA} onChange={e => setStatusA(e.target.value)}>
                                <option value="">-- 選択しない --</option>
                                {statuses.map(s => <option key={s} value={s}>{s}</option>)}
                            </select>
                        </div>
                        <div>
                            <div className="text-sm font-bold mb-2">統計ステータス B</div>
                            <select className="w-full border p-2 rounded" value={statusB} onChange={e => setStatusB(e.target.value)}>
                                <option value="">-- 選択しない --</option>
                                {statuses.map(s => <option key={s} value={s}>{s}</option>)}
                            </select>
                        </div>
                        <div>
                            <div className="text-sm font-bold mb-2">演算子 (A op B)</div>
                            <select className="w-full border p-2 rounded" value={op} onChange={e => setOp(e.target.value)}>
                                <option value="+">+</option>
                                <option value="-">-</option>
                                <option value="*">×</option>
                                <option value="/">÷</option>
                            </select>
                        </div>

                        <div className="col-span-3 flex justify-end">
                            <button
                                onClick={syncSpreadsheetData}
                                disabled={isSyncing}
                                className={`flex items-center gap-2 px-3 py-1.5 text-xs rounded border transition ${isSyncing ? 'bg-gray-100 text-gray-400' : 'bg-green-50 text-green-700 hover:bg-green-100 border-green-200'}`}
                            >
                                {isSyncing ? <div className="animate-spin h-3 w-3 border-2 border-green-500 rounded-full border-t-transparent"></div> : <Icon name="refresh-cw" size={12} />}
                                {isSyncing ? 'データ同期中...' : 'スプレッドシートデータ同期'}
                            </button>
                        </div>
                    </div>

                    <div className="flex gap-2 items-center flex-wrap">
                        <button onClick={runAggregate} className="px-4 py-2 bg-indigo-600 text-white rounded font-bold">グラフ生成</button>
                        <button onClick={() => { setConditionTags([]); setElementTags([]); setStatusA(''); setStatusB(''); setOp('+'); setSeries([]); }} className="px-4 py-2 border rounded">リセット</button>

                        {/* グラフタイプ切り替えボタン */}
                        <div className="flex bg-gray-100 rounded p-1 ml-4">
                            <button
                                onClick={() => setChartType('line')}
                                className={`flex items-center gap-1 px-3 py-1 text-sm rounded transition ${chartType === 'line' ? 'bg-white text-indigo-600 font-bold shadow-sm' : 'text-gray-600 hover:text-gray-800'}`}
                            >
                                <Icon name="trending-up" size={14} /> 折れ線
                            </button>
                            <button
                                onClick={() => setChartType('bar')}
                                className={`flex items-center gap-1 px-3 py-1 text-sm rounded transition ${chartType === 'bar' ? 'bg-white text-indigo-600 font-bold shadow-sm' : 'text-gray-600 hover:text-gray-800'}`}
                            >
                                <Icon name="bar-chart-2" size={14} /> 棒グラフ
                            </button>
                        </div>
                    </div>

                    <div>
                        {/* 選択されたグラフタイプに応じてコンポーネントを切り替え */}
                        {chartType === 'line' ? (
                            <SimpleLineChart series={series} />
                        ) : (
                            <SimpleBarChart series={series} />
                        )}
                        {series.length === 0 && <div className="text-sm text-gray-500 mt-2">記事の時間を X 軸（記事の年代）として、選択した統計ステータスを記事単位で集計します。記事内のテーブルや `stats` のラベルをステータス名として扱います。</div>}
                    </div>
                </div>
            );
        };

        // --- WikiSidebar Component ---
        const WikiSidebar = ({ articles, onNavigate, selectedArticleId }) => {
            const [filterText, setFilterText] = React.useState('');
            const [expandedFolders, setExpandedFolders] = React.useState({});

            // フォルダ構造の構築
            const folderTree = React.useMemo(() => {
                const tree = { name: 'root', children: {}, articles: [] };

                // フィルタリング
                const targetArticles = filterText
                    ? articles.filter(a => (a.title && a.title.toLowerCase().includes(filterText.toLowerCase())))
                    : articles;

                targetArticles.forEach(article => {
                    if (!article.folder) {
                        tree.articles.push(article);
                    } else {
                        const parts = article.folder.split('/').filter(p => p);
                        let current = tree;
                        parts.forEach(part => {
                            if (!current.children[part]) {
                                current.children[part] = { name: part, children: {}, articles: [] };
                            }
                            current = current.children[part];
                        });
                        current.articles.push(article);
                    }
                });

                // 並び替え (フォルダ名順 -> 記事タイトル順)
                const sortTree = (node) => {
                    // childrenをオブジェクトから配列へ変換してソート
                    const sortedChildren = Object.values(node.children).sort((a, b) => a.name.localeCompare(b.name));
                    sortedChildren.forEach(sortTree);
                    node.sortedChildren = sortedChildren;
                    node.articles.sort((a, b) => (a.title || '').localeCompare(b.title || ''));
                };
                sortTree(tree);
                return tree;
            }, [articles, filterText]);

            // 初期展開: 選択中の記事があるフォルダを開く
            React.useEffect(() => {
                if (selectedArticleId && articles.length > 0) {
                    const article = articles.find(a => a.id === selectedArticleId);
                    if (article && article.folder) {
                        const parts = article.folder.split('/').filter(p => p);
                        setExpandedFolders(prev => {
                            const next = { ...prev };
                            let path = '';
                            parts.forEach(part => {
                                path = path ? `${path}/${part}` : part;
                                next[path] = true;
                            });
                            return next;
                        });
                    }
                }
            }, [selectedArticleId, articles]);

            const toggleFolder = (path) => {
                setExpandedFolders(prev => ({ ...prev, [path]: !prev[path] }));
            };

            const renderNode = (node, path = '') => {
                return (
                    <div key={path || 'root'} className="pl-2">
                        {node.sortedChildren.map(child => {
                            const childPath = path ? `${path}/${child.name}` : child.name;
                            const isExpanded = expandedFolders[childPath] || filterText; // 検索時は全開
                            return (
                                <div key={childPath}>
                                    <div
                                        className="flex items-center gap-1 py-1 px-2 hover:bg-gray-100 cursor-pointer text-sm text-gray-700 font-medium rounded select-none"
                                        onClick={() => toggleFolder(childPath)}
                                    >
                                        <Icon name={isExpanded ? "folder-open" : "folder"} size={14} className="text-yellow-500" />
                                        <span className="truncate">{child.name}</span>
                                    </div>
                                    {isExpanded && (
                                        <div className="border-l border-gray-200 ml-2">
                                            {renderNode(child, childPath)}
                                        </div>
                                    )}
                                </div>
                            );
                        })}
                        {node.articles.map(article => (
                            <div
                                key={article.id}
                                onClick={() => onNavigate(article)}
                                className={`flex items-center gap-2 py-1 px-2 text-sm cursor-pointer rounded ml-1 ${selectedArticleId === article.id ? 'bg-indigo-50 text-indigo-700 font-bold' : 'text-gray-600 hover:bg-gray-50 hover:text-gray-900'}`}
                            >
                                <Icon name="file-text" size={12} className={selectedArticleId === article.id ? 'text-indigo-500' : 'text-gray-400'} />
                                <span className="truncate">{article.title}</span>
                            </div>
                        ))}
                    </div>
                );
            };

            return (
                <div className="flex flex-col h-full bg-gray-50 border-r w-64 shrink-0">
                    <div className="p-3 border-b bg-white">
                        <div className="relative">
                            <Icon name="search" size={14} className="absolute left-2.5 top-2.5 text-gray-400" />
                            <input
                                className="w-full pl-8 pr-2 py-1.5 text-sm border rounded bg-gray-50 focus:bg-white focus:outline-none focus:ring-2 focus:ring-indigo-500 transition-colors"
                                placeholder="記事を検索..."
                                value={filterText}
                                onChange={e => setFilterText(e.target.value)}
                            />
                        </div>
                    </div>
                    <div className="flex-1 overflow-y-auto p-2 custom-scrollbar">
                        {renderNode(folderTree)}
                        {folderTree.articles.length === 0 && folderTree.sortedChildren.length === 0 && (
                            <div className="text-center text-xs text-gray-400 py-4">
                                記事が見つかりません
                            </div>
                        )}
                    </div>
                </div>
            );
        };

        // --- WikiReadView Component ---
        const WikiReadView = ({ article, articles, onNavigate, onBack, onForward, canGoBack, canGoForward, history, historyIndex, onHistoryJump, onClearHistory }) => {
            const [showHistoryDropdown, setShowHistoryDropdown] = React.useState(false);

            // 関連記事を取得（同じフォルダまたは同じタグ）
            const relatedArticles = React.useMemo(() => {
                if (!article) return [];
                const related = articles.filter(a => {
                    if (a.id === article.id) return false;
                    if (a.folder === article.folder) return true;
                    if (article.tags && a.tags) {
                        return article.tags.some(tag => a.tags.includes(tag));
                    }
                    return false;
                }).slice(0, 10);
                return related;
            }, [article, articles]);

            if (!article) {
                return (
                    <div className="flex h-full bg-white overflow-hidden">
                        {/* サイドバー */}
                        <div className="hidden md:block h-full border-r relative z-10 w-64 shrink-0 shadow-sm">
                            <WikiSidebar
                                articles={articles}
                                onNavigate={onNavigate}
                                selectedArticleId={null}
                            />
                        </div>
                        <div className="flex-1 flex items-center justify-center h-full">
                            <div className="text-center text-gray-400">
                                <Icon name="book-open" size={64} className="mx-auto mb-4 opacity-30" />
                                <p className="text-lg">記事を選択してください</p>
                                <p className="text-sm mt-2">サイドバーから記事を選択するか、検索してください</p>
                            </div>
                        </div>
                    </div>
                );
            }

            return (
                <div className="flex h-full bg-white overflow-hidden">
                    {/* サイドバー */}
                    <div className="hidden md:block h-full border-r relative z-10 w-64 shrink-0 shadow-sm">
                        <WikiSidebar
                            articles={articles}
                            onNavigate={onNavigate}
                            selectedArticleId={article?.id}
                        />
                    </div>

                    {/* メインコンテンツエリア */}
                    <div className="flex-1 flex flex-col h-full min-w-0">
                        {/* ナビゲーションバー */}
                        <div className="border-b px-4 py-3 bg-gray-50 flex items-center gap-3 flex-wrap shrink-0">
                            {/* 戻る/進むボタン */}
                            <div className="flex gap-1">
                                <button
                                    onClick={onBack}
                                    disabled={!canGoBack}
                                    className={`p-2 rounded transition ${canGoBack ? 'hover:bg-gray-200 text-gray-700' : 'text-gray-300 cursor-not-allowed'}`}
                                    title="戻る"
                                >
                                    <Icon name="chevron-left" size={18} />
                                </button>
                                <button
                                    onClick={onForward}
                                    disabled={!canGoForward}
                                    className={`p-2 rounded transition ${canGoForward ? 'hover:bg-gray-200 text-gray-700' : 'text-gray-300 cursor-not-allowed'}`}
                                    title="進む"
                                >
                                    <Icon name="chevron-right" size={18} />
                                </button>
                            </div>

                            {/* 履歴ドロップダウン */}
                            <div className="relative">
                                <button
                                    onClick={() => setShowHistoryDropdown(!showHistoryDropdown)}
                                    className="flex items-center gap-1 px-3 py-1.5 rounded hover:bg-gray-200 text-sm text-gray-700"
                                    title="閲覧履歴"
                                >
                                    <Icon name="clock" size={16} />
                                    <span>履歴</span>
                                    <Icon name="chevron-down" size={14} />
                                </button>

                                {showHistoryDropdown && (
                                    <>
                                        <div className="fixed inset-0 z-10" onClick={() => setShowHistoryDropdown(false)} />
                                        <div className="absolute top-full left-0 mt-1 bg-white border rounded-lg shadow-lg z-20 w-80 max-h-96 overflow-y-auto">
                                            {history.length === 0 ? (
                                                <div className="p-4 text-sm text-gray-400 text-center">履歴はありません</div>
                                            ) : (
                                                <>
                                                    <div className="p-2 border-b flex justify-between items-center bg-gray-50">
                                                        <span className="text-xs font-bold text-gray-600">閲覧履歴 ({history.length}件)</span>
                                                        <button
                                                            onClick={() => {
                                                                if (confirm('履歴をクリアしますか？')) {
                                                                    onClearHistory();
                                                                    setShowHistoryDropdown(false);
                                                                }
                                                            }}
                                                            className="text-xs text-red-500 hover:text-red-700"
                                                        >
                                                            クリア
                                                        </button>
                                                    </div>
                                                    {history.map((entry, idx) => (
                                                        <button
                                                            key={idx}
                                                            onClick={() => {
                                                                onHistoryJump(idx);
                                                                setShowHistoryDropdown(false);
                                                            }}
                                                            className={`w-full text-left px-3 py-2 hover:bg-gray-50 border-b last:border-b-0 ${idx === historyIndex ? 'bg-indigo-50 font-bold' : ''}`}
                                                        >
                                                            <div className="text-sm truncate">{entry.articleTitle}</div>
                                                            <div className="text-xs text-gray-400 mt-0.5">
                                                                {new Date(entry.timestamp).toLocaleString('ja-JP', { month: 'short', day: 'numeric', hour: '2-digit', minute: '2-digit' })}
                                                            </div>
                                                        </button>
                                                    ))}
                                                </>
                                            )}
                                        </div>
                                    </>
                                )}
                            </div>

                            {/* パンくずリスト */}
                            <div className="flex items-center gap-2 text-sm text-gray-600 flex-1 min-w-0">
                                <Icon name="home" size={14} />
                                <span>/</span>
                                {article.folder && (
                                    <>
                                        <span className="truncate">{article.folder}</span>
                                        <span>/</span>
                                    </>
                                )}
                                <span className="font-bold text-gray-800 truncate">{article.title}</span>
                            </div>
                        </div>

                        {/* 記事コンテンツ */}
                        <div className="flex-1 overflow-y-auto custom-scrollbar">
                            <div className="max-w-4xl mx-auto p-6 bg-white shadow-sm min-h-[50vh] rounded-lg">
                                <h1 className="text-3xl font-serif text-gray-900 border-b pb-4 mb-6 leading-tight">
                                    {article.title}
                                    {article.isApproved && <span className="ml-2 align-middle"><Icon name="check-circle" size={20} className="text-emerald-500 inline" title="承認済み" /></span>}
                                </h1>

                                {/* 記事メタデータ */}
                                <div className="flex flex-wrap gap-4 text-sm text-gray-500 mb-8 p-3 bg-gray-50 rounded border border-gray-100">
                                    {article.dateStr && (
                                        <div className="flex items-center gap-1">
                                            <Icon name="calendar" size={14} />
                                            <span>{article.dateStr}</span>
                                        </div>
                                    )}
                                    {article.locations && article.locations.length > 0 && (
                                        <div className="flex items-center gap-1">
                                            <Icon name="map-pin" size={14} />
                                            <span>{article.locations.join(', ')}</span>
                                        </div>
                                    )}
                                    {article.tags && article.tags.length > 0 && (
                                        <div className="flex items-center gap-1">
                                            <Icon name="tag" size={14} />
                                            <span>{article.tags.join(', ')}</span>
                                        </div>
                                    )}
                                </div>

                                <div
                                    className="prose prose-lg max-w-none text-gray-800 leading-relaxed"
                                    dangerouslySetInnerHTML={{ __html: transformContent(article.contentHtml || '') }}
                                />
                            </div>
                        </div>

                        {/* 関連記事 */}
                        {relatedArticles.length > 0 && (
                            <div className="border-t px-6 py-4 bg-gray-50">
                                <div className="max-w-4xl mx-auto">
                                    <h3 className="text-sm font-bold text-gray-600 mb-3 flex items-center gap-2">
                                        <Icon name="link" size={16} />
                                        関連記事
                                    </h3>
                                    <div className="flex flex-wrap gap-2">
                                        {relatedArticles.map(a => (
                                            <button
                                                key={a.id}
                                                onClick={() => onNavigate(a)}
                                                className="px-3 py-1.5 bg-white border rounded-lg hover:bg-indigo-50 hover:border-indigo-300 transition text-sm flex items-center gap-2"
                                            >
                                                <span className={`w-2 h-2 rounded-full ${ARTICLE_TYPES[a.type]?.color || 'bg-gray-300'}`} />
                                                <span className="truncate max-w-xs">{a.title}</span>
                                            </button>
                                        ))}
                                    </div>
                                </div>
                            </div>
                        )}
                    </div>
                </div>
            );
        };

        // --- AdjacentArticlePreview (Not used but kept for compatibility) ---
        const AdjacentArticlePreview = () => null;

        // --- ArticleDetailPanel (Not used in new integrated view but kept for compatibility) ---
        const ArticleDetailPanel = () => null;

        const JoinRequestModal = ({ onClose, onSubmit, currentStatus }) => {
            const [msg, setMsg] = React.useState('');
            return (
                <div className="fixed inset-0 bg-black/50 flex items-center justify-center z-[9999] p-4">
                    <div className="bg-white p-6 rounded-lg shadow-xl w-full max-w-md">
                        <h3 className="text-lg font-bold mb-4">参加申請</h3>
                        {currentStatus === 'pending' ? (
                            <div className="text-center py-4">
                                <p className="text-gray-700 mb-4">現在、申請の承認待ちです。<br />管理者の承認をお待ちください。</p>
                                <button onClick={onClose} className="px-4 py-2 bg-gray-200 rounded">閉じる</button>
                            </div>
                        ) : (
                            <>
                                <p className="text-sm text-gray-600 mb-2">管理者へメッセージ（任意）:</p>
                                <textarea className="w-full border p-2 rounded mb-4 text-sm" rows={3} value={msg} onChange={e => setMsg(e.target.value)} placeholder="自己紹介や参加の意気込みなど" />
                                <div className="flex justify-end gap-2">
                                    <button onClick={onClose} className="px-4 py-2 bg-gray-200 rounded">キャンセル</button>
                                    <button onClick={() => onSubmit(msg)} className="px-4 py-2 bg-indigo-600 text-white rounded font-bold">申請を送る</button>
                                </div>
                            </>
                        )}
                    </div>
                </div>
            );
        };

        const App = () => {
            const { db, auth, storage, user, loading, error, activeConfig, appContextId } = useFirebase();
            const [viewMode, setViewMode] = React.useState('world_select');
            const [worldId, setWorldId] = React.useState(null);
            const [worldData, setWorldData] = React.useState(null);
            const [articles, setArticles] = React.useState([]);
            const [selectedArticle, setSelectedArticle] = React.useState(null);
            const [formData, setFormData] = React.useState(createEmptyArticle());
            const [mapTabQuery, setMapTabQuery] = React.useState('');
            const [stats, setStats] = React.useState([]);
            const [tagInput, setTagInput] = React.useState('');
            const [mapTabImportance, setMapTabImportance] = React.useState(0);
            const [authMode, setAuthMode] = React.useState('login');
            const [authForm, setAuthForm] = React.useState({ username: '', password: '', worldName: '', worldDesc: '' });
            const [showConfigEditor, setShowConfigEditor] = React.useState(false);
            const [showMemberManager, setShowMemberManager] = React.useState(false);
            const [showAdminPanel, setShowAdminPanel] = React.useState(false);
            const [showRegionRuleEditor, setShowRegionRuleEditor] = React.useState(false);
            const [showAuthModal, setShowAuthModal] = React.useState(false);
            const [showJoinRequestModal, setShowJoinRequestModal] = React.useState(false);
            const [myMemberData, setMyMemberData] = React.useState(null);
            const [members, setMembers] = React.useState([]);
            const [authError, setAuthError] = React.useState(null);
            const [timelineFilters, setTimelineFilters] = React.useState({ type: 'all', keyword: '', tag: '', excludeNoYear: true, onlyApproved: false });

            const [tagArticleInput, setTagArticleInput] = React.useState('');
            const [uiScale, setUiScale] = React.useState(100); // UI拡大率 (%)
            const [previousViewMode, setPreviousViewMode] = React.useState('timeline_large'); // 編集前のビューモードを記憶
            const [navBackView, setNavBackView] = React.useState('timeline_large'); // 記事詳細から戻る際のビューモード
            const isRestoringFromURL = React.useRef(false);
            const hasCheckedWorldURL = React.useRef(false); // URL復元中のフラグ

            // Wiki閲覧履歴管理
            const [wikiHistory, setWikiHistory] = React.useState([]);
            const [wikiHistoryIndex, setWikiHistoryIndex] = React.useState(-1);

            // Browser History & URL Sync
            React.useEffect(() => {
                const handlePopState = (event) => {
                    const state = event.state;
                    if (state) {
                        console.log('PopState:', state);
                        isRestoringFromURL.current = true;
                        if (state.viewMode) setViewMode(state.viewMode);
                        if (state.articleId) {
                            const target = articles.find(a => a.id === state.articleId);
                            if (target) setSelectedArticle(target);
                        } else {
                            setSelectedArticle(null);
                        }
                    }
                };
                window.addEventListener('popstate', handlePopState);
                return () => window.removeEventListener('popstate', handlePopState);
            }, [articles]);

            React.useEffect(() => {
                if (isRestoringFromURL.current) {
                    isRestoringFromURL.current = false;
                    return;
                }
                const params = new URLSearchParams(window.location.search);
                if (viewMode) params.set('view', viewMode);
                if (selectedArticle?.id) params.set('articleId', selectedArticle.id);
                else params.delete('articleId');

                const newUrl = window.location.pathname + '?' + params.toString();
                if (window.location.search !== '?' + params.toString()) {
                    window.history.pushState({ viewMode, articleId: selectedArticle?.id }, '', newUrl);
                }
            }, [viewMode, selectedArticle]);

            // Wiki View Initialization (Add current article to history if empty)
            React.useEffect(() => {
                if (viewMode === 'wiki' && selectedArticle && wikiHistory.length === 0) {
                    addToWikiHistory(selectedArticle, 'timeline_large');
                }
            }, [viewMode, selectedArticle, wikiHistory.length]);

            // Expose setViewMode to window for deep component access (hacky but effective for current structure)
            // Expose setViewMode to window for deep component access (hacky but effective for current structure)
            // Update navBackView when switching to single_article from a different view
            React.useEffect(() => {
                window.setAppViewMode = (mode) => {
                    if (mode === 'single_article' && viewMode !== 'single_article') {
                        setNavBackView(viewMode);
                    }
                    setViewMode(mode);
                };
                return () => delete window.setAppViewMode;
            }, [viewMode]);

            const isFixedView = ['timeline_large', 'list', 'map'].includes(viewMode);
            const scaleStyle = {
                transform: `scale(${uiScale / 100})`,
                transformOrigin: 'top left',
                width: `${100 * 100 / uiScale}%`,
                height: isFixedView ? `${100 * 100 / uiScale}%` : 'auto',
                minHeight: isFixedView ? '0' : `${100 * 100 / uiScale}%`
            };

            // これにより、エディタの参照を保持
            const editorRef = React.useRef(null);
            const htmlTextareaRef = React.useRef(null);

            React.useEffect(() => {
                if (!user || !db || hasCheckedWorldURL.current) return;
                const params = new URLSearchParams(window.location.search);
                const urlWorldId = params.get('world');
                if (urlWorldId) {
                    hasCheckedWorldURL.current = true;
                    isRestoringFromURL.current = true;
                    setWorldId(urlWorldId);
                    setViewMode('timeline_large');
                    console.log('URL復元: 世界選択', urlWorldId);
                } else {
                    hasCheckedWorldURL.current = true;
                }
            }, [user, db]);

            // URLから状態を復元（初回読み込み時）
            React.useEffect(() => {
                if (!user || !worldId || articles.length === 0 || isRestoringFromURL.current) return;

                const params = new URLSearchParams(window.location.search);
                const urlView = params.get('view');
                const urlArticleId = params.get('article');
                const urlKeyword = params.get('keyword');
                const urlTag = params.get('tag');
                const urlMapQuery = params.get('mapQuery');
                const urlMapImportance = params.get('mapImportance');

                let updated = false;

                if (urlArticleId) {
                    // 記事IDが指定されている場合、その記事を表示
                    const article = articles.find(a => a.id === urlArticleId);
                    if (article) {
                        isRestoringFromURL.current = true;
                        setSelectedArticle(article);
                        if (urlView) setViewMode(urlView);
                        else setViewMode('single_article');
                        console.log('URL復元: 記事表示', article.title, urlView);
                    }
                } else if (urlView && urlView !== viewMode) {
                    // ビューモードのみ指定されている場合
                    isRestoringFromURL.current = true;
                    setViewMode(urlView);
                    console.log('URL復元: ビューモード', urlView);
                }

                if (urlKeyword || urlTag) {
                    setTimelineFilters(prev => ({ ...prev, keyword: urlKeyword || '', tag: urlTag || '' }));
                    console.log('URL復元: 検索条件', { keyword: urlKeyword, tag: urlTag });
                    updated = true;
                }

                // 年代なしフィルタ状態を復元
                if (params.has('excludeNoYear')) {
                    const excludeNoYear = params.get('excludeNoYear') === 'true';
                    setTimelineFilters(prev => ({ ...prev, excludeNoYear }));
                    console.log('URL復元: 年代なしフィルタ', excludeNoYear);
                    updated = true;
                }

                if (urlMapQuery) {
                    setMapTabQuery(urlMapQuery);
                    console.log('URL復元: マップクエリ', urlMapQuery);
                    updated = true;
                }

                if (urlMapImportance) {
                    setMapTabImportance(Number(urlMapImportance));
                    console.log('URL復元: マップ重要度', urlMapImportance);
                    updated = true;
                }

                if (updated) {
                    isRestoringFromURL.current = true;
                }
            }, [user, worldId, articles]);

            // 状態が変更されたらURLを更新（ブラウザの履歴に追加）
            React.useEffect(() => {
                if (!worldId || !user || isRestoringFromURL.current) {
                    isRestoringFromURL.current = false;
                    return;
                }

                const timeoutId = setTimeout(() => {
                    const params = new URLSearchParams();
                    if (worldId) params.set('world', worldId);
                    params.set('view', viewMode);

                    if (selectedArticle) {
                        params.set('article', selectedArticle.id);
                    }

                    if (timelineFilters.keyword) {
                        params.set('keyword', timelineFilters.keyword);
                    }
                    if (timelineFilters.tag) {
                        params.set('tag', timelineFilters.tag);
                    }

                    // 年代なしフィルタ状態もURLに含める
                    // 年代なしフィルタ状態もURLに含める (デフォルトtrueの場合は省略)
                    if (timelineFilters.excludeNoYear === false) {
                        params.set('excludeNoYear', 'false');
                    }

                    if (viewMode === 'map' && mapTabQuery) {
                        params.set('mapQuery', mapTabQuery);
                    }
                    if (viewMode === 'map' && mapTabImportance > 0) {
                        params.set('mapImportance', mapTabImportance.toString());
                    }

                    const newUrl = `${window.location.pathname}?${params.toString()}`;
                    const currentUrl = `${window.location.pathname}${window.location.search}`;

                    if (newUrl !== currentUrl) {
                        window.history.pushState({ viewMode, worldId, articleId: selectedArticle?.id }, '', newUrl);
                        console.log('URL更新:', newUrl);
                    }
                }, 1000);

                return () => clearTimeout(timeoutId);
            }, [viewMode, selectedArticle, worldId, user]);

            // ブラウザの戻る/進むボタンに対応
            React.useEffect(() => {
                const handlePopState = (event) => {
                    if (event.state) {
                        console.log('履歴から復元:', event.state);
                        isRestoringFromURL.current = true;

                        if (event.state.viewMode) {
                            setViewMode(event.state.viewMode);
                        }

                        if (event.state.articleId && articles.length > 0) {
                            const article = articles.find(a => a.id === event.state.articleId);
                            if (article) {
                                setSelectedArticle(article);
                            }
                        } else if (!event.state.articleId) {
                            setSelectedArticle(null);
                        }
                    }
                };

                window.addEventListener('popstate', handlePopState);
                return () => window.removeEventListener('popstate', handlePopState);
            }, [articles]);

            React.useEffect(() => {
                if (!db || !worldId || !appContextId) return;
                const { onSnapshot, doc, collection } = window.firebaseModules;
                const unsubWorld = onSnapshot(doc(db, 'artifacts', appContextId, 'public', 'data', 'worlds', worldId), s => setWorldData(s.data()));
                const unsubArticles = onSnapshot(collection(db, 'artifacts', appContextId, 'public', 'data', 'worlds', worldId, 'articles'), s => {
                    setArticles(s.docs.map(d => ({ ...d.data(), id: d.id })).sort((a, b) => getArticleYear(a) - getArticleYear(b)));
                });
                const unsubMembers = onSnapshot(collection(db, 'artifacts', appContextId, 'public', 'data', 'worlds', worldId, 'members'), s => {
                    setMembers(s.docs.map(d => ({ ...d.data(), id: d.id })));
                });
                return () => { unsubWorld(); unsubArticles(); unsubMembers(); };
            }, [db, worldId, appContextId]);

            React.useEffect(() => {
                if (!db || !worldId || !user || !appContextId) return;
                const { onSnapshot, doc, updateDoc } = window.firebaseModules;
                return onSnapshot(doc(db, 'artifacts', appContextId, 'public', 'data', 'worlds', worldId, 'members', user.uid), async s => {
                    if (s.exists()) {
                        const data = s.data();
                        setMyMemberData(data);
                        // 名前が未登録または変更されている場合は更新 (自分の情報のみ)
                        if (user.displayName && data.username !== user.displayName) {
                            try {
                                await updateDoc(doc(db, 'artifacts', appContextId, 'public', 'data', 'worlds', worldId, 'members', user.uid), {
                                    username: user.displayName
                                });
                            } catch (e) { console.error("Name sync failed", e); }
                        }
                    }
                    else setMyMemberData(null);
                });
            }, [db, worldId, user, appContextId]);

            const myRole = myMemberData?.role || 'guest';
            const canIApprove = myRole === 'owner' || myRole === 'admin' || myMemberData?.canApprove === true;
            const isEditor = ['owner', 'admin', 'editor'].includes(myRole);

            const articleIndex = React.useMemo(() => { const map = new Map(); articles.forEach(a => map.set(a.id, a)); return map; }, [articles]);
            // previewArticles: merge current formData into articles for instant preview in edit mode
            const previewArticles = React.useMemo(() => {
                try {
                    if (!formData) return articles;
                    const merged = articles.map(a => (formData.id && a.id === formData.id ? { ...a, ...formData } : a));
                    if (!formData.id) {
                        // append draft preview for new article
                        const draft = { ...(formData || {}), id: '__draft__' };
                        merged.push(draft);
                    }
                    return merged;
                } catch (e) { return articles; }
            }, [articles, formData]);
            const filteredTimelineArticles = React.useMemo(() => filterTimelineArticles(articles, timelineFilters), [articles, timelineFilters]);
            const timelineSummary = React.useMemo(() => {
                const summary = [];
                if (timelineFilters.keyword) summary.push(`KW:${timelineFilters.keyword}`);
                if (timelineFilters.tag) summary.push(`#${timelineFilters.tag}`);
                if (timelineFilters.type && timelineFilters.type !== 'all') summary.push(ARTICLE_TYPES[timelineFilters.type]?.label || timelineFilters.type);
                return summary.join(' / ') || '全記事';
            }, [timelineFilters]);

            // Remove localStorage region rules hooks
            const regionRules = worldData?.regionRules || REGION_TAG_RULES_DEFAULT;

            const handleConfigSave = (newConfig, newAppId) => {
                localStorage.setItem('worldweaver_firebase_config', JSON.stringify(newConfig));
                localStorage.setItem('worldweaver_app_id', newAppId);
                setShowConfigEditor(false);
                window.location.reload();
            };

            const handleAuth = async () => {
                setAuthError(null);
                const { signInWithEmailAndPassword, createUserWithEmailAndPassword, updateProfile } = window.firebaseModules;
                const email = `${authForm.username}@worldweaver.local`;
                try {
                    if (authMode === 'login') await signInWithEmailAndPassword(auth, email, authForm.password);
                    else {
                        const cred = await createUserWithEmailAndPassword(auth, email, authForm.password);
                        await updateProfile(cred.user, { displayName: authForm.username });
                    }
                    setShowAuthModal(false);
                    // No need to reset viewMode to world_select if we want to stay in current context
                } catch (e) { setAuthError(e.message); }
            };

            const handleCreateWorld = async () => {
                if (!authForm.worldName) return alert("名前を入力してください");
                const { addDoc, collection, doc, setDoc, serverTimestamp } = window.firebaseModules;
                try {
                    const ref = await addDoc(collection(db, 'artifacts', appContextId, 'public', 'data', 'worlds'), {
                        name: authForm.worldName, description: authForm.worldDesc, ownerId: user.uid, createdAt: serverTimestamp()
                    });
                    await setDoc(doc(db, 'artifacts', appContextId, 'public', 'data', 'worlds', ref.id, 'members', user.uid), {
                        username: user.displayName, role: 'owner', joinedAt: serverTimestamp()
                    });
                    setWorldId(ref.id); setViewMode('timeline_large');
                } catch (e) { alert(e.message); }
            };

            const handleSaveArticle = async () => {
                if (!formData.title) return alert("タイトルを入力してください");
                const { addDoc, collection, doc, updateDoc, serverTimestamp } = window.firebaseModules;
                const tagsFromInput = tagInput.split(',').map(t => t.trim()).filter(t => t);
                const locationCandidates = [];
                if (Array.isArray(formData.locations)) {
                    formData.locations.forEach(l => {
                        const lat = Number(l.lat);
                        const lng = Number(l.lng);
                        if (Number.isFinite(lat) && Number.isFinite(lng)) locationCandidates.push({ lat, lng });
                    });
                }
                if (formData.lat !== undefined && formData.lng !== undefined && formData.lat !== '' && formData.lng !== '') {
                    const lat = Number(formData.lat);
                    const lng = Number(formData.lng);
                    if (Number.isFinite(lat) && Number.isFinite(lng)) locationCandidates.push({ lat, lng });
                }
                const regionTags = computeRegionTags(locationCandidates, regionRules);
                const tags = Array.from(new Set([...tagsFromInput, ...regionTags]));
                // 年代の計算
                let yearVal = parseInt(formData.year) || 0;
                if (!formData.noYear) {
                    if (formData.dateStr) {
                        const m = formData.dateStr.match(/^(\-?\d+)/);
                        if (m) yearVal = parseInt(m[1], 10);
                    } else if (formData.period?.start) {
                        const m = formData.period.start.match(/^(\-?\d+)/);
                        if (m) yearVal = parseInt(m[1], 10);
                    }
                } else {
                    yearVal = 0;
                }

                // Approval Status Logic
                let isApproved = !!formData.isApproved;
                // If not authorized to approve, keep it as is if existing, or false if new (unless default changes)
                // However, if unauthorized user edits an approved article, does it stay approved?
                // For now, adhere to formData state but verify permission if changing to true from false
                // But simplified: Only approvers see the checkbox. Editors just submit.
                // If I am NOT an approver, force preserving original state (if exists) or false (if new)
                if (!canIApprove) {
                    // 非承認者が編集した場合は、承認を取り下げる (または新規作成時は未承認)
                    isApproved = false;
                }

                const data = {
                    ...formData,
                    contentHtml: formData.contentHtml || '',
                    stats,
                    tags,
                    attachments: formData.attachments || [],
                    dateStr: formData.noYear ? '' : (formData.dateStr || ''),
                    period: formData.noYear ? { start: '', end: '' } : (formData.period || { start: '', end: '' }),
                    year: yearVal,
                    noYear: !!formData.noYear,
                    lat: Number.isFinite(formData.lat) ? formData.lat : null,
                    lng: Number.isFinite(formData.lng) ? formData.lng : null,
                    locationArticleId: formData.locationArticleId || '',
                    mainImageUrl: formData.mainImageUrl || '',
                    importance: Number(formData.importance) || 3,
                    isApproved: isApproved, // Save approval status
                    isApproved: isApproved, // Save approval status
                    updatedAt: serverTimestamp(), updatedBy: user.uid
                };
                // IDは保存データに含めない（ドキュメントIDとして管理されるため）
                delete data.id;

                try {
                    let artId = formData.id;
                    if (formData.id) {
                        await updateDoc(doc(db, 'artifacts', appContextId, 'public', 'data', 'worlds', worldId, 'articles', formData.id), data);
                    } else {
                        data.createdAt = serverTimestamp(); data.createdBy = user.uid;
                        const ref = await addDoc(collection(db, 'artifacts', appContextId, 'public', 'data', 'worlds', worldId, 'articles'), data);
                        artId = ref.id;
                        data.id = artId;
                    }

                    // Discord Webhook Notification
                    if (worldData?.discordWebhookUrl) {
                        const webhookUrl = worldData.discordWebhookUrl;
                        const isNew = !formData.id;
                        const editorName = user.displayName || 'Anonymous';
                        const title = data.title;
                        const checkStatus = isApproved ? 'Approved' : 'Unapproved';

                        // HTMLタグ除去 + Wikiリンク構文([[Title]]や[[Title|ID]])の除去(テキストは残す) + 空白整理
                        const rawText = stripHtml(data.contentHtml || '')
                            // [[Title|ID]] -> Title, [[Title]] -> Title
                            .replace(/\[\[([^|\]]+)(?:\|[^\]]+)?\]\]/g, '$1')
                            .replace(/\s+/g, ' ').trim();
                        const summary = rawText.length > 200 ? rawText.slice(0, 200) + '...' : (rawText || 'No Content');

                        const content = isNew
                            ? `🆕 **New Article Created** in ${worldData.name}\n**Title**: ${title}\n**Editor**: ${editorName}\n**Status**: ${checkStatus}\n**Summary**: ${summary}`
                            : `📝 **Article Updated** in ${worldData.name}\n**Title**: ${title}\n**Editor**: ${editorName}\n**Status**: ${checkStatus}\n**Summary**: ${summary}`;

                        // Fire and forget
                        fetch(webhookUrl, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ content })
                        }).catch(err => console.error("Discord Webhook Error:", err));
                    }

                    setSelectedArticle({ ...data, id: artId });

                    // 年代なし判定: noYearフラグが立っている、または年代が0/nullの場合
                    const hasYear = !data.noYear && data.year && Number(data.year) !== 0;

                    // 編集前のビューモードを考慮しつつ、適切なビューに遷移
                    if (previousViewMode === 'timeline_noyear' && !hasYear) {
                        // 年代なしビューから編集し、年代なしのまま → 年代なしビューに戻る
                        setViewMode('timeline_noyear');
                    } else if (previousViewMode === 'single_article') {
                        // 単独記事表示から編集 → 単独記事表示に戻る
                        setViewMode('single_article');
                    } else if (previousViewMode === 'list') {
                        // 一覧から編集 → 一覧に戻る
                        setViewMode('list');
                    } else {
                        // その他の場合は年代に基づいて判定
                        if (hasYear) {
                            setViewMode('timeline_large');
                        } else {
                            setViewMode('timeline_noyear');
                        }
                    }
                    // Success Message
                    alert(isApproved ? "保存しました" : "編集リクエストを送信しました (承認待ち)");

                } catch (e) { alert(e.message); }
            };

            const handleMapLayersUpdate = async (newLayers) => {
                const { updateDoc, doc } = window.firebaseModules;
                try {
                    await updateDoc(doc(db, 'artifacts', appContextId, 'public', 'data', 'worlds', worldId), { mapLayers: newLayers });
                    // compatibility with old field if needed, defaulting to first layer's url
                    if (newLayers.length > 0) {
                        await updateDoc(doc(db, 'artifacts', appContextId, 'public', 'data', 'worlds', worldId), { mapImageUrl: newLayers[0].url });
                    }
                } catch (e) { alert(e.message); }
            };

            const handleSaveRegionRules = async (newRules) => {
                const { updateDoc, doc } = window.firebaseModules;
                try {
                    await updateDoc(doc(db, 'artifacts', appContextId, 'public', 'data', 'worlds', worldId), { regionRules: newRules });
                } catch (e) { alert("ルール保存失敗: " + e.message); }
            };

            const handleAddMember = async (uid, defaultName = "") => {
                if (!uid) return;
                const { doc, setDoc, serverTimestamp } = window.firebaseModules;
                const name = prompt("メンバーの表示名を入力してください", defaultName);
                if (name === null) return;
                try {
                    await setDoc(doc(db, 'artifacts', appContextId, 'public', 'data', 'worlds', worldId, 'members', uid.trim()), {
                        role: 'editor', username: name || '', joinedAt: serverTimestamp()
                    });
                    alert('メンバーを追加しました');
                } catch (e) { alert('追加エラー: ' + e.message); }
            };

            // Wiki閲覧履歴管理関数
            const addToWikiHistory = (article, sourceView = 'wiki') => {
                if (!article || !article.id) return;

                // 現在位置以降の履歴を削除（新しい分岐を作成）
                const newHistory = wikiHistory.slice(0, wikiHistoryIndex + 1);

                // 同じ記事が連続する場合は追加しない
                if (newHistory.length > 0 && newHistory[newHistory.length - 1].articleId === article.id) {
                    return;
                }

                newHistory.push({
                    articleId: article.id,
                    articleTitle: article.title,
                    viewMode: sourceView,
                    timestamp: Date.now()
                });

                // 履歴は最大50件まで保持
                if (newHistory.length > 50) {
                    newHistory.shift();
                }

                setWikiHistory(newHistory);
                setWikiHistoryIndex(newHistory.length - 1);
            };

            const navigateWikiHistory = (delta) => {
                const newIndex = wikiHistoryIndex + delta;
                if (newIndex >= 0 && newIndex < wikiHistory.length) {
                    const entry = wikiHistory[newIndex];
                    const article = articles.find(a => a.id === entry.articleId);
                    if (article) {
                        setSelectedArticle(article);
                        setWikiHistoryIndex(newIndex);
                        setViewMode('wiki');
                    }
                }
            };

            const clearWikiHistory = () => {
                setWikiHistory([]);
                setWikiHistoryIndex(-1);
            };
            const handleReapplyRegionTags = async () => {
                if (!confirm('現在の全記事に対して、地域タグ・ルールを再適用しますか？\n\n・ルールに合致するタグが自動追加されます\n・場所が範囲外になった地域タグは自動削除されます\n・手動タグは維持されます')) return;
                const { updateDoc, doc } = window.firebaseModules;
                try {
                    const updates = [];
                    const managedTags = new Set(regionRules.map(r => r.tag));

                    for (const article of articles) {
                        const locationCandidates = [];
                        if (Array.isArray(article.locations)) {
                            article.locations.forEach(l => {
                                const lat = Number(l.lat);
                                const lng = Number(l.lng);
                                if (Number.isFinite(lat) && Number.isFinite(lng)) locationCandidates.push({ lat, lng });
                            });
                        }
                        if (article.lat !== undefined && article.lat !== null && article.lat !== '') {
                            const lat = Number(article.lat);
                            const lng = Number(article.lng);
                            if (Number.isFinite(lat) && Number.isFinite(lng)) locationCandidates.push({ lat, lng });
                        }

                        const validRegionTags = new Set(computeRegionTags(locationCandidates, regionRules));
                        const currentTags = article.tags || [];
                        const finalTags = new Set();
                        let changed = false;

                        currentTags.forEach(t => {
                            if (managedTags.has(t)) {
                                if (validRegionTags.has(t)) finalTags.add(t);
                                else changed = true;
                            } else {
                                finalTags.add(t);
                            }
                        });

                        validRegionTags.forEach(t => {
                            if (!finalTags.has(t)) {
                                finalTags.add(t);
                                changed = true;
                            }
                        });

                        if (changed) {
                            updates.push(updateDoc(doc(db, 'artifacts', appContextId, 'public', 'data', 'worlds', worldId, 'articles', article.id), {
                                tags: Array.from(finalTags)
                            }));
                        }
                    }
                    if (updates.length > 0) {
                        await Promise.all(updates);
                        alert(`${updates.length} 件の記事のタグを更新しました。`);
                    } else {
                        alert("更新が必要な記事はありませんでした。");
                    }
                } catch (e) { console.error(e); alert("エラーが発生しました: " + e.message); }
            };

            // When switching to the no-year view, if a selectedArticle is set then scroll to it inside that view
            React.useEffect(() => {
                try {
                    if (viewMode === 'timeline_noyear' && selectedArticle && selectedArticle.id) {
                        const id = selectedArticle.id;
                        // wait for render
                        setTimeout(() => {
                            const el = document.querySelector(`[data-noyear-id="${id}"]`);
                            if (el) {
                                try { el.scrollIntoView({ behavior: 'smooth', block: 'center' }); console.log('App: scrolled to no-year element', id); }
                                catch (err) { console.warn('scrollIntoView failed', err); }
                            } else {
                                console.log('App: no-year element not found for', id);
                            }
                        }, 200);
                    }
                } catch (e) { console.warn(e); }
            }, [viewMode, selectedArticle]);

            const openDetailView = (article, origin = viewMode) => {
                setSelectedArticle(article);
                setNavBackView(origin);

                // 記事の年代状態に応じてフィルタを調整
                const y = getArticleYear(article);
                const hasYear = y && y !== 0 && !article.noYear;

                // 年代なし記事を開く場合はexcludeNoYearをfalseに、年代あり記事はtrueに
                setTimelineFilters(prev => ({ ...prev, excludeNoYear: hasYear }));

                // 一覧、マップ、その他どこからでも詳細ビュー（全画面）へ遷移
                setViewMode('single_article');
            };

            const startEditingArticle = (article) => {
                if (!article) return;
                setPreviousViewMode(viewMode); // 編集前のビューモードを保存
                setFormData({
                    ...createEmptyArticle(),
                    ...article,
                    locations: article.locations || [],
                    period: article.period || { start: '', end: '' },
                    lat: article.lat || null,
                    lng: article.lng || null
                });
                setStats(article.stats || []);
                setTagInput((article.tags || []).join(', '));
                setViewMode('edit');
            };

            const handleTagClick = (tagName) => {
                setTimelineFilters(prev => ({ ...prev, tag: tagName }));
                const motherArticle = articles.find(a => a.representedTag === tagName);
                if (motherArticle) {
                    openDetailView(motherArticle);
                } else if (confirm(`タグ ${tagName} の記事はまだありません。作成しますか?`)) {
                    openTagArticle(tagName);
                }
            };

            const openTagArticle = (tagNameRaw) => {
                const tagName = (tagNameRaw || '').trim();
                if (!tagName) return;
                setTagArticleInput(tagName);
                const existing = articles.find(a => (a.representedTag || '').toLowerCase() === tagName.toLowerCase());
                if (existing) { startEditingArticle(existing); return; }
                const byTitle = articles.find(a => (a.title || '').toLowerCase() === tagName.toLowerCase());
                if (byTitle) { startEditingArticle(byTitle); return; }
                const draft = {
                    ...createEmptyArticle(),
                    title: tagName,
                    representedTag: tagName,
                    type: 'other',
                    folder: 'Keywords',
                    contentHtml: `<p>#${tagName} の説明を書いてください。</p>`,
                    noYear: true,
                    dateStr: '',
                    period: { start: '', end: '' },
                    tags: [tagName]
                };
                setFormData(draft);
                setStats([]);
                setTagInput(tagName);
                setViewMode('edit');
            };


            const copyMyId = () => {
                if (!user) return;
                const text = user.uid;
                const fallbackCopy = (text) => { const textArea = document.createElement("textarea"); textArea.value = text; textArea.style.position = "fixed"; textArea.style.left = "-9999px"; textArea.style.top = "0"; document.body.appendChild(textArea); textArea.focus(); textArea.select(); try { document.execCommand('copy'); alert("IDコピー: " + text); } catch (err) { console.error(err); alert("失敗"); } document.body.removeChild(textArea); };
                if (navigator.clipboard && navigator.clipboard.writeText) { navigator.clipboard.writeText(text).then(() => alert("IDコピー: " + text)).catch(() => fallbackCopy(text)); } else { fallbackCopy(text); }
            };

            const handleJoinRequest = async (msg) => {
                if (!user || !worldId) return;
                try {
                    const { doc, setDoc } = window.firebaseModules;
                    await setDoc(doc(db, 'artifacts', appContextId, 'public', 'data', 'worlds', worldId, 'members', user.uid), {
                        username: user.displayName || 'No Name',
                        role: 'pending',
                        message: msg,
                        joinedAt: new Date().toISOString()
                    }, { merge: true });
                    alert("参加申請を送りました");
                    setShowJoinRequestModal(false);
                } catch (e) { alert(e.message); }
            };

            const handleDeleteArticle = async (article) => {
                if (!article) return;
                const canDelete = myRole === 'owner' || myRole === 'admin';
                if (!canDelete) { alert("削除権限がありません（管理者のみ）"); return; }
                if (!confirm(`本当に「${article.title}」を削除しますか？\nこの操作は取り消せません。`)) return;

                const { deleteDoc, doc } = window.firebaseModules;
                try {
                    await deleteDoc(doc(db, 'artifacts', appContextId, 'public', 'data', 'worlds', worldId, 'articles', article.id));
                    // If we are currently viewing this article, close it or go back
                    if (selectedArticle && selectedArticle.id === article.id) {
                        setSelectedArticle(null);
                        setViewMode('timeline_large');
                    }
                } catch (e) { alert("削除失敗: " + e.message); }
            };

            // Expose state to window for plugins (like #datatable)
            React.useEffect(() => {
                window.articles = articles;
                window.db = db;
                window.appContextId = appContextId;
                window.worldId = worldId;
                window.worldData = worldData;
            }, [articles, db, appContextId, worldId, worldData]);

            // Global Wiki Link Click Handler for plugins (e.g. datatable)
            React.useEffect(() => {
                const handleGlobalClick = (e) => {
                    const link = e.target.closest('.wiki-link');
                    if (link) {
                        e.preventDefault();
                        e.stopPropagation();
                        const id = link.getAttribute('data-article-id');
                        const wikiTitle = link.getAttribute('data-wiki-title');

                        const target = id
                            ? articles.find(a => a.id === id)
                            : (wikiTitle ? articles.find(a => (a.title || '').trim() === wikiTitle.trim()) : null);

                        if (target) {
                            if (viewMode === 'wiki') {
                                // Wikiモード時は履歴に追加して遷移
                                addToWikiHistory(target, 'wiki');
                                setSelectedArticle(target);
                            } else {
                                // それ以外は詳細ビューロジック（年表や地図へ飛ぶ）
                                openDetailView(target);
                            }
                        } else if (wikiTitle === '年代なし') {
                            alert('年代なし表示へ移動します（未実装）');
                        } else if (id || wikiTitle) {
                            alert('記事が見つかりません');
                        }
                    }
                };
                document.addEventListener('click', handleGlobalClick);
                return () => document.removeEventListener('click', handleGlobalClick);
            }, [articles, viewMode, wikiHistory, wikiHistoryIndex]); // 依存配列に必要なstateを追加


            // Expose openArticleById globally for spreadsheet and other components
            window.openArticleById = (id) => {
                const target = articles.find(a => a.id === id);
                if (target) openDetailView(target);
                else {
                    const byTitle = articles.find(a => (a.title || '').trim() === id.trim());
                    if (byTitle) openDetailView(byTitle);
                    else alert('記事が見つかりません: ' + id);
                }
            };

            const handleDuplicateArticle = (article) => {
                if (!article) return;
                if (!['owner', 'editor', 'admin'].includes(myRole)) { alert("作成権限がありません"); return; }

                const newTitle = article.title + " (複製)";
                const duplicated = {
                    ...article,
                    title: newTitle,
                    id: null,
                    isApproved: false,
                    createdAt: null,
                    updatedAt: null,
                    createdBy: null,
                    updatedBy: null
                };

                // Use existing startEditingArticle logic but override state with duplicated data
                setFormData({
                    ...createEmptyArticle(),
                    ...duplicated,
                    locations: duplicated.locations || [],
                    period: duplicated.period || { start: '', end: '' },
                    lat: duplicated.lat || null,
                    lng: duplicated.lng || null
                });
                setStats(duplicated.stats || []);
                setTagInput((duplicated.tags || []).join(','));
                setViewMode('edit');
            };

            // 匿名ログインを自動実行（閲覧のみ可能）
            React.useEffect(() => {
                if (!user && !loading && auth) {
                    const { signInAnonymously } = window.firebaseModules;
                    signInAnonymously(auth).catch(err => {
                        console.error('匿名ログイン失敗:', err);
                        setAuthError('自動ログインに失敗しました: ' + err.message);
                    });
                }
            }, [user, loading, auth]);

            if (loading) return <div className="h-screen flex items-center justify-center text-indigo-600 font-bold animate-pulse">Loading...</div>;
            if (!user) return <div className="h-screen flex items-center justify-center text-indigo-600 font-bold">接続中...</div>;

            if (viewMode === 'world_select') return (
                <div className="min-h-screen bg-gray-100 p-6">
                    <div className="max-w-4xl mx-auto">
                        <div className="flex justify-between items-center mb-6">
                            <h1 className="text-2xl font-bold serif text-gray-800">世界の選択</h1>
                            <div className="flex gap-2 items-center">
                                <span className="text-xs text-gray-400 font-mono">{appContextId}</span>
                                <button onClick={() => setShowConfigEditor(true)} className="text-xs text-gray-500 hover:text-indigo-600"><Icon name="settings" size={14} /></button>
                                {user?.isAnonymous ? (
                                    <button onClick={() => { setAuthMode('login'); setShowAuthModal(true); }} className="text-sm text-indigo-600 font-bold hover:underline ml-2">ログイン</button>
                                ) : (
                                    <button onClick={() => window.firebaseModules.signOut(auth)} className="text-sm text-red-500 hover:underline ml-2">ログアウト</button>
                                )}
                            </div>
                        </div>
                        {showConfigEditor && <ConfigEditor currentConfig={activeConfig} currentAppId={appContextId} onSave={handleConfigSave} onCancel={() => setShowConfigEditor(false)} />}
                        <div className="grid md:grid-cols-2 gap-6">
                            <div className="bg-white p-6 rounded-lg shadow"><h2 className="text-lg font-bold mb-4"><Icon name="search" /> 世界を探す</h2><WorldList db={db} appContextId={appContextId} onSelect={(id) => { setWorldId(id); setViewMode('timeline_large'); }} /></div>
                            <div className="bg-white p-6 rounded-lg shadow"><h2 className="text-lg font-bold mb-4"><Icon name="plus-circle" /> 新世界創造</h2>
                                <div className="space-y-3"><input className="w-full border p-2 rounded" placeholder="名前" value={authForm.worldName} onChange={e => setAuthForm({ ...authForm, worldName: e.target.value })} /><button onClick={handleCreateWorld} className="w-full bg-emerald-600 text-white py-2 rounded font-bold">創造</button></div>
                            </div>
                        </div>
                    </div>
                </div>
            );

            return (
                <div className="flex h-screen overflow-hidden bg-gray-100">
                    <div className="flex-1 flex flex-col relative h-full overflow-hidden">
                        <header className="bg-white shadow-sm px-2 md:px-4 py-2 flex flex-wrap gap-2 items-center justify-between z-10 border-b shrink-0">
                            <div className="flex items-center gap-4">
                                <button onClick={() => { setWorldId(null); setViewMode('world_select'); }} className="p-2 -ml-2 text-gray-400 hover:text-indigo-600 rounded-full hover:bg-gray-100 transition-colors" title="メニューに戻る">
                                    <Icon name="home" size={20} />
                                </button>
                                <div className="hidden md:flex flex-col text-xs text-gray-500">
                                    <span className="text-sm font-bold text-gray-800">{worldData?.name}</span>
                                    <div className="flex items-center gap-2">
                                        <span className="text-[11px] cursor-pointer hover:text-indigo-600" onClick={copyMyId} title="IDコピー">{user?.displayName || 'Guest'} (ID)</span>
                                        {user?.isAnonymous ? (
                                            <button onClick={() => { setAuthMode('login'); setShowAuthModal(true); }} className="text-[10px] bg-indigo-50 text-indigo-600 px-1.5 py-0.5 rounded border border-indigo-100 hover:bg-indigo-100 font-bold">ログイン</button>
                                        ) : (
                                            <button onClick={() => window.firebaseModules.signOut(auth)} className="text-[10px] bg-red-50 text-red-500 px-1.5 py-0.5 rounded border border-red-100 hover:bg-red-100 font-bold">ログアウト</button>
                                        )}
                                    </div>
                                </div>
                                <div className="flex-1 md:flex-none flex bg-gray-100 p-1 rounded-lg overflow-x-auto no-scrollbar min-w-0 max-w-full md:max-w-[60vw]">{VIEW_TABS.map(tab => (<button key={tab.key} onClick={() => setViewMode(tab.key)} className={`px-3 py-1.5 rounded text-sm flex items-center gap-1 whitespace-nowrap ${viewMode === tab.key ? 'bg-white shadow text-indigo-600 font-bold' : 'text-gray-500'}`}><Icon name={tab.icon} size={16} /> {tab.label}</button>))}</div>
                            </div>
                            <div className="flex items-center gap-2 md:gap-4">
                                {(viewMode === 'timeline_large' || viewMode === 'list' || viewMode === 'story' || viewMode === 'map') && (
                                    <button onClick={() => setTimelineFilters(prev => ({ ...prev, onlyApproved: !prev.onlyApproved, onlyUnapproved: false }))} className={`flex items-center gap-1 text-xs px-2 py-1 rounded transition-colors ${timelineFilters.onlyApproved ? 'bg-emerald-600 text-white font-bold' : 'bg-gray-200 text-gray-500 hover:bg-gray-300'}`} title="承認済み記事のみ表示">
                                        <Icon name="check-circle" size={14} />
                                        <span className="hidden sm:inline">承認済のみ</span>
                                    </button>
                                )}
                                <div className="hidden lg:flex items-center text-[11px] text-gray-400"><Icon name="filter" size={12} className="mr-1" /> {timelineSummary} {timelineFilters.onlyApproved && <span className="text-emerald-600 font-bold ml-1">(ON)</span>}</div>
                                <div className="flex items-center gap-1 bg-gray-100 rounded px-1 ml-2">
                                    <button onClick={() => setUiScale(s => Math.max(50, s - 10))} className="p-1 hover:text-indigo-600 text-gray-500" title="縮小"><Icon name="minus" size={12} /></button>
                                    <span className="text-[10px] w-8 text-center text-gray-500 font-mono">{uiScale}%</span>
                                    <button onClick={() => setUiScale(s => Math.min(200, s + 10))} className="p-1 hover:text-indigo-600 text-gray-500" title="拡大"><Icon name="plus" size={12} /></button>
                                </div>
                                {(myRole === 'owner' || myRole === 'admin') && <button onClick={() => setShowAdminPanel(true)} title="管理パネル" className="text-gray-500 hover:text-indigo-600 p-2 rounded-full bg-gray-100"><Icon name="settings" size={18} /></button>}
                                {!user ? (
                                    <button onClick={() => setShowAuthModal(true)} className="bg-indigo-600 text-white px-4 py-1.5 rounded text-sm font-bold shadow-sm flex items-center gap-1">
                                        <Icon name="log-in" size={16} /> ログインしてください
                                    </button>
                                ) : isEditor ? (
                                    <button onClick={() => { setFormData(createEmptyArticle()); setStats([]); setTagInput(''); setViewMode('edit'); }} className="bg-indigo-600 text-white px-4 py-1.5 rounded text-sm font-bold shadow-sm flex items-center gap-1">
                                        <Icon name="plus" size={16} /> 記事作成
                                    </button>
                                ) : (
                                    <button onClick={() => setShowJoinRequestModal(true)} className="bg-indigo-600 text-white px-4 py-1.5 rounded text-sm font-bold shadow-sm flex items-center gap-1">
                                        <Icon name="user-plus" size={16} /> 参加申請
                                    </button>
                                )}
                            </div>
                        </header>
                        <div className={`flex-1 relative bg-slate-50 w-full ${isFixedView ? 'overflow-hidden' : 'overflow-y-auto'}`}><div style={viewMode === 'map' ? {} : scaleStyle}>
                            {viewMode === 'list' && <FolderIntegratedList articles={articles} onSelectArticle={(article) => openDetailView(article, 'list')} onTagClick={handleTagClick} onlyApproved={timelineFilters.onlyApproved} onlyUnapproved={timelineFilters.onlyUnapproved} onOpenNoYear={(id) => { if (id) { const art = articles.find(x => x.id === id); if (art) setSelectedArticle(art); } setViewMode('timeline_noyear'); }} onSearchChange={p => setTimelineFilters(prev => ({ ...prev, ...p }))} />}
                            {viewMode === 'story' && <FolderIntegratedList articles={articles} onSelectArticle={(article) => openDetailView(article, 'story')} onTagClick={handleTagClick} onlyApproved={timelineFilters.onlyApproved} onlyUnapproved={timelineFilters.onlyUnapproved} onOpenNoYear={(id) => { if (id) { const art = articles.find(x => x.id === id); if (art) setSelectedArticle(art); } setViewMode('timeline_noyear'); }} onSearchChange={p => setTimelineFilters(prev => ({ ...prev, ...p }))} filterFn={(a) => a.type === 'story' || (a.tags && (a.tags.includes('物語') || a.tags.includes('小説') || a.tags.includes('設定書')))} />}
                            {viewMode === 'map' && <div className="absolute inset-0 flex flex-col">
                                <div className="p-3 z-10 bg-white/90 border-b flex items-center gap-4">
                                    <input className="flex-1 p-2 rounded border text-sm max-w-sm" placeholder="地図検索 (タイトル/本文/タグ)..." value={mapTabQuery || ''} onChange={e => setMapTabQuery(e.target.value)} />
                                    <div className="flex items-center gap-2 border-l pl-4">
                                        <span className="text-xs font-bold text-gray-500">重要度:</span>
                                        <div className="flex bg-gray-100 rounded p-0.5">
                                            {[1, 2, 3, 4, 5].map(v => (
                                                <button key={v} onClick={() => setMapTabImportance(mapTabImportance === v ? 0 : v)} className={`px-2 py-0.5 text-xs rounded ${mapTabImportance === v ? 'bg-indigo-600 text-white font-bold' : mapTabImportance > v ? 'text-indigo-600' : 'text-gray-400'}`}>
                                                    {v}
                                                </button>
                                            ))}
                                            <span className="text-[10px] items-center flex px-1 text-gray-400">{mapTabImportance ? '以上' : '指定なし'}</span>
                                        </div>
                                    </div>
                                </div>
                                <div className="flex-1 relative"><MapView articles={articles} worldData={worldData} isEditing={false} externalQuery={mapTabQuery} onExternalQueryChange={v => setMapTabQuery(v)} highlightArticleId={selectedArticle?.id} minImportance={mapTabImportance} onSelectArticle={a => {
                                    // 年代がある記事は年表ビューで拡大表示、年代なしは単独の拡大記事表示
                                    const y = getArticleYear(a);
                                    const hasYear = y && y !== 0 && !a.noYear;

                                    // 記事の年代状態に応じてフィルタを調整
                                    setTimelineFilters(prev => ({ ...prev, excludeNoYear: hasYear }));

                                    if (hasYear) {
                                        setSelectedArticle(a);
                                        setViewMode('timeline_large');
                                    } else {
                                        openDetailView(a, 'map');
                                    }
                                }} appContextId={appContextId} /></div>
                            </div>}
                            {viewMode === 'timeline_large' && <LargeTimelineView
                                articles={filteredTimelineArticles}
                                onSelectArticle={setSelectedArticle}
                                onEditArticle={startEditingArticle}
                                onDeleteArticle={handleDeleteArticle}
                                onDuplicateArticle={handleDuplicateArticle}
                                focusedArticle={selectedArticle}
                                onFocusChange={setSelectedArticle}
                                allArticles={articles}
                                searchState={timelineFilters}
                                onSearchChange={p => setTimelineFilters(prev => ({ ...prev, ...p }))}
                                onResetFilters={() => setTimelineFilters({ type: 'all', keyword: '', tag: '', excludeNoYear: true, onlyApproved: false })}
                                worldData={worldData}
                                appContextId={appContextId}
                                myRole={myRole}
                                onOpenNoYear={(id) => { if (id) { const art = articles.find(x => x.id === id); if (art) { openDetailView(art, 'timeline_large'); } } else { setViewMode('timeline_noyear'); } }}
                                onOpenTagArticle={openTagArticle}
                                tagArticleValue={tagArticleInput}
                                onTagArticleValueChange={setTagArticleInput}
                                members={members}
                                onAddMember={handleAddMember}
                            />}
                            {viewMode === 'stats' && <GraphView setView={setViewMode} articles={articles} />}
                            {viewMode === 'wiki' && (
                                <WikiReadView
                                    article={selectedArticle}
                                    articles={articles}
                                    history={wikiHistory}
                                    historyIndex={wikiHistoryIndex}
                                    canGoBack={wikiHistoryIndex > 0}
                                    canGoForward={wikiHistoryIndex < wikiHistory.length - 1}
                                    onNavigate={(nextArticle) => {
                                        addToWikiHistory(nextArticle, 'wiki');
                                        setSelectedArticle(nextArticle);
                                    }}
                                    onBack={() => navigateWikiHistory(-1)}
                                    onForward={() => navigateWikiHistory(1)}
                                    onHistoryJump={(idx) => {
                                        const entry = wikiHistory[idx];
                                        const target = articles.find(a => a.id === entry.articleId);
                                        if (target) {
                                            setSelectedArticle(target);
                                            setWikiHistoryIndex(idx);
                                        }
                                    }}
                                    onClearHistory={clearWikiHistory}
                                />
                            )}
                            {viewMode === 'spreadsheet' && <LargeSpreadsheetView articles={articles} db={db} appContextId={appContextId} worldId={worldId} filters={timelineFilters} />}
                            {viewMode === 'timeline_noyear' && (
                                <div className="absolute inset-0 overflow-auto p-6 bg-slate-900">
                                    <div className="flex items-center justify-between mb-4">
                                        <h2 className="text-xl font-bold text-white">年代未設定の記事一覧</h2>
                                        <div className="flex gap-2"><button onClick={() => setViewMode('timeline_large')} className="px-3 py-1 rounded bg-slate-700 text-white hover:bg-slate-600">年表に戻る</button><button onClick={() => { setPreviousViewMode('timeline_noyear'); setViewMode('edit'); }} className="px-3 py-1 rounded bg-indigo-600 text-white hover:bg-indigo-700">新規作成</button></div>
                                    </div>
                                    <div className="space-y-4">
                                        {articles.filter(a => {
                                            if (a.noYear === true) return true;
                                            const y = Math.floor(getArticleYear(a));
                                            return !y || Number(y) === 0;
                                        }).map(a => (
                                            <div key={a.id} className="bg-slate-800/50 border border-slate-700 rounded-xl p-6 hover:bg-slate-800 transition">
                                                <div className="flex items-center justify-between mb-3"><h3 className="font-bold text-xl text-white" dangerouslySetInnerHTML={{ __html: applyRuby(escapeHtml(a.title)) }}></h3><span className="text-xs text-slate-400 font-mono">{a.dateStr || ''}</span></div>
                                                <div className="text-sm text-slate-300 mb-4 rich-editor leading-relaxed" onClick={(e) => {
                                                    const link = e.target.closest && e.target.closest('.wiki-link');
                                                    if (link) {
                                                        e.preventDefault(); e.stopPropagation();
                                                        const id = link.getAttribute('data-article-id');
                                                        const wikiTitle = link.getAttribute('data-wiki-title');
                                                        if (id) {
                                                            const target = articleIndex.get(id);
                                                            if (target) {
                                                                openDetailView(target, 'timeline_noyear');
                                                            } else {
                                                                alert('リンク先の記事が見つかりません');
                                                            }
                                                        } else if (wikiTitle) {
                                                            if (wikiTitle === '年代なし') {
                                                                setViewMode('timeline_noyear');
                                                            } else {
                                                                const target = articles.find(x => (x.title || '').trim() === wikiTitle.trim());
                                                                if (target) {
                                                                    openDetailView(target, 'timeline_noyear');
                                                                } else {
                                                                    alert('リンク先の記事が見つかりません');
                                                                }
                                                            }
                                                        }
                                                    }
                                                }} dangerouslySetInnerHTML={{ __html: transformContent(a.contentHtml || '') }}></div>
                                                <div className="flex justify-end gap-2 border-t border-slate-700 pt-3">
                                                    <button onClick={() => { startEditingArticle(a); }} className="px-3 py-1 rounded bg-slate-700 text-white text-sm hover:bg-slate-600">編集</button>
                                                    <button onClick={() => { handleDuplicateArticle(a); }} className="px-3 py-1 rounded bg-emerald-600 text-white text-sm hover:bg-emerald-700">複製</button>
                                                    {(myRole === 'owner' || myRole === 'admin') && <button onClick={() => { handleDeleteArticle(a); }} className="px-3 py-1 rounded bg-red-600 text-white text-sm hover:bg-red-700">削除</button>}
                                                </div>
                                            </div>
                                        ))}
                                    </div>
                                </div>
                            )}
                            {viewMode === 'single_article' && selectedArticle && (
                                <div className="absolute inset-0 bg-slate-900 overflow-y-auto z-50 p-0">
                                    <div className="sticky top-0 bg-slate-900/95 backdrop-blur border-b border-slate-700 p-4 flex justify-between items-center z-50 shadow-lg">
                                        <div className="flex items-center gap-4">
                                            <button onClick={() => setViewMode(navBackView || 'timeline_large')} className="flex items-center gap-1 text-sm text-slate-400 hover:text-white"><Icon name="arrow-left" size={16} /> 一覧に戻る</button>
                                            <h2 className="font-bold text-lg truncate max-w-xl flex items-center gap-2 text-white">
                                                <span dangerouslySetInnerHTML={{ __html: applyRuby(escapeHtml(selectedArticle.title)) }}></span>
                                                {selectedArticle.isApproved && <span className="bg-emerald-600 text-white text-xs px-2 py-0.5 rounded flex items-center gap-1"><Icon name="check" size={12} /> 承認済</span>}
                                            </h2>
                                        </div>
                                        <div className="flex gap-2">
                                            {isEditor && (
                                                <>
                                                    <button onClick={() => startEditingArticle(selectedArticle)} className="px-4 py-1.5 bg-indigo-600 text-white text-sm font-bold rounded shadow-sm hover:bg-indigo-700">編集</button>
                                                    <button onClick={() => handleDuplicateArticle(selectedArticle)} className="px-4 py-1.5 bg-emerald-600 text-white text-sm font-bold rounded shadow-sm hover:bg-emerald-700">複製</button>
                                                </>
                                            )}
                                            {(myRole === 'owner' || myRole === 'admin') && <button onClick={() => handleDeleteArticle(selectedArticle)} className="px-4 py-1.5 bg-red-600 text-white text-sm font-bold rounded shadow-sm hover:bg-red-700">削除</button>}
                                        </div>
                                    </div>
                                    <div className="max-w-none p-8 md:p-12 mx-auto">
                                        {/* Full width rendering container without constraints for complex tables */}
                                        <div className="prose prose-xl max-w-none prose-invert" style={{ color: '#e2e8f0' }} dangerouslySetInnerHTML={{ __html: transformContent(selectedArticle.contentHtml || '') }} onClick={(e) => {
                                            const link = e.target.closest && e.target.closest('.wiki-link');
                                            if (link) {
                                                e.preventDefault(); e.stopPropagation();
                                                const id = link.getAttribute('data-article-id');
                                                if (id) {
                                                    const target = articleIndex.get(id);
                                                    if (target) {
                                                        const y = getArticleYear(target);
                                                        // 年代設定ありの記事なら年表ビューへ飛ぶ
                                                        if (y && y !== 0 && !target.noYear) {
                                                            setSelectedArticle(target);
                                                            setViewMode('timeline_large');
                                                            // フォーカスを当てるなど
                                                        } else {
                                                            setSelectedArticle(target);
                                                            /* stay in single view */
                                                        }
                                                    }
                                                    else alert('リンク先が見つかりません');
                                                }
                                            }
                                        }}></div>
                                    </div>
                                </div>
                            )}
                            {viewMode === 'edit' && (
                                <div className="absolute inset-0 flex flex-col bg-white z-50">
                                    <div className="border-b px-6 py-3 flex justify-between items-center bg-gray-50">
                                        <h2 className="font-bold text-gray-700 flex items-center gap-2">
                                            {canIApprove ? '編集' : '編集リクエスト'}
                                            {!canIApprove && <span className="text-[10px] bg-amber-100 text-amber-700 px-2 py-0.5 rounded">※承認待ちとなります</span>}
                                        </h2>
                                        <div className="flex gap-2">
                                            <button onClick={() => setViewMode(previousViewMode || 'timeline_large')} className="px-4 py-2 rounded bg-gray-200 text-sm">キャンセル</button>
                                            <button onClick={handleSaveArticle} className={`px-6 py-2 rounded text-white font-bold text-sm ${canIApprove ? 'bg-indigo-600 hover:bg-indigo-700' : 'bg-emerald-600 hover:bg-emerald-700'}`}>
                                                {canIApprove ? '保存' : '申請する'}
                                            </button>
                                        </div>
                                    </div>
                                    <div className="flex-1 flex flex-col lg:flex-row overflow-hidden">
                                        <div className="flex-1 p-4 md:p-6 overflow-y-auto flex flex-col gap-4">
                                            <input className="w-full text-xl md:text-3xl font-bold p-2 border-b outline-none serif" placeholder="タイトル" value={formData.title} onChange={e => setFormData(prev => ({ ...prev, title: e.target.value }))} />
                                            <div className="grid grid-cols-1 md:grid-cols-2 gap-4"><div><label className="text-xs font-bold text-gray-500 block mb-1">期間 (開始) (yyyy/mm/dd-hh:mm:ss)</label><input type="text" className="w-full border p-2 rounded" placeholder="2023/01/01-00:00:00" value={formData.period?.start || ''} onChange={e => setFormData(prev => ({ ...prev, period: { ...(prev.period || {}), start: e.target.value } }))} /></div><div><label className="text-xs font-bold text-gray-500 block mb-1">期間 (終了) (yyyy/mm/dd-hh:mm:ss)</label><input type="text" className="w-full border p-2 rounded" placeholder="2023/12/31-23:59:59" value={formData.period?.end || ''} onChange={e => setFormData(prev => ({ ...prev, period: { ...(prev.period || {}), end: e.target.value } }))} /></div></div>
                                            <div className="grid grid-cols-1 md:grid-cols-3 gap-4">
                                                <div>
                                                    <label className="text-xs font-bold text-gray-500 block mb-1">種別</label>
                                                    <select className="w-full border p-2 rounded" value={formData.type} onChange={e => setFormData(prev => ({ ...prev, type: e.target.value }))}>
                                                        {Object.entries(ARTICLE_TYPES).map(([k, v]) => <option key={k} value={k}>{v.label}</option>)}
                                                    </select>
                                                </div>
                                                <div>
                                                    <label className="text-xs font-bold text-gray-500 block mb-1">フォルダ</label>
                                                    <input className="w-full border p-2 rounded" placeholder="国/組織" value={formData.folder} onChange={e => setFormData(prev => ({ ...prev, folder: e.target.value }))} />
                                                </div>
                                                <div>
                                                    <label className="text-xs font-bold text-gray-500 block mb-1">日時 (yyyy/mm/dd-hh:mm:ss)</label>
                                                    <input className="w-full border p-2 rounded" placeholder="2023/11/20-14:00:00" value={formData.dateStr || ''} onChange={e => setFormData(prev => ({ ...prev, dateStr: e.target.value }))} />
                                                </div>
                                            </div>
                                            <div className="my-2">
                                                <label className="text-xs font-bold text-gray-500 block mb-1">重要度 (1-5)</label>
                                                <div className="flex gap-1">
                                                    {[1, 2, 3, 4, 5].map(v => (
                                                        <button key={v} onClick={() => setFormData(prev => ({ ...prev, importance: v }))} className={`px-3 py-1 rounded text-sm font-bold border ${formData.importance === v ? 'bg-yellow-100 text-yellow-600 border-yellow-300' : 'bg-gray-50 text-gray-400'}`}>
                                                            {v}
                                                        </button>
                                                    ))}
                                                </div>
                                            </div>
                                            <div className="flex items-center gap-4">
                                                <label className="flex items-center gap-2 text-sm"><input type="checkbox" checked={!!formData.noYear} onChange={e => setFormData(prev => ({ ...prev, noYear: e.target.checked }))} /> <span className="text-sm text-gray-600">年代なしにする</span></label>
                                                {canIApprove && (
                                                    <label className="flex items-center gap-2 text-sm bg-emerald-50 px-2 py-1 rounded border border-emerald-200">
                                                        <input type="checkbox" checked={!!formData.isApproved} onChange={e => setFormData(prev => ({ ...prev, isApproved: e.target.checked }))} />
                                                        <span className="text-sm font-bold text-emerald-800">承認済みにする</span>
                                                    </label>
                                                )}
                                            </div>
                                            {!canIApprove && (
                                                <div className="text-xs text-gray-500">
                                                    現在のステータス: <span className={`font-bold ${formData.isApproved ? 'text-emerald-600' : 'text-gray-400'}`}>{formData.isApproved ? '承認済み' : '未承認'}</span>
                                                    (承認権限がありません)
                                                </div>
                                            )}
                                            <div className="flex flex-col md:flex-row gap-2">
                                                <div className="flex-1"><LocationsEditor locations={formData.locations} onChange={l => setFormData(prev => ({ ...prev, locations: l }))} /></div>
                                                <div className="w-full md:w-1/3 space-y-2">
                                                    <ArticleLinkInserter articles={articles} onInsert={(a) => {
                                                        if (formData._editorMode === 'html' && htmlTextareaRef.current) {
                                                            const ta = htmlTextareaRef.current;
                                                            const start = ta.selectionStart;
                                                            const end = ta.selectionEnd;
                                                            const text = formData.contentHtml || '';
                                                            const wikiLink = `[[${a.title}|${a.id}]]`;
                                                            const newText = text.substring(0, start) + wikiLink + text.substring(end);
                                                            setFormData(prev => ({ ...prev, contentHtml: newText }));
                                                            setTimeout(() => {
                                                                ta.focus();
                                                                ta.setSelectionRange(start + wikiLink.length, start + wikiLink.length);
                                                            }, 0);
                                                        } else if (editorRef.current) {
                                                            editorRef.current.insertLink(a);
                                                        }
                                                    }} />
                                                    <TableInserter
                                                        isWysiwyg={formData._editorMode !== 'html'}
                                                        canCreateSheet={isEditor}
                                                        onInsert={(r, c) => {
                                                            if (formData._editorMode === 'html' && htmlTextareaRef.current) {
                                                                const ta = htmlTextareaRef.current;
                                                                const start = ta.selectionStart;
                                                                const end = ta.selectionEnd;
                                                                const text = formData.contentHtml || '';
                                                                let tableHtml = '<table style="width:100%; border-collapse:collapse; border:1px solid #ccc;"><tbody>';
                                                                for (let i = 0; i < r; i++) {
                                                                    tableHtml += '<tr>';
                                                                    for (let j = 0; j < c; j++) tableHtml += '<td style="border:1px solid #ccc; padding:8px;">&nbsp;</td>';
                                                                    tableHtml += '</tr>';
                                                                }
                                                                tableHtml += '</tbody></table><p><br></p>';
                                                                const newText = text.substring(0, start) + tableHtml + text.substring(end);
                                                                setFormData(prev => ({ ...prev, contentHtml: newText }));
                                                                setTimeout(() => {
                                                                    ta.focus();
                                                                    ta.setSelectionRange(start + tableHtml.length, start + tableHtml.length);
                                                                }, 0);
                                                            } else if (editorRef.current) {
                                                                editorRef.current.insertTable(r, c);
                                                            }
                                                        }}
                                                        onAction={(action, payload) => {
                                                            if (action === 'insertEmbed' && payload) {
                                                                if (formData._editorMode === 'html' && htmlTextareaRef.current) {
                                                                    const ta = htmlTextareaRef.current;
                                                                    const start = ta.selectionStart;
                                                                    const end = ta.selectionEnd;
                                                                    const text = formData.contentHtml || '';
                                                                    const newText = text.substring(0, start) + payload + text.substring(end);
                                                                    setFormData(prev => ({ ...prev, contentHtml: newText }));
                                                                } else if (editorRef.current) {
                                                                    editorRef.current.insertText(payload);
                                                                }
                                                                return;
                                                            }
                                                            if (action === 'insertFromText' && payload) {
                                                                if (formData._editorMode === 'html' && htmlTextareaRef.current) {
                                                                    const ta = htmlTextareaRef.current;
                                                                    const start = ta.selectionStart;
                                                                    const text = formData.contentHtml || '';
                                                                    const rows = parseCSV(payload);
                                                                    let tableHtml = '<table style="width:100%; border-collapse:collapse; border:1px solid #ccc;"><tbody>';
                                                                    rows.forEach(r => {
                                                                        tableHtml += '<tr>';
                                                                        r.forEach(c => { tableHtml += `<td style="border:1px solid #ccc; padding:8px;">${c || '&nbsp;'}</td>`; });
                                                                        tableHtml += '</tr>';
                                                                    });
                                                                    tableHtml += '</tbody></table><p><br></p>';
                                                                    const newText = text.substring(0, start) + tableHtml + text.substring(start);
                                                                    setFormData(prev => ({ ...prev, contentHtml: newText }));
                                                                } else if (editorRef.current) {
                                                                    editorRef.current.insertCSV(payload);
                                                                }
                                                                return;
                                                            }
                                                            if (formData._editorMode !== 'html' && editorRef.current) {
                                                                if (action === 'insertRowBelow') editorRef.current.insertRow('below');
                                                                else if (action === 'insertColumnRight') editorRef.current.insertColumn('right');
                                                                else if (action === 'deleteRow') editorRef.current.deleteRow();
                                                                else if (action === 'deleteColumn') editorRef.current.deleteColumn();
                                                                else if (action === 'mergeCells') editorRef.current.mergeCells();
                                                                else if (action === 'unmergeCells') editorRef.current.unmergeCells();
                                                                else if (action === 'formatCell') editorRef.current.formatCell(payload.attr, payload.value);
                                                            } else {
                                                                alert('表の構成変更はWYSIWYGモードで行ってください。');
                                                            }
                                                        }}
                                                    />
                                                    <div className="text-xs text-gray-500">※文字色はエディタのカラー機能で変更できます</div>
                                                </div>
                                            </div>
                                            <div className="space-y-2">
                                                <div className="mt-2 flex items-center gap-3">
                                                    <label className="text-xs font-bold text-gray-500">本文</label>
                                                    <div className="flex items-center gap-2">
                                                        <button onClick={() => setFormData(prev => ({ ...prev, _editorMode: 'wysiwyg' }))} className={`px-2 py-1 rounded text-xs ${formData._editorMode !== 'html' ? 'bg-indigo-600 text-white' : 'bg-white'}`}>WYSIWYG</button>
                                                        <button onClick={() => setFormData(prev => ({ ...prev, _editorMode: 'html' }))} className={`px-2 py-1 rounded text-xs ${formData._editorMode === 'html' ? 'bg-indigo-600 text-white' : 'bg-white'}`}>HTML編集</button>
                                                    </div>
                                                </div>
                                                {formData._editorMode === 'html' ? (
                                                    <div className="flex-1 border rounded overflow-hidden flex flex-col min-h-[320px] bg-white">
                                                        <label className="text-xs font-bold text-gray-500 p-2">HTML ソース</label>
                                                        <textarea ref={htmlTextareaRef} className="w-full h-48 p-2 font-mono text-sm border-t" value={formData.contentHtml || ''} onChange={e => setFormData(prev => ({ ...prev, contentHtml: e.target.value }))} />
                                                        <div className="p-2 border-t">
                                                            <AttachmentUploader storage={storage} appContextId={appContextId} onAddAttachment={(att) => setFormData(prev => ({ ...prev, attachments: [...(prev.attachments || []), att] }))} />
                                                            <div className="mt-2 space-y-1 text-xs">
                                                                {(formData.attachments || []).map((att, i) => (
                                                                    <div key={i} className="flex items-center justify-between gap-2 p-1 bg-gray-50 rounded mb-1">
                                                                        <a className="text-indigo-600 underline truncate flex-1" href={att.url} target="_blank" rel="noreferrer" title={att.name}>{att.name}</a>
                                                                        <div className="flex gap-1">
                                                                            <button onClick={() => copyText(att.url)} className="text-gray-500 hover:text-indigo-600 text-[10px] border px-1 rounded bg-white">URL</button>
                                                                            <button onClick={() => {
                                                                                const tag = `<img src="${att.url}" alt="${att.name}" style="max-width:100%;" />`;
                                                                                if (htmlTextareaRef.current) {
                                                                                    const ta = htmlTextareaRef.current;
                                                                                    const start = ta.selectionStart;
                                                                                    const end = ta.selectionEnd;
                                                                                    const text = formData.contentHtml || '';
                                                                                    const newText = text.substring(0, start) + tag + text.substring(end);
                                                                                    setFormData(prev => ({ ...prev, contentHtml: newText }));
                                                                                    setTimeout(() => {
                                                                                        ta.focus();
                                                                                        ta.setSelectionRange(start + tag.length, start + tag.length);
                                                                                    }, 0);
                                                                                }
                                                                            }} className="text-indigo-600 hover:text-indigo-800 text-[10px] border px-1 rounded font-bold bg-white">IMG挿入</button>
                                                                            <button onClick={() => setFormData(prev => ({ ...prev, attachments: prev.attachments.filter((_, ii) => ii !== i) }))} className="text-red-500 hover:text-red-700 text-[10px] border px-1 rounded bg-white">削除</button>
                                                                        </div>
                                                                    </div>
                                                                ))}
                                                            </div>
                                                        </div>
                                                    </div>
                                                ) : (
                                                    <div className="flex-1 border rounded overflow-hidden flex flex-col min-h-[320px] bg-white"><RichTextEditor ref={editorRef} value={formData.contentHtml || ''} onChange={val => setFormData(prev => ({ ...prev, contentHtml: val }))} /></div>
                                                )}
                                            </div>
                                            <div className="bg-gray-50 p-2 rounded"><label className="text-xs font-bold text-gray-500 block mb-1">タグ (カンマ区切り)</label><input className="w-full border p-2 rounded" placeholder="王, 歴史, 重要" value={tagInput} onChange={e => setTagInput(e.target.value)} /></div>
                                            <div className="bg-white border rounded p-3 shadow-sm space-y-3">
                                                <div className="flex items-center justify-between">
                                                    <div><label className="text-xs font-bold text-gray-500 block mb-1">メイン画像</label></div>
                                                    <ImageUploader storage={storage} appContextId={appContextId} onUploadComplete={url => setFormData(prev => ({ ...prev, mainImageUrl: url }))} label="アップロード" />
                                                </div>
                                                {formData.mainImageUrl && <>
                                                    <img src={formData.mainImageUrl} alt="preview" className="w-full rounded border" />
                                                    <div className="flex gap-2 text-[11px] text-gray-500">
                                                        <button type="button" onClick={() => setFormData(prev => ({ ...prev, mainImageUrl: '' }))} className="px-2 py-1 border rounded">削除</button>
                                                    </div>
                                                </>}
                                            </div>
                                        </div>
                                        <div className="w-full lg:w-80 h-72 lg:h-auto border-t lg:border-t-0 lg:border-l bg-gray-50 flex flex-col overflow-y-auto shrink-0">
                                            <div className="h-52 relative border-b">
                                                <MapView
                                                    articles={previewArticles}
                                                    worldData={worldData}
                                                    highlightArticleId={formData?.id || '__draft__'}
                                                    isEditing={true}
                                                    onLocationSelect={c => {
                                                        const newLoc = { lat: Number(c.lat.toFixed(4)), lng: Number(c.lng.toFixed(4)), label: 'New Point' };
                                                        setFormData(prev => ({ ...prev, locations: [...(prev.locations || []), newLoc] }));
                                                    }}
                                                    appContextId={appContextId}
                                                    storage={storage}
                                                    onMapImageUpdate={null} // Disable direct image update in edit sidebar in favor of admin panel
                                                    myRole={myRole}
                                                />
                                            </div>
                                            <div className="p-4 border-t"><div className="text-xs font-bold text-gray-500 mb-2 border-b pb-1">ステータス</div><StatsEditor stats={stats} onChange={setStats} /></div>
                                        </div>
                                    </div>
                                </div>
                            )}
                            {showMemberManager && <MemberManager db={db} worldId={worldId} appContextId={appContextId} onClose={() => setShowMemberManager(false)} members={members} onAddMember={handleAddMember} />}
                            {showJoinRequestModal && <JoinRequestModal onClose={() => setShowJoinRequestModal(false)} onSubmit={handleJoinRequest} currentStatus={myRole} />}
                            {showAuthModal && (
                                <div className="fixed inset-0 bg-black/60 flex items-center justify-center z-[10000] p-4 backdrop-blur-sm">
                                    <div className="bg-white p-8 rounded-2xl shadow-2xl w-full max-w-sm animate-[fadeIn_0.2s_ease-out] relative">
                                        <button onClick={() => setShowAuthModal(false)} className="absolute top-4 right-4 text-gray-400 hover:text-gray-600"><Icon name="x" size={20} /></button>
                                        <div className="text-center mb-6">
                                            <div className="w-16 h-16 bg-indigo-100 text-indigo-600 rounded-full flex items-center justify-center mx-auto mb-4"><Icon name="user" size={32} /></div>
                                            <h3 className="text-xl font-bold text-gray-900">{authMode === 'login' ? 'ログイン' : '新規登録'}</h3>
                                            <p className="text-sm text-gray-500 mt-1">{authMode === 'login' ? 'アカウントにログインしてください' : '新しいアカウントを作成します'}</p>
                                        </div>
                                        <div className="space-y-4">
                                            <div>
                                                <label className="text-xs font-bold text-gray-500 uppercase tracking-wider ml-1">ユーザー名</label>
                                                <input className="w-full border-2 border-gray-100 p-3 rounded-xl mt-1 focus:border-indigo-500 outline-none transition-colors" placeholder="Username" value={authForm.username} onChange={e => setAuthForm({ ...authForm, username: e.target.value })} />
                                            </div>
                                            <div>
                                                <label className="text-xs font-bold text-gray-500 uppercase tracking-wider ml-1">パスワード</label>
                                                <input className="w-full border-2 border-gray-100 p-3 rounded-xl mt-1 focus:border-indigo-500 outline-none transition-colors" type="password" placeholder="Password" value={authForm.password} onChange={e => setAuthForm({ ...authForm, password: e.target.value })} />
                                            </div>
                                            {authError && <div className="text-xs text-red-500 bg-red-50 p-2 rounded-lg border border-red-100">{authError}</div>}
                                            <button onClick={handleAuth} className="w-full bg-indigo-600 text-white py-3 rounded-xl font-bold shadow-lg shadow-indigo-200 hover:bg-indigo-700 transition-all active:scale-[0.98] mt-2">{authMode === 'login' ? 'ログイン' : '作成'}</button>
                                            <div className="text-center pt-4 border-t border-gray-50">
                                                <button onClick={() => { setAuthMode(authMode === 'login' ? 'signup' : 'login'); setAuthError(null); }} className="text-sm text-indigo-600 font-bold hover:underline">
                                                    {authMode === 'login' ? 'アカウントをお持ちでない方はこちら' : '既にアカウントをお持ちの方はこちら'}
                                                </button>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            )}
                            {showRegionRuleEditor && <RegionRuleEditor rules={regionRules} worldData={worldData} onSave={(r) => { handleSaveRegionRules(r); setShowRegionRuleEditor(false); }} onClose={() => setShowRegionRuleEditor(false)} />}
                            {showAdminPanel && (
                                <div className="fixed inset-0 bg-black/50 flex items-center justify-center z-[9999] p-4">
                                    <div className="bg-white p-6 rounded-lg shadow-xl w-full max-w-md">
                                        <div className="flex justify-between items-center mb-4">
                                            <h3 className="text-lg font-bold text-gray-800">管理パネル</h3>
                                            <button onClick={() => setShowAdminPanel(false)} className="text-gray-500"><Icon name="x" size={18} /></button>
                                        </div>
                                        <div className="space-y-4">
                                            <div className="flex items-center justify-between bg-yellow-50 border border-yellow-200 p-3 rounded">
                                                <div>
                                                    <div className="text-sm font-bold text-yellow-800">未承認の記事 (申請)</div>
                                                    <div className="text-xs text-yellow-600">承認待ち: {articles.filter(a => !a.isApproved).length}件 / 著者をメンバーに招待できます。</div>
                                                </div>
                                                <button onClick={() => {
                                                    setTimelineFilters(prev => ({ ...prev, onlyUnapproved: true, onlyApproved: false }));
                                                    setViewMode('list');
                                                    setShowAdminPanel(false);
                                                }} className="px-3 py-1.5 bg-yellow-600 text-white rounded text-sm hover:bg-yellow-700">確認する</button>
                                            </div>
                                            <div className="flex items-center justify-between">
                                                <div>
                                                    <div className="text-sm font-bold">メンバー管理</div>
                                                    <div className="text-xs text-gray-500">メンバーの追加・削除を行います</div>
                                                </div>
                                                <div>
                                                    <button onClick={() => { setShowMemberManager(true); setShowAdminPanel(false); }} className="px-3 py-1.5 bg-indigo-600 text-white rounded text-sm">開く</button>
                                                </div>
                                            </div>
                                            <div className="flex items-center justify-between">
                                                <div>
                                                    <div className="text-sm font-bold">地図レイヤー管理</div>
                                                    <div className="text-xs text-gray-500">複数の地図レイヤーを管理します</div>
                                                </div>
                                                <div>
                                                    {/* Just a placeholder, main UI is below */}
                                                </div>
                                            </div>
                                            <div className="border border-indigo-100 rounded bg-indigo-50 p-3">
                                                <MapLayerManager
                                                    layers={worldData?.mapLayers || (worldData?.mapImageUrl ? [{ id: 'default', name: '標準マップ', url: worldData.mapImageUrl }] : [])}
                                                    onUpdate={handleMapLayersUpdate}
                                                    storage={storage}
                                                    appContextId={appContextId}
                                                />
                                            </div>

                                            <div className="flex items-center justify-between">
                                                <div>
                                                    <div className="text-sm font-bold">地域タグ自動付与</div>
                                                    <div className="text-xs text-gray-500">座標に応じたタグ割り当てルールを設定します</div>
                                                </div>
                                                <div className="flex gap-2">
                                                    <button onClick={handleReapplyRegionTags} className="px-3 py-1.5 bg-gray-500 text-white rounded text-sm hover:bg-gray-600" title="現在のルールに基づいてタグを再計算・追加します">再適用</button>
                                                    <button onClick={() => { setShowRegionRuleEditor(true); setShowAdminPanel(false); }} className="px-3 py-1.5 bg-emerald-600 text-white rounded text-sm">編集</button>
                                                </div>
                                            </div>
                                            <div className="flex items-center justify-between pt-4 border-t">
                                                <div>
                                                    <div className="text-sm font-bold">Discord Webhook設定</div>
                                                    <div className="text-xs text-gray-500">記事更新通知の送信先</div>
                                                </div>
                                                <button onClick={async () => {
                                                    const currentUrl = worldData?.discordWebhookUrl || '';
                                                    const newUrl = prompt('Discord Webhook URLを入力:', currentUrl);
                                                    if (newUrl !== null) {
                                                        try {
                                                            const { doc, updateDoc } = window.firebaseModules;
                                                            await updateDoc(doc(db, 'artifacts', appContextId, 'public', 'data', 'worlds', worldId), { discordWebhookUrl: newUrl });
                                                            alert('Webhook URLを保存しました');
                                                        } catch (e) { alert('保存失敗: ' + e.message); }
                                                    }
                                                }} className="px-3 py-1.5 bg-indigo-500 text-white rounded text-sm">設定</button>
                                            </div>
                                            <div className="flex items-center justify-between pt-4 border-t">
                                                <div>
                                                    <div className="text-sm font-bold">Googleスプレッドシート連携 (GAS)</div>
                                                    <div className="text-xs text-gray-500">疑似アカウント作成用のGAS URL</div>
                                                </div>
                                                <button onClick={async () => {
                                                    const currentUrl = worldData?.spreadsheetProxyUrl || '';
                                                    const newUrl = prompt('GAS Web App URLを入力:', currentUrl);
                                                    if (newUrl !== null) {
                                                        try {
                                                            const { doc, updateDoc } = window.firebaseModules;
                                                            await updateDoc(doc(db, 'artifacts', appContextId, 'public', 'data', 'worlds', worldId), { spreadsheetProxyUrl: newUrl });
                                                            alert('GAS連携URLを保存しました');
                                                        } catch (e) { alert('保存失敗: ' + e.message); }
                                                    }
                                                }} className="px-3 py-1.5 bg-green-500 text-white rounded text-sm">設定</button>
                                            </div>
                                            {/* スプレッドシートフィールドマッピング設定 */}
                                            <div className="flex flex-col gap-2 pt-4 border-t">
                                                <div>
                                                    <div className="text-sm font-bold">スプレッドシート値マッピング</div>
                                                    <div className="text-xs text-gray-500">記事内シートのセル値を統計フィールドとして使用</div>
                                                </div>

                                                {/* 既存マッピング一覧 */}
                                                <div className="space-y-1 max-h-40 overflow-y-auto">
                                                    {(worldData?.sheetFieldMappings || []).map((m, idx) => (
                                                        <div key={idx} className="flex items-center gap-2 bg-gray-50 p-1.5 rounded text-xs">
                                                            <span className="font-mono bg-white px-2 py-0.5 rounded border">{m.cell}</span>
                                                            <span className="text-gray-400">→</span>
                                                            <span className="flex-1 font-bold text-indigo-700">{m.field}</span>
                                                            <button onClick={async () => {
                                                                if (!confirm(`マッピング「${m.cell}→${m.field}」を削除しますか？`)) return;
                                                                try {
                                                                    const newMappings = (worldData?.sheetFieldMappings || []).filter((_, i) => i !== idx);
                                                                    const { doc, updateDoc } = window.firebaseModules;
                                                                    await updateDoc(doc(db, 'artifacts', appContextId, 'public', 'data', 'worlds', worldId), {
                                                                        sheetFieldMappings: newMappings
                                                                    });
                                                                } catch (e) { alert('削除失敗: ' + e.message); }
                                                            }} className="text-red-500 hover:text-red-700 px-1" title="削除">✕</button>
                                                        </div>
                                                    ))}
                                                    {(!worldData?.sheetFieldMappings || worldData.sheetFieldMappings.length === 0) && (
                                                        <div className="text-xs text-gray-400 italic py-2">マッピングはまだありません</div>
                                                    )}
                                                </div>

                                                {/* 新規追加ボタン */}
                                                <button onClick={async () => {
                                                    const cell = prompt('セルアドレスを入力（例: A2, B3）');
                                                    if (!cell) return;

                                                    const field = prompt('フィールド名を入力（例: year, status, population）');
                                                    if (!field) return;

                                                    try {
                                                        const currentMappings = worldData?.sheetFieldMappings || [];
                                                        const newMapping = { cell: cell.toUpperCase().trim(), field: field.trim() };

                                                        // 重複チェック
                                                        if (currentMappings.some(m => m.cell === newMapping.cell)) {
                                                            alert(`セル「${newMapping.cell}」は既に登録されています`);
                                                            return;
                                                        }

                                                        const newMappings = [...currentMappings, newMapping];
                                                        const { doc, updateDoc } = window.firebaseModules;
                                                        await updateDoc(doc(db, 'artifacts', appContextId, 'public', 'data', 'worlds', worldId), {
                                                            sheetFieldMappings: newMappings
                                                        });
                                                        alert(`マッピング「${newMapping.cell}→${newMapping.field}」を追加しました`);
                                                    } catch (e) { alert('追加失敗: ' + e.message); }
                                                }} className="px-3 py-1.5 bg-cyan-500 text-white rounded text-sm self-start hover:bg-cyan-600 flex items-center gap-1">
                                                    <span>＋</span> マッピング追加
                                                </button>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            )}
                        </div></div>
                    </div >
                </div >
            );
        };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>

</html>